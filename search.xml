<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>前端监控</title>
    <url>/2020/06/02/Monitor/</url>
    <content><![CDATA[<h1 id="相关文章"><a href="#相关文章" class="headerlink" title="相关文章"></a>相关文章</h1><p><a href="http://www.zhufengpeixun.cn/2020/html/101.monitor.html" target="_blank" rel="noopener">http://www.zhufengpeixun.cn/2020/html/101.monitor.html</a></p>
]]></content>
      <categories>
        <category>前端监控</category>
      </categories>
      <tags>
        <tag>前端监控</tag>
      </tags>
  </entry>
  <entry>
    <title>《深入浅出 React和Redux》</title>
    <url>/2020/05/25/Books-Digests/</url>
    <content><![CDATA[<h1 id="React"><a href="#React" class="headerlink" title="React"></a>React</h1><p>1、我们在JSX中看到一个组件使用了onClick，但是并没有产生直接使用onclick的HTML，而是使用事件委托的方式处理点击事件，无论有多少个onClick出现，其实最后都只在DOM树上添加了一个事件处理函数，挂在最高层的DOM节点上。所有的点击事件都被这个事件处理函数捕获，然后根据具体组件分配给特定函数。<br>    因为React控制了组件的生命周期，在unmount的时候自然能够清除相关的所有事件处理函数，内存泄漏也不再是一个问题。</p>
<p>2、试试            </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">使用 <span class="string">` create-react-app `</span> 命令创建项目</span><br><span class="line">执行 <span class="string">` npm run eject`</span> 将隐藏在 <span class="string">` react-scripts `</span> 中的一系列技术栈配置都显示出来 (不可逆)</span><br></pre></td></tr></table></figure>

<p>3、纯函数，指的是没有任何副作用，输出完全依赖输入的函数，两次函数调用如果输入相同，得到的结果也绝对相同。</p>
<p>4、web前端开发关于性能优化有一个原则：<code>尽量减少DOM操作</code>。虽然DOM操作也只是一些简单的JavaScript语句，但是DOM操作会引起浏览器对网页进行重新布局，重新绘制，这就是一个比JavaScript语句执行慢很多的过程。</p>
<p>5、<code>分而治之</code> 把问题分解为多个小问题，拆分组件。</p>
<p>6、prop是组件的对外接口，state是组件的内部状态，对外用prop，对内用state。</p>
<p>7、</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Counter</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span></span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">    <span class="keyword">this</span>.onClickIncrementButton = <span class="keyword">this</span>.onClickIncrementButton.bind(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">this</span>.onClickInDecrementButton = <span class="keyword">this</span>.onClickDecrementButton.bind(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">this</span>.state = &#123;</span><br><span class="line">        count: props.initValue || <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>(1) 如果一个组件需要定义自己的构造函数，一定要在构造函数的第一行通过super调用父类也就是React.Component的构造函数。如果在构造函数中没有调用super(props)，那么组件实例被构造之后，类实例的所有成员函数就无法通过this.props访问到父组件传递过来的props值。<br>(2) 在Count的构造函数中还给两个成员函数绑定了当前this的执行环境，因为ES6方法创建的React组件类并不自动给我们绑定this到当前实例对象。<br>(3) 在构造函数中可以通过参数props获得传入prop值，在其他函数中比如render中，可以通过this.props访问传入prop的值。</p>
<p>8、在开发环境中定义 propTypes, 在开发过程中避免犯错，但是生产环境做propTypes检查没什么帮助，还要消耗CPU计算资源。在生产环境用插件<code>babel-react-optimize</code>，生产环境安装可以去掉propTypes。</p>
<p>9、组件的生命周期的三个阶段：</p>
<ul>
<li>装载过程(Mount)，也就是把组件第一次在DOM树中渲染的过程；</li>
<li>更新过程(Update)，当组件被重新渲染的过程；</li>
<li>卸载过程(Unmount)，组件从DOM中删除的过程。</li>
</ul>
<p>9.1、装载过程</p>
<ul>
<li>constructor</li>
<li>getInitialState</li>
<li>getDefaultProps</li>
<li>componentWillMount</li>
<li>render</li>
<li>componentDidMount</li>
</ul>
]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>摘要</tag>
      </tags>
  </entry>
  <entry>
    <title>React Hooks</title>
    <url>/2020/05/25/React-Hooks/</url>
    <content><![CDATA[<h1 id="解决的问题"><a href="#解决的问题" class="headerlink" title="解决的问题"></a>解决的问题</h1><ul>
<li>在组件之间复用状态逻辑很难,可能要用到render props和高阶组件，React 需要为共享状态逻辑提供更好的原生途径，Hook 使你在无需修改组件结构的情况下复用状态逻辑</li>
<li>复杂组件变得难以理解，Hook 将组件中相互关联的部分拆分成更小的函数（比如设置订阅或请求数据）</li>
</ul>
<h1 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h1><ul>
<li>只能在函数最外层调用 Hook。不要在循环、条件判断或者子函数中调用。</li>
<li>只能在 React 的函数组件中调用 Hook。</li>
</ul>
<h1 id="useState"><a href="#useState" class="headerlink" title="useState"></a>useState</h1><ul>
<li>useState 就是一个 Hook</li>
<li>通过在函数组件里调用它来给组件添加一些内部 state,React 会在重复渲染时保留这个 state</li>
<li>useState 会返回一对值：当前状态和一个让你更新它的函数，你可以在事件处理函数中或其他一些地方调用这个函数。它类似 class 组件的 this.setState，但是它不会把新的 state 和旧的 state 进行合并</li>
<li>useState 唯一的参数就是初始 state<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const [state, setState] = useState(initialState);</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="1】-alert会“捕获”点击按钮时候的状态"><a href="#1】-alert会“捕获”点击按钮时候的状态" class="headerlink" title="1】 alert会“捕获”点击按钮时候的状态"></a>1】 alert会“捕获”点击按钮时候的状态</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123;useState&#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Counter</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> [number,setNumber] = useState(<span class="number">0</span>);</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">alertNumber</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">        alert(number);</span><br><span class="line">      &#125;,<span class="number">3000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        &lt;&gt;</span><br><span class="line">            &lt;p&gt;&#123;number&#125;&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">            &lt;button onClick=&#123;()=&gt;setNumber(number+1)&#125;&gt;+&lt;/</span>button&gt;</span><br><span class="line">            &lt;button onClick=&#123;alertNumber&#125;&gt;alertNumber&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">        &lt;/</span>&gt;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Counter;</span><br></pre></td></tr></table></figure>

<p>点击 <code>alertNumber</code>按钮一次， 再点击 <code>+</code>按钮两次，number变为 2， 3秒钟后alert 0 </p>
<h3 id="2】-函数式更新"><a href="#2】-函数式更新" class="headerlink" title="2】 函数式更新"></a>2】 函数式更新</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123;useState&#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Counter</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> [number,setNumber] = useState(<span class="number">0</span>);</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">alertNumber</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">        setNumber(<span class="function"><span class="params">number</span>=&gt;</span>number+<span class="number">1</span>) <span class="comment">// 函数式更新</span></span><br><span class="line">      &#125;,<span class="number">3000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        &lt;&gt;</span><br><span class="line">            &lt;p&gt;&#123;number&#125;&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">            &lt;button onClick=&#123;()=&gt;setNumber(number+1)&#125;&gt;+&lt;/</span>button&gt;</span><br><span class="line">            &lt;button onClick=&#123;alertNumber&#125;&gt;alertNumber&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">        &lt;/</span>&gt;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Counter;</span><br></pre></td></tr></table></figure>

<p>如果新的 state 需要通过使用先前的 state 计算得出，那么可以将函数传递给 setNumber。该函数将接收先前的 state，并返回一个更新后的值。</p>
<h3 id="3】惰性初始state"><a href="#3】惰性初始state" class="headerlink" title="3】惰性初始state"></a>3】惰性初始state</h3><p>initialState初始状态参数只会在组件初始渲染的时候调用，后续渲染会被忽略<br>与 class 组件中的 setState 方法不同，useState 不会自动合并更新对象。你可以用函数式的 setState 结合展开运算符来达到合并更新对象的效果</p>
<h3 id="4】性能优化"><a href="#4】性能优化" class="headerlink" title="4】性能优化"></a>4】性能优化</h3><h4 id="Object-is"><a href="#Object-is" class="headerlink" title="Object.is"></a>Object.is</h4><p>调用 State Hook 的更新函数并传入当前的 state 时，React 将跳过子组件的渲染及 effect 的执行。（React 使用 Object.is 比较算法 来比较 state。）</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123;useState&#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Counter</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> [state,setNumber] = useState(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;<span class="attr">number</span>: <span class="number">0</span>, <span class="attr">name</span>: <span class="string">'计数器'</span>&#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"Counter render"</span>);</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        &lt;&gt;</span><br><span class="line">            &lt;p&gt;&#123;state.name&#125;：&#123;state.number&#125;&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">            &lt;button onClick=&#123;()=&gt;setNumber(&#123;...state, number: state.number + 1&#125;)&#125;&gt;+&lt;/</span>button&gt;</span><br><span class="line">            &lt;button onClick=&#123;()=&gt;setNumber(state)&#125;&gt;old state +&lt;/button&gt;</span><br><span class="line">        &lt;<span class="regexp">/&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp">export default Counter;</span></span><br></pre></td></tr></table></figure>

<p>点击 <code>+</code> 按钮会输出 Counter render 组件刷新<br>点击 <code>old state +</code> 不更改数据，会刷新一次，之后都不会刷新组件</p>
<h4 id="减少渲染次数"><a href="#减少渲染次数" class="headerlink" title="减少渲染次数"></a>减少渲染次数</h4><h5 id="useCallback"><a href="#useCallback" class="headerlink" title="useCallback"></a>useCallback</h5><p>减少渲染次数</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 情况一</span></span><br><span class="line"><span class="keyword">import</span> React, &#123;useState&#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Counter</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> [number,setNumber] = useState(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">const</span> [name,setName] = useState(<span class="string">'test'</span>);</span><br><span class="line">    <span class="comment">// 会在每次渲染的时候都会生成一个新的函数</span></span><br><span class="line">    <span class="keyword">const</span> addClick = <span class="function"><span class="params">()</span>=&gt;</span> setNumber(number+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        &lt;&gt;</span><br><span class="line">            &lt;p&gt;&#123;name&#125;：&#123;number&#125;&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">            &lt;button onClick=&#123;addClick&#125;&gt;+&lt;/</span>button&gt;</span><br><span class="line">        &lt;<span class="regexp">/&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp">export default Counter;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ 添加了useCallback之后</span></span><br><span class="line"><span class="regexp">import React, &#123;useState, useCallback&#125; from 'react';</span></span><br><span class="line"><span class="regexp">let lastAddClick;</span></span><br><span class="line"><span class="regexp">function Counter()&#123;</span></span><br><span class="line"><span class="regexp">    const [number,setNumber] = useState(0);</span></span><br><span class="line"><span class="regexp">    const [name,setName] = useState('test');</span></span><br><span class="line"><span class="regexp">    /</span><span class="regexp">/ 添加了 useCallback，后面置了一个空数组</span></span><br><span class="line"><span class="regexp">    const addClick = useCallback(()=&gt; setNumber(number+1), []);</span></span><br><span class="line"><span class="regexp">    /</span><span class="regexp">/ 只有在依赖的变量发生变化的时候才会重新生成</span></span><br><span class="line"><span class="regexp">    /</span><span class="regexp">/ const addClick = useCallback(()=&gt; setNumber(number+1), [number]);</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">    console.log(lastAddClick === addClick);</span></span><br><span class="line"><span class="regexp">    lastAddClick = addClick;</span></span><br><span class="line"><span class="regexp">    return (</span></span><br><span class="line"><span class="regexp">        &lt;&gt;</span></span><br><span class="line"><span class="regexp">            &lt;p&gt;&#123;name&#125;：&#123;number&#125;&lt;/</span>p&gt;</span><br><span class="line">            &lt;button onClick=&#123;addClick&#125;&gt;+&lt;/button&gt;</span><br><span class="line">        &lt;<span class="regexp">/&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp">export default Counter;</span></span><br></pre></td></tr></table></figure>

<p>第一次是false，点击按钮可以看到后面都是 true<br>将line27注释打开，这里的number就是依赖的变量，所以这里当number改变的时候，都会重新生成 addClick</p>
<h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 情况一</span></span><br><span class="line"><span class="keyword">import</span> React, &#123;useState&#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span>(<span class="params">props</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"Child render"</span>);</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;button onClick=&#123;props.addClick&#125;&gt;&#123;props.data.number&#125;&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">  )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">function App()&#123;</span></span><br><span class="line"><span class="regexp">  const [number, setNumber] = useState(0);</span></span><br><span class="line"><span class="regexp">  const [name, setName] = useState('test');</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">  const data = &#123;number&#125;</span></span><br><span class="line"><span class="regexp">  const addClick = ()=&gt;setNumber(number+1);</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">  return (</span></span><br><span class="line"><span class="regexp">    &lt;div&gt;</span></span><br><span class="line"><span class="regexp">      &lt;input type="text" value=&#123;name&#125; onChange=&#123;e =&gt; setName(e.target.value)&#125; /</span>&gt;</span><br><span class="line">      &lt;Child addClick=&#123;addClick&#125; data=&#123;data&#125; /&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp">export default App;</span></span><br></pre></td></tr></table></figure>

<p>input框中改变input 的值触发onChange，<code>App</code> 和 <code>Child</code> 都会渲染<br>点击Child的button，改变number的值，<code>App</code> 和 <code>Child</code> 都会渲染</p>
<p>子组件Child是一个纯函数，希望只有当props改变的时候才会渲染Child组件</p>
<h5 id="1】-memo"><a href="#1】-memo" class="headerlink" title="1】 memo"></a>1】 memo</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123;useState, memo&#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line">Child = memo(Child);</span><br></pre></td></tr></table></figure>

<h5 id="2】-useCallback"><a href="#2】-useCallback" class="headerlink" title="2】 useCallback"></a>2】 useCallback</h5><p>这里每次App组件渲染的时候都会重新生成addClick，改变如下：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">+ <span class="keyword">import</span> React, &#123;useState, useCallback, memo&#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> lastAddClick;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [number, setNumber] = useState(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">const</span> [name, setName] = useState(<span class="string">'test'</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> data = &#123;number&#125;</span><br><span class="line">+  <span class="comment">// 第二个参数表示此函数缓存依赖的变量，如果变量变了，会生成新的函数</span></span><br><span class="line">+  <span class="keyword">const</span> addClick = useCallback(<span class="function"><span class="params">()</span>=&gt;</span>setNumber(number+<span class="number">1</span>), [number]);</span><br><span class="line">+  <span class="built_in">console</span>.log(<span class="string">"addClick:"</span>, addClick === lastAddClick);</span><br><span class="line">+  lastAddClick = addClick;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;input type=<span class="string">"text"</span> value=&#123;name&#125; onChange=&#123;e =&gt; setName(e.target.value)&#125; /&gt;</span><br><span class="line">      &lt;Child addClick=&#123;addClick&#125; data=&#123;data&#125; /&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp">function Child(props)&#123;</span></span><br><span class="line"><span class="regexp">  console.log("Child render");</span></span><br><span class="line"><span class="regexp">  return (</span></span><br><span class="line"><span class="regexp">    &lt;button onClick=&#123;props.addClick&#125;&gt;&#123;props.data.number&#125;&lt;/</span>button&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line">Child = memo(Child);</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> App;</span><br></pre></td></tr></table></figure>

<p>第一次进来的时候 addClick: false，之后改变name的值时 都是true，只有改变 addClick函数缓存依赖的变量number时，才会重新生成，输出true</p>
<p>这里 <code>const data = {number}</code>每次App函数渲染的时候也都重新生成了</p>
<h5 id="3】useMemo"><a href="#3】useMemo" class="headerlink" title="3】useMemo"></a>3】useMemo</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">+ <span class="keyword">import</span> React, &#123;useState, useCallback, useMemo&#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> lastAddClick;</span><br><span class="line">+ <span class="keyword">let</span> lastData;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [number, setNumber] = useState(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">const</span> [name, setName] = useState(<span class="string">'test'</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> data = useMemo(<span class="function"><span class="params">()</span>=&gt;</span>(&#123;number&#125;),[number]);</span><br><span class="line">  <span class="keyword">const</span> addClick = useCallback(<span class="function"><span class="params">()</span>=&gt;</span>setNumber(number+<span class="number">1</span>),[number]);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"addClick:"</span>, lastAddClick === addClick);</span><br><span class="line">  lastAddClick = addClick;</span><br><span class="line"></span><br><span class="line">+  <span class="built_in">console</span>.log(<span class="string">"data:"</span>, lastData === data); <span class="comment">// 可以看到，一开始进来false，改变inpu中的值为true，点击按钮改变number 的值为false</span></span><br><span class="line">+  lastData = data;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;input type=<span class="string">"text"</span> value=&#123;name&#125; onChange=&#123;e =&gt; setName(e.target.value)&#125; /&gt;</span><br><span class="line">      &lt;Child addClick=&#123;addClick&#125; data=&#123;data&#125; /&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  )</span></span><br><span class="line"><span class="regexp">&#125;;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">function Child(props)&#123;</span></span><br><span class="line"><span class="regexp">  console.log("Child render");</span></span><br><span class="line"><span class="regexp">  return (</span></span><br><span class="line"><span class="regexp">    &lt;button onClick=&#123;props.addClick&#125;&gt;&#123;props.data.number&#125;&lt;/</span>button&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;;</span><br><span class="line">Child = memo(Child);</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> App;</span><br></pre></td></tr></table></figure>

<h3 id="5】注意事项"><a href="#5】注意事项" class="headerlink" title="5】注意事项"></a>5】注意事项</h3><blockquote>
<p>只能在函数最外层调用 Hook。不要在循环、条件判断或者子函数中调用。</p>
</blockquote>
<p>因为react内部hook是以链表的形式一个一个按顺序存储的，如下情况，一次if判断，存储 ① ② ③，第二次if判断只存储 ① ② ，它是通过前后存储的hook按顺序判断的，少了一个就会出错。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123;useState, useEffect&#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [number, setNumber] = useState(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">const</span> [visible, setVisible] = useState(<span class="literal">false</span>);</span><br><span class="line">  <span class="keyword">if</span> (number % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">      useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">          setVisible(<span class="literal">true</span>);</span><br><span class="line">      &#125;, [number]);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">          setVisible(<span class="literal">false</span>);</span><br><span class="line">      &#125;, [number]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">          &lt;p&gt;&#123;number&#125;&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">          &lt;p&gt;&#123;visible &amp;&amp; &lt;div&gt;visible&lt;/</span>div&gt;&#125;&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">          &lt;button onClick=&#123;() =&gt; setNumber(number + 1)&#125;&gt;+&lt;/</span>button&gt;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp">export default App;</span></span><br></pre></td></tr></table></figure>

<h1 id="useReducer"><a href="#useReducer" class="headerlink" title="useReducer"></a>useReducer</h1><p>hooks的作者就是redux的作者</p>
<ul>
<li>useState 的替代方案。它接收一个形如 (state, action) =&gt; newState 的 reducer，并返回当前的 state 以及与其配套的 dispatch 方法</li>
<li>在某些场景下，useReducer 会比 useState 更适用，例如 state 逻辑较复杂且包含多个子值，或者下一个 state 依赖于之前的 state 等</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123;useReducer&#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> initialState = &#123;<span class="attr">number</span>: <span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">const</span> INCREMENT = <span class="string">'increment'</span>;</span><br><span class="line"><span class="keyword">const</span> DECREMENT = <span class="string">'decrement'</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reducer</span>(<span class="params">state, action</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">switch</span> (action.type) &#123;</span><br><span class="line">    <span class="keyword">case</span> INCREMENT:</span><br><span class="line">      <span class="keyword">return</span> &#123;<span class="attr">number</span>: state.number + <span class="number">1</span>&#125;;</span><br><span class="line">    <span class="keyword">case</span> DECREMENT:</span><br><span class="line">      <span class="keyword">return</span> &#123;<span class="attr">number</span>: state.number - <span class="number">1</span>&#125;;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">return</span> state;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [state, dispatch] = useReducer(reducer, initialState);</span><br><span class="line">  <span class="comment">// 这里的 initialState 就是 state的初始值</span></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;p&gt;&#123;state.number&#125;&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">      &lt;button onClick=&#123;()=&gt;dispatch(&#123;type: INCREMENT&#125;)&#125;&gt;+&lt;/</span>button&gt;</span><br><span class="line">      &lt;button onClick=&#123;()=&gt;dispatch(&#123;<span class="attr">type</span>: DECREMENT&#125;)&#125;&gt;-&lt;/button&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  )</span></span><br><span class="line"><span class="regexp">&#125;;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">export default App;</span></span><br></pre></td></tr></table></figure>

<p>如上，点<code>+</code>加一，点<code>-</code>减一</p>
<p>useState是基于useReducer实现的，基于上面的useReducer自己实现useState</p>
<p>原生useState</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123;useState&#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">let</span> initialState = &#123;<span class="attr">number</span>: <span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [state, setState] = useState(initialState);</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;p&gt;&#123;state.number&#125;&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">      &lt;button onClick=&#123;()=&gt;setState(&#123;number: state.number+1&#125;)&#125;&gt;+&lt;/</span>button&gt;</span><br><span class="line">      &lt;button onClick=&#123;()=&gt;setState(&#123;<span class="attr">number</span>: state.number<span class="number">-1</span>&#125;)&#125;&gt;-&lt;/button&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  )</span></span><br><span class="line"><span class="regexp">&#125;;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">export default App;</span></span><br></pre></td></tr></table></figure>

<p>自定义useState</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123;useCallback, useReducer&#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">let</span> initialState = &#123;<span class="attr">number</span>: <span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义hooks</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">useState</span>(<span class="params">initialState</span>)</span>&#123; <span class="comment">// 内部就是用的useReducer</span></span><br><span class="line">  <span class="keyword">const</span> reducer = useCallback(<span class="function">(<span class="params">state,action</span>)=&gt;</span>action.payload);</span><br><span class="line">  <span class="comment">// 不用useCallback也可以，优化而已</span></span><br><span class="line">  <span class="comment">// const reducer = (state,action)=&gt;action.payload;</span></span><br><span class="line">  <span class="keyword">const</span> [state, dispatch] = useReducer(reducer, initialState); <span class="comment">// 这里的initialState就是上一行 (state,action) 中的state</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">setState</span>(<span class="params">payload</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 调dispatch方法 派发action</span></span><br><span class="line">    dispatch(&#123;payload&#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> [state, setState]; <span class="comment">// 这里state有，setState需要自己实现</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [state, setState] = useState(initialState);</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;p&gt;&#123;state.number&#125;&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">      &lt;button onClick=&#123;()=&gt;setState(&#123;number: state.number+1&#125;)&#125;&gt;+&lt;/</span>button&gt;</span><br><span class="line">      &lt;button onClick=&#123;()=&gt;setState(&#123;<span class="attr">number</span>: state.number<span class="number">-1</span>&#125;)&#125;&gt;-&lt;/button&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  )</span></span><br><span class="line"><span class="regexp">&#125;;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">export default App;</span></span><br></pre></td></tr></table></figure>

<h1 id="useContext"><a href="#useContext" class="headerlink" title="useContext"></a>useContext</h1><ul>
<li>接收一个 context 对象（React.createContext 的返回值）并返回该 context 的当前值</li>
<li>当前的 context 值由上层组件中距离当前组件最近的 &lt;MyContext.Provider&gt; 的 value prop 决定</li>
<li>当组件上层最近的 &lt;MyContext.Provider&gt; 更新时，该 Hook 会触发重渲染，并使用最新传递给 MyContext provider 的 context value 值</li>
<li>useContext(MyContext) 相当于 class 组件中的 static contextType = MyContext 或者 &lt;MyContext.Consumer&gt;</li>
<li>useContext(MyContext) 只是让你能够读取 context 的值以及订阅 context 的变化。你仍然需要在上层组件树中使用 &lt;MyContext.Provider&gt; 来为下层组件提供 context</li>
</ul>
<p>不使用useContext时的用法</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123;useState, useContext&#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">let</span> MyContext = React.createContext();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Counter</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;MyContext.Consumer&gt;</span><br><span class="line">      &#123;</span><br><span class="line">        value =&gt; (</span><br><span class="line">          &lt;div&gt;</span><br><span class="line">            &lt;p&gt;&#123;value.state.number&#125;&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">            &lt;button onClick=&#123;()=&gt;value.setState(&#123;number: value.state.number+1&#125;)&#125;&gt;+&lt;/</span>button&gt;</span><br><span class="line">          &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">        )</span></span><br><span class="line"><span class="regexp">      &#125;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>MyContext.Consumer&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [state, setState] = useState(&#123;<span class="attr">number</span>: <span class="number">0</span>&#125;);</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">   &lt;MyContext.Provider value=&#123;&#123;state, setState&#125;&#125;&gt;</span><br><span class="line">     &lt;Counter /&gt;</span><br><span class="line">   &lt;<span class="regexp">/MyContext.Provider&gt;</span></span><br><span class="line"><span class="regexp">  )</span></span><br><span class="line"><span class="regexp">&#125;;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">export default App;</span></span><br></pre></td></tr></table></figure>

<p>使用useContext</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123;useState, useContext&#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">let</span> MyContext = React.createContext();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Counter</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">let</span> &#123;state, setState&#125; = useContext(MyContext);</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;p&gt;&#123;state.number&#125;&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">      &lt;button onClick=&#123;()=&gt;setState(&#123;number: state.number+1&#125;)&#125;&gt;+&lt;/</span>button&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp">function App()&#123;</span></span><br><span class="line"><span class="regexp">  const [state, setState] = useState(&#123;number: 0&#125;);</span></span><br><span class="line"><span class="regexp">  return (</span></span><br><span class="line"><span class="regexp">   &lt;MyContext.Provider value=&#123;&#123;state, setState&#125;&#125;&gt;</span></span><br><span class="line"><span class="regexp">     &lt;Counter /</span>&gt;</span><br><span class="line">   &lt;<span class="regexp">/MyContext.Provider&gt;</span></span><br><span class="line"><span class="regexp">  )</span></span><br><span class="line"><span class="regexp">&#125;;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">export default App;</span></span><br></pre></td></tr></table></figure>

<h1 id="effect"><a href="#effect" class="headerlink" title="effect"></a>effect</h1><ul>
<li>在函数组件主体内（这里指在 React 渲染阶段）改变 DOM、添加订阅、设置定时器、记录日志以及执行其他包含副作用的操作都是不被允许的，因为这可能会产生莫名其妙的 bug 并破坏 UI 的一致性</li>
<li>使用 useEffect 完成副作用操作。赋值给 useEffect 的函数会在组件渲染到屏幕之后执行。你可以把 effect 看作从 React 的纯函数式世界通往命令式世界的逃生通道</li>
<li>useEffect 就是一个 Effect Hook，给函数组件增加了操作副作用的能力。它跟 class 组件中的 componentDidMount、componentDidUpdate 和 componentWillUnmount 具有相同的用途，只不过被合并成了一个 API</li>
<li>该 Hook 接收一个包含命令式、且可能有副作用代码的函数</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123;useState, useEffect&#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [state, setState] = useState(&#123;<span class="attr">number</span>: <span class="number">0</span>&#125;);</span><br><span class="line">  <span class="comment">// useEffect里的函数会在 componentDidMount、componentDidUpdate后进行调用</span></span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">document</span>.title = state.number;</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">   &lt;div&gt;</span><br><span class="line">     &lt;p&gt;&#123;state.number&#125;&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">     &lt;button onClick=&#123;()=&gt;setState(&#123;number: state.number+1&#125;)&#125;&gt;+&lt;/</span>button&gt;</span><br><span class="line">   &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  )</span></span><br><span class="line"><span class="regexp">&#125;;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">export default App;</span></span><br></pre></td></tr></table></figure>

<p>点击<code>+</code>页面数字变化，title也跟着变化</p>
<h2 id="1】调过effect进行性能优化"><a href="#1】调过effect进行性能优化" class="headerlink" title="1】调过effect进行性能优化"></a>1】调过effect进行性能优化</h2><ul>
<li>如果某些特定值在两次重渲染之间没有发生变化，你可以通知 React 跳过对 effect 的调用，只要传递数组作为 useEffect 的第二个可选参数即可</li>
<li>如果想执行只运行一次的 effect（仅在组件挂载和卸载时执行），可以传递一个空数组（[]）作为第二个参数。这就告诉 React 你的 effect 不依赖于 props 或 state 中的任何值，所以它永远都不需要重复执行</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123;useState, useEffect&#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [state, setState] = useState(&#123;<span class="attr">number</span>: <span class="number">0</span>&#125;);</span><br><span class="line">  <span class="comment">// 如果没有给第二个参数，函数会在每次执行渲染后调用</span></span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">document</span>.title = state.number;</span><br><span class="line">  &#125;, [])</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">   &lt;div&gt;</span><br><span class="line">     &lt;p&gt;&#123;state.number&#125;&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">     &lt;button onClick=&#123;()=&gt;setState(&#123;number: state.number+1&#125;)&#125;&gt;+&lt;/</span>button&gt;</span><br><span class="line">   &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  )</span></span><br><span class="line"><span class="regexp">&#125;;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">export default App;</span></span><br></pre></td></tr></table></figure>

<p>如果没有第二个参数</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123;useState, useEffect&#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [state, setState] = useState(&#123;<span class="attr">number</span>: <span class="number">0</span>&#125;);</span><br><span class="line">  </span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> timer = setInterval(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">      setState(<span class="function"><span class="params">state</span>=&gt;</span>(&#123;<span class="attr">number</span>: state.number+<span class="number">1</span>&#125;));</span><br><span class="line">    &#125;,<span class="number">1000</span>)</span><br><span class="line">  &#125;, [])</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">   &lt;div&gt;</span><br><span class="line">     &lt;p&gt;&#123;state.number&#125;&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">     &lt;button onClick=&#123;()=&gt;setState(&#123;number: state.number+1&#125;)&#125;&gt;+&lt;/</span>button&gt;</span><br><span class="line">   &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  )</span></span><br><span class="line"><span class="regexp">&#125;;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">export default App;</span></span><br></pre></td></tr></table></figure>

<p>有第二个参数，它是每隔1s加一，没有，就会各种叠加，因为没渲染一次，就会生成一个新的定时器。</p>
<h2 id="2】-清除副作用"><a href="#2】-清除副作用" class="headerlink" title="2】 清除副作用"></a>2】 清除副作用</h2><ul>
<li>副作用函数还可以通过返回一个函数来指定如何清除副作用</li>
<li>为防止内存泄漏，清除函数会在组件卸载前执行。另外，如果组件多次渲染，则在执行下一个 effect 之前，上一个 effect 就已被清除</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123;useState, useEffect&#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [state, setState] = useState(&#123;<span class="attr">number</span>: <span class="number">0</span>&#125;);</span><br><span class="line">  </span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> timer = setInterval(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">      setState(<span class="function"><span class="params">state</span>=&gt;</span>(&#123;<span class="attr">number</span>: state.number+<span class="number">1</span>&#125;));</span><br><span class="line">    &#125;,<span class="number">1000</span>)</span><br><span class="line">  &#125;, [])</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">   &lt;div&gt;</span><br><span class="line">     &lt;p&gt;&#123;state.number&#125;&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">     &lt;button onClick=&#123;()=&gt;setState(&#123;number: state.number+1&#125;)&#125;&gt;+&lt;/</span>button&gt;</span><br><span class="line">   &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  )</span></span><br><span class="line"><span class="regexp">&#125;;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">function Counter()&#123;</span></span><br><span class="line"><span class="regexp">  const [visible, setVisible] = useState(true);</span></span><br><span class="line"><span class="regexp">  return (</span></span><br><span class="line"><span class="regexp">    &lt;div&gt;</span></span><br><span class="line"><span class="regexp">      &#123;</span></span><br><span class="line"><span class="regexp">        visible &amp;&amp; &lt;App /</span>&gt;</span><br><span class="line">      &#125;</span><br><span class="line">      &lt;button onClick=&#123;()=&gt;setVisible(<span class="literal">false</span>)&#125;&gt;hide&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>div&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> App;</span><br></pre></td></tr></table></figure>

<p>点击<code>hide</code>按钮后，组件App不显示，页面报错</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">Can't perform a React state update on an unmounted component. This is a no-op, but it indicates a memory leak in your application. To fix, cancel all subscriptions and asynchronous tasks in a useEffect cleanup function.</span><br></pre></td></tr></table></figure>

<p>不能在一个已经卸载的组件上执行状态更新。会出现内存泄露。为了修复，需要在useEffect清理函数中取消所有的订阅和异步任务。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123;useState, useEffect&#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [state, setState] = useState(&#123;<span class="attr">number</span>: <span class="number">0</span>&#125;);</span><br><span class="line">  </span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> timer = setInterval(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">      setState(<span class="function"><span class="params">state</span>=&gt;</span>(&#123;<span class="attr">number</span>: state.number+<span class="number">1</span>&#125;));</span><br><span class="line">    &#125;,<span class="number">1000</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// useEffect会返回一个清理函数，当组件将要卸载的时候会执行清理函数 </span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">      clearInterval(timer);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, [])</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">   &lt;div&gt;</span><br><span class="line">     &lt;p&gt;&#123;state.number&#125;&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">     &lt;button onClick=&#123;()=&gt;setState(&#123;number: state.number+1&#125;)&#125;&gt;+&lt;/</span>button&gt;</span><br><span class="line">   &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  )</span></span><br><span class="line"><span class="regexp">&#125;;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">function Counter()&#123;</span></span><br><span class="line"><span class="regexp">  const [visible, setVisible] = useState(true);</span></span><br><span class="line"><span class="regexp">  return (</span></span><br><span class="line"><span class="regexp">    &lt;div&gt;</span></span><br><span class="line"><span class="regexp">      &#123;</span></span><br><span class="line"><span class="regexp">        visible &amp;&amp; &lt;App /</span>&gt;</span><br><span class="line">      &#125;</span><br><span class="line">      &lt;button onClick=&#123;()=&gt;setVisible(<span class="literal">false</span>)&#125;&gt;hide&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>div&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Counter;</span><br></pre></td></tr></table></figure>

<h2 id="3】useRef"><a href="#3】useRef" class="headerlink" title="3】useRef"></a>3】useRef</h2><ul>
<li>useRef 返回一个可变的 ref 对象，其 .current 属性被初始化为传入的参数（initialValue）</li>
<li>返回的 ref 对象在组件的整个生命周期内保持不变</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> refContainer = useRef(initialValue);</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123;useState, useRef&#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> lastRef;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="comment">// let refObj = React.createRef();</span></span><br><span class="line">  <span class="keyword">let</span> refObj = useRef();</span><br><span class="line">  <span class="built_in">console</span>.log(lastRef === refObj);</span><br><span class="line">  lastRef = refObj;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">getFocus</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    refObj.current.focus()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;input ref=&#123;refObj&#125; /&gt;</span><br><span class="line">      &lt;button onClick=&#123;getFocus&#125;&gt;focus&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>div&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [state, setState] = useState(&#123;<span class="attr">number</span>: <span class="number">0</span>&#125;);</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">   &lt;div&gt;</span><br><span class="line">     &lt;p&gt;&#123;state.number&#125;&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">     &lt;button onClick=&#123;()=&gt;setState(&#123;number: state.number+1&#125;)&#125;&gt;+&lt;/</span>button&gt;</span><br><span class="line">     &lt;Child /&gt;</span><br><span class="line">   &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  )</span></span><br><span class="line"><span class="regexp">&#125;;</span></span><br><span class="line"><span class="regexp">export default App;</span></span><br></pre></td></tr></table></figure>

<p>用 <code>React.createRef</code>时， 每次渲染Child组件都会重新生成 <code>refObj</code><br>用 <code>useRef</code>时，返回的ref对象在组件的整个生命周期内保持不变。</p>
<p>实现useRef</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> currentRefObject;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">useRef</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(!currentRefObject)&#123;</span><br><span class="line">    currentRefObject = &#123;<span class="attr">current</span>: <span class="literal">null</span>&#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> currentRefObject;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4】forwardRef"><a href="#4】forwardRef" class="headerlink" title="4】forwardRef"></a>4】forwardRef</h2><p>现在想把获取焦点按钮放到App组件中，如下</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123;useRef&#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span>(<span class="params">props</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;input ref=&#123;props.ref&#125; /&gt; </span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp">function App()&#123;</span></span><br><span class="line"><span class="regexp">  let refObj = useRef();</span></span><br><span class="line"><span class="regexp">  return (</span></span><br><span class="line"><span class="regexp">   &lt;div&gt;</span></span><br><span class="line"><span class="regexp">     &lt;Child ref=&#123;refObj&#125; /</span>&gt;</span><br><span class="line">     &lt;button onClick=&#123;()=&gt;refObj.current.focus()&#125;&gt;focus&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">   &lt;/</span>div&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> App;</span><br></pre></td></tr></table></figure>

<p>页面会报错</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">Function components cannot be given refs. Attempts to access this ref will fail. Did you mean to use React.forwardRef()?</span><br></pre></td></tr></table></figure>

<p>使用React.forwardRef</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">+<span class="keyword">import</span> React, &#123;useRef&#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line">+<span class="function"><span class="keyword">function</span> <span class="title">Child</span>(<span class="params">props,ref</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line"> +     &lt;input ref=&#123;ref&#125; /&gt; </span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line">+<span class="keyword">let</span> ForwardRefChild = React.forwardRef(Child);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">let</span> refObj = useRef();</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">getFocus</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    refObj.current.focus()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">   &lt;div&gt;</span><br><span class="line">     &lt;ForwardRefChild ref=&#123;refObj&#125; /&gt;</span><br><span class="line">     &lt;button onClick=&#123;getFocus&#125;&gt;focus&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">   &lt;/</span>div&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> App;</span><br></pre></td></tr></table></figure>

<p>直接这样传递的话，Child组件的输入框对象直接暴露给了父组件,也破坏了封装的原则，很危险</p>
<h3 id="useImperativeHandle"><a href="#useImperativeHandle" class="headerlink" title="useImperativeHandle"></a>useImperativeHandle</h3><ul>
<li>useImperativeHandle 可以让你在使用 ref 时自定义暴露给父组件的实例值</li>
<li>在大多数情况下，应当避免使用 ref 这样的命令式代码。useImperativeHandle 应当与 forwardRef 一起使用</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123;useRef, useImperativeHandle&#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span>(<span class="params">props,ref</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">let</span> refObj = useRef();</span><br><span class="line">  useImperativeHandle(ref, () =&gt; (&#123;</span><br><span class="line">    focus()&#123;</span><br><span class="line">      refObj.current.focus();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;),</span><br><span class="line">  )</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;input ref=&#123;refObj&#125; /&gt; </span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp">let ForwardRefChild = React.forwardRef(Child);</span></span><br><span class="line"><span class="regexp">function App()&#123;</span></span><br><span class="line"><span class="regexp">  let refObj = useRef();</span></span><br><span class="line"><span class="regexp">  function getFocus()&#123;</span></span><br><span class="line"><span class="regexp">    refObj.current.focus();</span></span><br><span class="line"><span class="regexp">    refObj.current.value = 'xxxx';</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">  return (</span></span><br><span class="line"><span class="regexp">   &lt;div&gt;</span></span><br><span class="line"><span class="regexp">     &lt;ForwardRefChild ref=&#123;refObj&#125; /</span>&gt;</span><br><span class="line">     &lt;button onClick=&#123;getFocus&#125;&gt;focus&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">   &lt;/</span>div&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> App;</span><br></pre></td></tr></table></figure>

<p>如果不用<code>useImperativeHandle</code>,子组件直接用父组件传递过来的<code>&lt;input ref={ref} /&gt;</code>,当父组件App执行到line22时，就会直接取修改子组件input中的value，现在父组件中<code>getFocus</code>方法只有line21是生效的，因为它调用的focus方法是子组件有暴露给外部的。</p>
<h1 id="useLayoutEffect"><a href="#useLayoutEffect" class="headerlink" title="useLayoutEffect"></a>useLayoutEffect</h1><ul>
<li>其函数签名与 useEffect 相同，但它会在所有的 DOM 变更之后同步调用 effect</li>
<li>可以使用它来读取 DOM 布局并同步触发重渲染</li>
<li>在浏览器执行绘制之前useLayoutEffect内部的更新计划将被同步刷新</li>
<li>尽可能使用标准的 useEffect 以避免阻塞视图更新</li>
</ul>
<p><a href="https://jiafei2333.github.io/html/images/hooks01.png" target="_blank" rel="noopener"></a></p>
<p>如图是浏览器呈现一张页面的过程。<br>在红色分割线左边界面并没有绘制，绿色圈中是布局，蓝色圈中是绘制，页面上能看到效果。<br>如图可以看到 useLayoutEffect 和 useEffect 的执行顺序。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123;useState, useEffect, useLayoutEffect&#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [color, setColor] = useState(<span class="string">'red'</span>);</span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"useEffect"</span>, color);</span><br><span class="line">  &#125;)</span><br><span class="line">  useLayoutEffect(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">    alert(<span class="string">"useLayoutEffect"</span>);</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">   &lt;div&gt;</span><br><span class="line">     &lt;p style=&#123;&#123;<span class="attr">backgroundColor</span>: color&#125;&#125;&gt;背景色&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">     &lt;button onClick=&#123;()=&gt;setColor('red')&#125;&gt;红&lt;/</span>button&gt;</span><br><span class="line">     &lt;button onClick=&#123;()=&gt;setColor(<span class="string">'yellow'</span>)&#125;&gt;黄&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">     &lt;button onClick=&#123;()=&gt;setColor('blue')&#125;&gt;蓝&lt;/</span>button&gt;</span><br><span class="line">   &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  )</span></span><br><span class="line"><span class="regexp">&#125;;</span></span><br><span class="line"><span class="regexp">export default App;</span></span><br></pre></td></tr></table></figure>

<p>点击按钮颜色切换时，先alert <code>useLayoutEffect</code>，界面变色，再console.log出 <code>useEffect</code></p>
<h1 id="自定义hooks"><a href="#自定义hooks" class="headerlink" title="自定义hooks"></a>自定义hooks</h1><ul>
<li>有时候我们会想要在组件之间重用一些状态逻辑</li>
<li>自定义 Hook 可以让你在不增加组件的情况下达到同样的目的</li>
<li>Hook 是一种复用状态逻辑的方式，它不复用 state 本身</li>
<li>事实上 Hook 的每次调用都有一个完全独立的 state</li>
<li>自定义 Hook 更像是一种约定，而不是一种功能。如果函数的名字以 use 开头，并且调用了其他的 Hook，则就称其为一个自定义 Hook</li>
</ul>
<h2 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h2><p>当有2个逻辑相同的组件时，如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123;useState, useEffect&#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Counter1</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [number, setNumber] = useState(<span class="number">0</span>);</span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> timer = setInterval(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">      setNumber(number+<span class="number">1</span>);</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">      clearInterval(timer);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &#123;number&#125;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp">function Counter2()&#123;</span></span><br><span class="line"><span class="regexp">  const [number, setNumber] = useState(0);</span></span><br><span class="line"><span class="regexp">  useEffect(()=&gt;&#123;</span></span><br><span class="line"><span class="regexp">    let timer = setInterval(()=&gt;&#123;</span></span><br><span class="line"><span class="regexp">      setNumber(number+1);</span></span><br><span class="line"><span class="regexp">    &#125;, 1000);</span></span><br><span class="line"><span class="regexp">    return ()=&gt;&#123;</span></span><br><span class="line"><span class="regexp">      clearInterval(timer);</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">  &#125;)</span></span><br><span class="line"><span class="regexp">  return (</span></span><br><span class="line"><span class="regexp">    &lt;div&gt;</span></span><br><span class="line"><span class="regexp">      &#123;number&#125;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>div&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(</span><br><span class="line">    &lt;&gt;</span><br><span class="line">      &lt;Counter1 /&gt;</span><br><span class="line">      &lt;Counter2 /&gt;</span><br><span class="line">    &lt;<span class="regexp">/&gt;,</span></span><br><span class="line"><span class="regexp">  document.getElementById('root')</span></span><br><span class="line"><span class="regexp">);</span></span><br></pre></td></tr></table></figure>

<p>页面上同时展示 每隔1秒 number + 1</p>
<p>使用自定义hooks（<code>函数的名字以 use 开头，并且调用了其他的 Hook</code>），如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123;useState, useEffect&#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">useCounter</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [number, setNumber] = useState(<span class="number">0</span>);</span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> timer = setInterval(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">      setNumber(<span class="built_in">Math</span>.random());</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">      clearInterval(timer);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> number;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Counter1</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">let</span> number = useCounter();</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &#123;number&#125;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp">function Counter2()&#123;</span></span><br><span class="line"><span class="regexp">  let number = useCounter();</span></span><br><span class="line"><span class="regexp">  return (</span></span><br><span class="line"><span class="regexp">    &lt;div&gt;</span></span><br><span class="line"><span class="regexp">      &#123;number&#125;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>div&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(</span><br><span class="line">    &lt;&gt;</span><br><span class="line">      &lt;Counter1 /&gt;</span><br><span class="line">      &lt;Counter2 /&gt;</span><br><span class="line">    &lt;<span class="regexp">/&gt;,</span></span><br><span class="line"><span class="regexp">  document.getElementById('root')</span></span><br><span class="line"><span class="regexp">);</span></span><br></pre></td></tr></table></figure>

<p>这里line8，将number生成了随机数来展示说明，<code>Hook是一种复用状态逻辑的方式，它不复用state本身，事实上Hook的每次调用都有一个完全独立的state</code></p>
<h2 id="中间件"><a href="#中间件" class="headerlink" title="中间件"></a>中间件</h2><h3 id="logger"><a href="#logger" class="headerlink" title="logger"></a>logger</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123;useReducer, useEffect&#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> initialState = &#123;<span class="attr">number</span>: <span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">const</span> INCREMENT = <span class="string">'increment'</span>;</span><br><span class="line"><span class="keyword">const</span> DECREMENT = <span class="string">'decrement'</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reducer</span>(<span class="params">state, action</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">switch</span> (action.type) &#123;</span><br><span class="line">    <span class="keyword">case</span> INCREMENT:</span><br><span class="line">      <span class="keyword">return</span> &#123;<span class="attr">number</span>: state.number + <span class="number">1</span>&#125;;</span><br><span class="line">    <span class="keyword">case</span> DECREMENT:</span><br><span class="line">      <span class="keyword">return</span> &#123;<span class="attr">number</span>: state.number - <span class="number">1</span>&#125;;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">return</span> state;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">+<span class="comment">// 实现redux-logger 在每次状态变更后打印新的状态值；</span></span><br><span class="line">+<span class="comment">// redux中间件，是用新的dispatch替换老的dispatch</span></span><br><span class="line">+<span class="function"><span class="keyword">function</span> <span class="title">useLogger</span>(<span class="params">reducer, initialState</span>)</span>&#123;</span><br><span class="line">+  <span class="keyword">const</span> [state, dispatch] = useReducer(reducer, initialState);</span><br><span class="line">+  <span class="function"><span class="keyword">function</span> <span class="title">loggerDispatch</span>(<span class="params">action</span>)</span>&#123;</span><br><span class="line">+    <span class="built_in">console</span>.log(<span class="string">"老状态:"</span>, state);</span><br><span class="line">+    dispatch(action);</span><br><span class="line">+  &#125;</span><br><span class="line">+  useEffect(<span class="function"><span class="params">()</span>=&gt;</span><span class="built_in">console</span>.log(<span class="string">"新状态"</span>, state));</span><br><span class="line">+  <span class="keyword">return</span> [state, loggerDispatch]</span><br><span class="line">+&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">+  <span class="keyword">const</span> [state, dispatch] = useLogger(reducer, initialState); <span class="comment">// 这里调用 useLogger</span></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;p&gt;&#123;state.number&#125;&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">      &lt;button onClick=&#123;()=&gt;dispatch(&#123;type: INCREMENT&#125;)&#125;&gt;+&lt;/</span>button&gt;</span><br><span class="line">      &lt;button onClick=&#123;()=&gt;dispatch(&#123;<span class="attr">type</span>: DECREMENT&#125;)&#125;&gt;-&lt;/button&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  )</span></span><br><span class="line"><span class="regexp">&#125;;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">export default App;</span></span><br></pre></td></tr></table></figure>

<h3 id="thunk"><a href="#thunk" class="headerlink" title="thunk"></a>thunk</h3><p>thunk里面派发的是函数</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123;useReducer, useEffect&#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> initialState = &#123;<span class="attr">number</span>: <span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">const</span> INCREMENT = <span class="string">'increment'</span>;</span><br><span class="line"><span class="keyword">const</span> DECREMENT = <span class="string">'decrement'</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reducer</span>(<span class="params">state, action</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">switch</span> (action.type) &#123;</span><br><span class="line">    <span class="keyword">case</span> INCREMENT:</span><br><span class="line">      <span class="keyword">return</span> &#123;<span class="attr">number</span>: state.number + <span class="number">1</span>&#125;;</span><br><span class="line">    <span class="keyword">case</span> DECREMENT:</span><br><span class="line">      <span class="keyword">return</span> &#123;<span class="attr">number</span>: state.number - <span class="number">1</span>&#125;;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">return</span> state;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+<span class="function"><span class="keyword">function</span> <span class="title">useThunk</span>(<span class="params">reducer, initialState</span>)</span>&#123;</span><br><span class="line">+  <span class="keyword">const</span> [state, dispatch] = useReducer(reducer, initialState);</span><br><span class="line">+  <span class="function"><span class="keyword">function</span> <span class="title">thunkDispatch</span>(<span class="params">action</span>)</span>&#123;</span><br><span class="line">+    <span class="comment">// 判断是否为函数，这里模拟的是redux-logger，line23的参数是根据line35中的来，这里传入新的dispatch，也就是thunkDispatch</span></span><br><span class="line">+    <span class="keyword">if</span>(<span class="keyword">typeof</span> action === <span class="string">'function'</span>)&#123;</span><br><span class="line">+      action(thunkDispatch, ()=&gt;state);</span><br><span class="line">+    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">+      dispatch(action);</span><br><span class="line">+    &#125;</span><br><span class="line">+  &#125;</span><br><span class="line">+  <span class="keyword">return</span> [state, thunkDispatch]</span><br><span class="line">+&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">+  <span class="keyword">const</span> [state, dispatch] = useThunk(reducer, initialState);</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;p&gt;&#123;state.number&#125;&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">+      &lt;button onClick=&#123;()=&gt;dispatch(function(dispatch, getState)&#123;</span></span><br><span class="line"><span class="regexp">+        dispatch(&#123;type: INCREMENT&#125;)</span></span><br><span class="line"><span class="regexp">+      &#125;)&#125;&gt;+&lt;/</span>button&gt;</span><br><span class="line">      &lt;button onClick=&#123;()=&gt;dispatch(&#123;<span class="attr">type</span>: DECREMENT&#125;)&#125;&gt;-&lt;/button&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  )</span></span><br><span class="line"><span class="regexp">&#125;;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">export default App;</span></span><br></pre></td></tr></table></figure>

<h3 id="promise"><a href="#promise" class="headerlink" title="promise"></a>promise</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123;useReducer, useEffect&#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> initialState = &#123;<span class="attr">number</span>: <span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">const</span> INCREMENT = <span class="string">'increment'</span>;</span><br><span class="line"><span class="keyword">const</span> DECREMENT = <span class="string">'decrement'</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reducer</span>(<span class="params">state, action</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">switch</span> (action.type) &#123;</span><br><span class="line">    <span class="keyword">case</span> INCREMENT:</span><br><span class="line">      <span class="keyword">return</span> &#123;<span class="attr">number</span>: state.number + <span class="number">1</span>&#125;;</span><br><span class="line">    <span class="keyword">case</span> DECREMENT:</span><br><span class="line">      <span class="keyword">return</span> &#123;<span class="attr">number</span>: state.number - <span class="number">1</span>&#125;;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">return</span> state;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+<span class="function"><span class="keyword">function</span> <span class="title">usePromise</span>(<span class="params">reducer, initialState</span>)</span>&#123;</span><br><span class="line">+  <span class="keyword">const</span> [state, dispatch] = useReducer(reducer, initialState);</span><br><span class="line">+  <span class="function"><span class="keyword">function</span> <span class="title">promiseDispatch</span>(<span class="params">action</span>)</span>&#123;</span><br><span class="line">+    <span class="keyword">if</span>(<span class="keyword">typeof</span> action.then === <span class="string">'function'</span>)&#123;</span><br><span class="line">+      action.then(promiseDispatch); <span class="comment">// 点击按钮 1秒 后加1</span></span><br><span class="line">+    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">+      dispatch(action);</span><br><span class="line">+    &#125;</span><br><span class="line">+  &#125;</span><br><span class="line">+  <span class="keyword">return</span> [state, promiseDispatch]</span><br><span class="line">+&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">+  <span class="keyword">const</span> [state, dispatch] = usePromise(reducer, initialState);</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;p&gt;&#123;state.number&#125;&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">+      &lt;button onClick=&#123;()=&gt;dispatch(new Promise(function(resolve)&#123;</span></span><br><span class="line"><span class="regexp">+        setTimeout(()=&gt;&#123;</span></span><br><span class="line"><span class="regexp">+          resolve(&#123;type: INCREMENT&#125;)</span></span><br><span class="line"><span class="regexp">+        &#125;,1000)</span></span><br><span class="line"><span class="regexp">+      &#125;))&#125;&gt;+&lt;/</span>button&gt;</span><br><span class="line">      &lt;button onClick=&#123;()=&gt;dispatch(&#123;<span class="attr">type</span>: DECREMENT&#125;)&#125;&gt;-&lt;/button&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  )</span></span><br><span class="line"><span class="regexp">&#125;;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">export default App;</span></span><br></pre></td></tr></table></figure>

<h2 id="ajax"><a href="#ajax" class="headerlink" title="ajax"></a>ajax</h2><p>新建api.js</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>);</span><br><span class="line"><span class="keyword">let</span> app = express();</span><br><span class="line">app.use(<span class="function"><span class="keyword">function</span> (<span class="params">req, res, next</span>) </span>&#123;</span><br><span class="line">    res.header(<span class="string">'Access-Control-Allow-Origin'</span>, <span class="string">'http://localhost:3000'</span>);</span><br><span class="line">    next();</span><br><span class="line">&#125;);</span><br><span class="line">app.get(<span class="string">'/api/users'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> offset = <span class="built_in">parseInt</span>(req.query.offset);<span class="comment">// 偏移量</span></span><br><span class="line">    <span class="keyword">let</span> limit = <span class="built_in">parseInt</span>(req.query.limit); <span class="comment">// 每页的条数</span></span><br><span class="line">    <span class="keyword">let</span> result = [];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = offset; i &lt; offset + limit; i++) &#123;</span><br><span class="line">        result.push(&#123; <span class="attr">id</span>: i + <span class="number">1</span>, <span class="attr">name</span>: <span class="string">'name'</span> + (i + <span class="number">1</span>) &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    res.json(result);</span><br><span class="line">&#125;);</span><br><span class="line">app.listen(<span class="number">8000</span>);</span><br></pre></td></tr></table></figure>

<p><code>npm install express</code><br><code>node ./api.js</code> 运行后台</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; useState, useEffect, useLayoutEffect &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">useRequest</span>(<span class="params">url</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> limit = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">let</span> [offset, setOffset] = useState(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">let</span> [data, setData] = useState([]);</span><br><span class="line">    <span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">loadMore</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        setData(<span class="literal">null</span>);</span><br><span class="line">        <span class="keyword">let</span> pageData = <span class="keyword">await</span> fetch(<span class="string">`<span class="subst">$&#123;url&#125;</span>?offset=<span class="subst">$&#123;offset&#125;</span>&amp;limit=<span class="subst">$&#123;limit&#125;</span>`</span>)</span><br><span class="line">            .then(<span class="function"><span class="params">response</span> =&gt;</span> response.json());</span><br><span class="line">        setData([...data, ...pageData]);</span><br><span class="line">        setOffset(offset + pageData.length);</span><br><span class="line">    &#125;</span><br><span class="line">    useEffect(loadMore, []);</span><br><span class="line">    <span class="keyword">return</span> [data, loadMore];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> [users, loadMore] = useRequest(<span class="string">'http://localhost:8000/api/users'</span>);</span><br><span class="line">    <span class="keyword">if</span> (users === <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> &lt;div&gt;正在加载中....&lt;/div&gt;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        &lt;&gt;</span><br><span class="line">            &lt;ul&gt;</span><br><span class="line">                &#123;</span><br><span class="line">                    users.map(<span class="function">(<span class="params">item, index</span>) =&gt;</span> &lt;li key=&#123;index&#125;&gt;&#123;item.id&#125;:&#123;item.name&#125;&lt;/li&gt;)</span><br><span class="line">                &#125;</span><br><span class="line">            &lt;<span class="regexp">/ul&gt;</span></span><br><span class="line"><span class="regexp">            &lt;button onClick=&#123;loadMore&#125;&gt;加载更多&lt;/</span>button&gt;</span><br><span class="line">        &lt;<span class="regexp">/&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp">ReactDOM.render(&lt;App /</span>&gt;, <span class="built_in">document</span>.getElementById(<span class="string">'root'</span>));</span><br></pre></td></tr></table></figure>

<h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p><code>useMemo</code>、<code>useCallback</code>、<code>useRef</code><br>本质上都是为了缓存，这些东西在没有hooks之前，在以前我们都用类组件，一但创建就有类的实例，上面的属性也可以存在。但是现在我们用hooks，hooks只能用在函数组件里，函数组件没有this，就没有实例，就没有办法在实例上挂属性和状态。现在就要靠 <code>useMemo</code>、<code>useCallback</code>、<code>useRef</code> 实现缓存。</p>
<h1 id="相关文章"><a href="#相关文章" class="headerlink" title="相关文章"></a>相关文章</h1><p><a href="https://zh-hans.reactjs.org/docs/hooks-intro.html" target="_blank" rel="noopener">https://zh-hans.reactjs.org/docs/hooks-intro.html</a><br><a href="http://www.zhufengpeixun.cn/2020/html/62.5.react-hooks.html" target="_blank" rel="noopener">http://www.zhufengpeixun.cn/2020/html/62.5.react-hooks.html</a></p>
]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
        <tag>React Hooks</tag>
      </tags>
  </entry>
  <entry>
    <title>React+Redux+Antd</title>
    <url>/2020/05/23/React-Redux-Antd/</url>
    <content><![CDATA[<h3 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h3><p><code>npx create-react-app myapp</code></p>
<p>版本：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">"react": "^16.13.1",</span><br><span class="line">"react-dom": "^16.13.1",</span><br><span class="line">"@babel/core": "^7.9.6",</span><br><span class="line">"webpack": "^4.43.0",</span><br></pre></td></tr></table></figure>

<h4 id="安装webpack"><a href="#安装webpack" class="headerlink" title="安装webpack"></a>安装webpack</h4><p><code>npm install --save-dev webpack-cli webpack webpack-merge webpack-dev-server  clean-webpack-plugin</code></p>
<p>具体步骤见 <a href="https://jiafei2333.github.io/2019/10/12/Webpack-base/" target="_blank" rel="noopener">https://jiafei2333.github.io/2019/10/12/Webpack-base/</a></p>
<h4 id="安装loader"><a href="#安装loader" class="headerlink" title="安装loader"></a>安装loader</h4><p><code>npm install style-loader css-loader --save-dev</code><br><code>npm install less less-loader --save-dev</code><br><code>npm install file-loader --save-dev</code></p>
<h4 id="安装babel"><a href="#安装babel" class="headerlink" title="安装babel"></a>安装babel</h4><p><code>npm install @babel/core @babel/preset-env babel-loader --save-dev</code><br><code>npm i @babel/plugin-proposal-class-properties @babel/plugin-proposal-decorators --save-dev</code><br><code>npm install core-js@2 --save</code><br><code>npm install --save-dev @babel/plugin-transform-runtime</code><br><code>npm install --save @babel/runtime</code></p>
<p>具体步骤见 <a href="https://jiafei2333.github.io/2019/11/13/Webpack-js/" target="_blank" rel="noopener">https://jiafei2333.github.io/2019/11/13/Webpack-js/</a></p>
<h4 id="安装开发环境"><a href="#安装开发环境" class="headerlink" title="安装开发环境"></a>安装开发环境</h4><p><code>npm install --save redux</code><br><code>npm install --save react-redux</code><br><code>npm install --save redux-saga</code><br><code>npm install --save react-router-dom</code></p>
<h4 id="基础目录创建"><a href="#基础目录创建" class="headerlink" title="基础目录创建"></a>基础目录创建</h4><p>()[<a href="https://jiafei2333.github.io/html/images/react-redux01.png" target="_blank" rel="noopener">https://jiafei2333.github.io/html/images/react-redux01.png</a> “”]</p>
<h4 id="UI组件库"><a href="#UI组件库" class="headerlink" title="UI组件库"></a>UI组件库</h4><p><code>npm install antd --save</code></p>
<h3 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h3>]]></content>
      <categories>
        <category>React</category>
        <category>Redux</category>
      </categories>
      <tags>
        <tag>React</tag>
        <tag>Redux</tag>
        <tag>Webpack</tag>
        <tag>Antd</tag>
      </tags>
  </entry>
  <entry>
    <title>roadhog-umi-dva</title>
    <url>/2020/04/28/roadhog-umi-dva-antd/</url>
    <content><![CDATA[<h1 id="1-roadhog"><a href="#1-roadhog" class="headerlink" title="1. roadhog"></a>1. roadhog</h1><ul>
<li>roadhog 是基于 webpack 的封装工具，目的是简化 webpack 的配置</li>
<li>提供 server、 build 和 test 三个命令，分别用于本地调试和构建</li>
<li>提供了特别易用的 mock 功能</li>
<li>命令行体验和 create-react-app 一致，配置略有不同，比如默认开启 css modules</li>
<li>还提供了 JSON 格式的配置方式。</li>
</ul>
<p>根目录新建.roadhogrc.mock.js文件 mock本地数据</p>
<h2 id="1-1-内部是如何实现的"><a href="#1-1-内部是如何实现的" class="headerlink" title="1.1 内部是如何实现的"></a>1.1 内部是如何实现的</h2><p>1、本地全局安装<code>npm install roadhog -g</code><br>2、<code>npm root -g</code> 查看全局安装的路径，找到roadhog/package.json<br>可以看到</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="string">"bin"</span>:&#123;</span><br><span class="line">    <span class="string">"roadhog"</span>: <span class="string">"./bin/roadhog.js"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3、查看这个roadhog.js文件，部分源码如下</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/env node</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> spawn = <span class="built_in">require</span>(<span class="string">'cross-spawn'</span>);</span><br><span class="line"><span class="keyword">const</span> chalk = <span class="built_in">require</span>(<span class="string">'chalk'</span>); <span class="comment">// 可以在命令行显示颜色</span></span><br><span class="line"><span class="keyword">const</span> script = process.argv[<span class="number">2</span>];</span><br><span class="line"><span class="comment">//node bin/roadhog.js -v</span></span><br><span class="line"><span class="keyword">switch</span> (script) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"-v"</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"--version"</span>:</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">require</span>(<span class="string">"../package.json"</span>).version);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"build"</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"server"</span>:</span><br><span class="line">        result = spawn.sync(</span><br><span class="line">            <span class="string">"node"</span>,</span><br><span class="line">            [<span class="built_in">require</span>.resolve(<span class="string">`../lib/<span class="subst">$&#123;script&#125;</span>`</span>)],</span><br><span class="line">            &#123; <span class="attr">stdio</span>: <span class="string">"inherit"</span> &#125;</span><br><span class="line">        );</span><br><span class="line">        process.exit(result.status);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`Unknown script <span class="subst">$&#123;chalk.cyan(script)&#125;</span>.`</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>获取到命令行输入的参数 <code>process.argv</code> 根据不同的参数执行相应的文件<br>例如这里执行的是build，在node环境中，读取的是<code>../lib/build.js</code>文件<br>lib/build.js 缩减版如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> webpack = <span class="built_in">require</span>(<span class="string">"webpack"</span>);</span><br><span class="line"><span class="keyword">const</span> chalk = <span class="built_in">require</span>(<span class="string">"chalk"</span>);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doneHandler</span>(<span class="params">err, stats</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(stats.toJson().assets);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">build</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> config = <span class="built_in">require</span>(<span class="string">"lib/config/webpack.config.prod"</span>);</span><br><span class="line">    <span class="keyword">var</span> compiler = webpack(config);</span><br><span class="line">    compiler.run(doneHandler);</span><br><span class="line">&#125;</span><br><span class="line">build();</span><br></pre></td></tr></table></figure>

<p>会去读取 <code>webpack.config.prod</code> 配置文件，再交给webpack编译打包<br>4、lib\config\webpack.config.prod.js 简单配置如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">"path"</span>);</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    entry: <span class="string">"./src/index.js"</span>,</span><br><span class="line">    output: &#123;</span><br><span class="line">        path: path.resolve(<span class="string">'dist'</span>),</span><br><span class="line">        filename: <span class="string">"[name].js"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>5、配置自定义的打包配置<br>根目录新建.roadhogrc 或 .roadhogrc.js</p>
<h1 id="2-UmiJs"><a href="#2-UmiJs" class="headerlink" title="2. UmiJs"></a>2. UmiJs</h1><ul>
<li>UmiJS 是一个类 Next.JS 的 react 开发框架。</li>
<li>他基于一个约定，即 pages 目录下的文件即路由，而文件则导出 react 组件</li>
<li>然后打通从源码到产物的每个阶段，并配以完善的插件体系，让我们能把 umi 的产物部署到各种场景里。</li>
</ul>
<p>约定 src/layouts/index.js 为全局路由，返回一个 React 组件,所以编译顺序是先去编译/layouts/下的index.js,读取到React组件，然后去编译pages下的页面内容。</p>
<p>核心工作：<br>1、动态检测项目，生成配置文件(pages/.umi/history.js|router.js)</p>
<p>会监控pages文件夹，有新的文件生成就改变.umi/文件夹下的配置</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line">fs.watchFile(<span class="string">'**'</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    ...监控文件变化，执行重新生成配置文件的操作</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h1 id="3-dva"><a href="#3-dva" class="headerlink" title="3. dva"></a>3. dva</h1><ul>
<li>基于 redux、redux-saga 和 react-router 的轻量级前端框架。</li>
<li>dva是基于react+redux最佳实践上实现的封装方案，简化了redux和redux-saga使用上的诸多繁琐操作</li>
</ul>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> dva,&#123;connect&#125; <span class="keyword">from</span> <span class="string">'dva'</span>;</span><br><span class="line"><span class="keyword">import</span> keymaster <span class="keyword">from</span> <span class="string">'keymaster'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; Router, Route &#125; <span class="keyword">from</span> <span class="string">'dva/router'</span>;</span><br><span class="line"><span class="comment">//dva react react-dom redux redux-saga react-router react-router-dom history </span></span><br><span class="line"><span class="keyword">const</span> app = dva();</span><br><span class="line"><span class="comment">//redux combineReducers reducer都有自己的状态 </span></span><br><span class="line"><span class="comment">//combineReducers(&#123;counter:counterReducer&#125;)</span></span><br><span class="line"><span class="comment">//总的状态树 state=&#123;counter:0,counter2:0&#125;</span></span><br><span class="line"><span class="keyword">const</span> delay = <span class="function">(<span class="params">millseconds</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve,reject</span>)</span>&#123;</span><br><span class="line">        setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            resolve();</span><br><span class="line">        &#125;,millseconds);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line">app.model(&#123;</span><br><span class="line">    namespace:<span class="string">'counter'</span>,</span><br><span class="line">    state:&#123;<span class="attr">number</span>:<span class="number">0</span>&#125;,</span><br><span class="line">    reducers:&#123;<span class="comment">//接收老状态，返回新状态</span></span><br><span class="line">        add(state)&#123; <span class="comment">//dispatch(&#123;type:'add'&#125;);</span></span><br><span class="line">            <span class="keyword">return</span> &#123;<span class="attr">number</span>:state.number+<span class="number">1</span>&#125;;</span><br><span class="line">        &#125;,</span><br><span class="line">        minus(state)&#123;<span class="comment">//dispatch(&#123;type:'minus'&#125;)</span></span><br><span class="line">            <span class="keyword">return</span> &#123;<span class="attr">number</span>:state.number<span class="number">-1</span>&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 延时操作 调用接口  等待</span></span><br><span class="line">    effects:&#123;</span><br><span class="line">        *asyncAdd(action,&#123;put,call&#125;)&#123; <span class="comment">//redux-saga/effects &#123;put,call&#125;</span></span><br><span class="line">            <span class="keyword">yield</span> call(delay,<span class="number">1000</span>);<span class="comment">//把100传给delay并调用，yield会等待promise完成</span></span><br><span class="line">            <span class="keyword">yield</span> put(&#123;<span class="attr">type</span>:<span class="string">'add'</span>&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    subscriptions:&#123;</span><br><span class="line">        keyboard(&#123;dispatch&#125;)&#123; <span class="comment">// 监听键盘输入，是空格键 就执行add方法</span></span><br><span class="line">            keymaster(<span class="string">'space'</span>,()=&gt;&#123;</span><br><span class="line">                dispatch(&#123;<span class="attr">type</span>:<span class="string">'add'</span>&#125;);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;,</span><br><span class="line">        changeTitle(&#123;history&#125;)&#123; <span class="comment">// 当路径发生变化的时候执行回调函数</span></span><br><span class="line">            setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">                history.listen(<span class="function">(<span class="params">&#123;pathname&#125;</span>)=&gt;</span>&#123;</span><br><span class="line">                    <span class="built_in">document</span>.title = pathname;</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;,<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">app.model(&#123;</span><br><span class="line">    namespace:<span class="string">'counter2'</span>,</span><br><span class="line">    state:&#123;<span class="attr">number</span>:<span class="number">0</span>&#125;,</span><br><span class="line">    reducers:&#123;<span class="comment">//接收老状态，返回新状态</span></span><br><span class="line">        add(state)&#123; <span class="comment">//dispatch(&#123;type:'add'&#125;);</span></span><br><span class="line">            <span class="keyword">return</span> &#123;<span class="attr">number</span>:state.number+<span class="number">1</span>&#125;;</span><br><span class="line">        &#125;,</span><br><span class="line">        minus(state)&#123;<span class="comment">//dispatch(&#123;type:'minus'&#125;)</span></span><br><span class="line">            <span class="keyword">return</span> &#123;<span class="attr">number</span>:state.number<span class="number">-1</span>&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">const</span> Counter = <span class="function">(<span class="params">props</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">            &lt;p&gt;&#123;props.number&#125;&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">            &lt;button onClick=&#123;()=&gt;props.dispatch(&#123;type:'counter/</span>add<span class="string">'&#125;)&#125;&gt;add&lt;/button&gt;</span></span><br><span class="line"><span class="string">            &lt;button onClick=&#123;()=&gt;props.dispatch(&#123;type:'</span>counter/asyncAdd<span class="string">'&#125;)&#125;&gt;asyncAdd&lt;/button&gt;</span></span><br><span class="line"><span class="string">            &lt;button onClick=&#123;()=&gt;props.dispatch(&#123;type:'</span>counter/minus<span class="string">'&#125;)&#125;&gt;-&lt;/button&gt;</span></span><br><span class="line"><span class="string">        &lt;/div&gt;</span></span><br><span class="line"><span class="string">    )</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">const Counter2 = (props)=&gt;&#123;</span></span><br><span class="line"><span class="string">    return (</span></span><br><span class="line"><span class="string">        &lt;div&gt;</span></span><br><span class="line"><span class="string">            &lt;p&gt;&#123;props.number&#125;&lt;/p&gt;</span></span><br><span class="line"><span class="string">            &lt;button onClick=&#123;()=&gt;props.dispatch(&#123;type:'</span>counter2/add<span class="string">'&#125;)&#125;&gt;+&lt;/button&gt;</span></span><br><span class="line"><span class="string">            &lt;button onClick=&#123;()=&gt;props.dispatch(&#123;type:'</span>counter2/minus<span class="string">'&#125;)&#125;&gt;-&lt;/button&gt;</span></span><br><span class="line"><span class="string">        &lt;/div&gt;</span></span><br><span class="line"><span class="string">    )</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">//&#123;counter1:&#123;number:0&#125;,counter2:&#123;number:0&#125;&#125;</span></span><br><span class="line"><span class="string">const ConnectedCounter = connect(</span></span><br><span class="line"><span class="string">    state=&gt;state.counter</span></span><br><span class="line"><span class="string">)(Counter);</span></span><br><span class="line"><span class="string">const ConnectedCounter2 = connect(</span></span><br><span class="line"><span class="string">    state=&gt;state.counter2</span></span><br><span class="line"><span class="string">)(Counter2);</span></span><br><span class="line"><span class="string">app.router(</span></span><br><span class="line"><span class="string">    (&#123;app,history&#125;)=&gt;(</span></span><br><span class="line"><span class="string">        &lt;Router history=&#123;history&#125;&gt;</span></span><br><span class="line"><span class="string">            &lt;&gt;</span></span><br><span class="line"><span class="string">            &lt;Route path="/counter1" component=&#123;ConnectedCounter&#125;/&gt;</span></span><br><span class="line"><span class="string">            &lt;Route path="/counter2" component=&#123;ConnectedCounter2&#125;/&gt;</span></span><br><span class="line"><span class="string">            &lt;/&gt;</span></span><br><span class="line"><span class="string">        &lt;/Router&gt;</span></span><br><span class="line"><span class="string">    )</span></span><br><span class="line"><span class="string">);</span></span><br><span class="line">app.start('#root');</span><br></pre></td></tr></table></figure>

<p>[官网]<a href="https://dvajs.com/guide/" target="_blank" rel="noopener">https://dvajs.com/guide/</a></p>
<p>注意： 这里最后的手写dva可以看一下，都是基于redux react-redux react-router-dom redux-saga connected-react-router history的封装：<a href="http://www.zhufengpeixun.cn/2020/html/31.dva.html#t43.1%20src\index.js" target="_blank" rel="noopener">http://www.zhufengpeixun.cn/2020/html/31.dva.html#t43.1%20src\index.js</a></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; routerMiddleware, connectRouter, ConnectedRouter &#125; <span class="keyword">from</span> <span class="string">"connected-react-router"</span>;</span><br></pre></td></tr></table></figure>

<h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><ul>
<li>roadhog 是基于 webpack 的封装工具，目的是简化 webpack 的配置</li>
<li>umi 可以简单地理解为 roadhog + 路由，思路类似 next.js/nuxt.js，辅以一套插件机制，目的是通过框架的方式简化 React 开发</li>
<li>dva 目前是纯粹的数据流，和 umi 以及 roadhog 之间并没有相互的依赖关系，可以分开使用也可以一起使用，个人觉得 umi + dva 是比较搭的</li>
</ul>
<h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><p><a href="http://www.zhufengpeixun.cn/2020/html/30.cms-8-roadhog.html" target="_blank" rel="noopener">http://www.zhufengpeixun.cn/2020/html/30.cms-8-roadhog.html</a><br><a href="http://www.zhufengpeixun.cn/2020/html/30.cms-10-umi.html" target="_blank" rel="noopener">http://www.zhufengpeixun.cn/2020/html/30.cms-10-umi.html</a><br><a href="https://v2.umijs.org/zh/guide/" target="_blank" rel="noopener">https://v2.umijs.org/zh/guide/</a><br><a href="http://www.zhufengpeixun.cn/2020/html/30.cms-12-dva.html" target="_blank" rel="noopener">http://www.zhufengpeixun.cn/2020/html/30.cms-12-dva.html</a></p>
]]></content>
      <categories>
        <category>框架</category>
      </categories>
      <tags>
        <tag>roadhog</tag>
        <tag>umi</tag>
        <tag>dva</tag>
        <tag>ant.design</tag>
      </tags>
  </entry>
  <entry>
    <title>react-router-dom</title>
    <url>/2020/04/25/React-router-dom/</url>
    <content><![CDATA[<ul>
<li>不同的路径渲染不同的组件</li>
<li>有两种实现方式<ul>
<li>HashRouter:利用hash实现路由切换</li>
<li>BrowserRouter: 利用h5 Api实现路由的切换</li>
</ul>
</li>
</ul>
<h1 id="h5中的路由"><a href="#h5中的路由" class="headerlink" title="h5中的路由"></a>h5中的路由</h1><h2 id="hash"><a href="#hash" class="headerlink" title="hash"></a>hash</h2><blockquote>
<p>默认地址栏后面会加hash，如 <a href="http://www.a.com/index.html#" target="_blank" rel="noopener">http://www.a.com/index.html#</a></p>
</blockquote>
<p>hash 模式 前端路由的特点，不刷新，但是可以根据路径显示不同的内容<br>hash 不是浏览器的规范，优点：兼容性比较好，缺点是不美观 (#/…)</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#/home"</span>&gt;</span>首页<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#/abort"</span>&gt;</span>关于<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"container"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>点击a标签，可以看到路由变化了，但是页面没有改变</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1)初始化路径</span><br><span class="line">一般启动服务的时候初始进来是index.html，需要跳转到/页面或者本身的页面</span><br><span class="line">```javascript</span><br><span class="line">window.location.hash = window.location.hash.slice(1) || &apos;/&apos;;</span><br><span class="line">// window.location.hash.slice(1) 如果进来是#/user就把值加过去 或者 &apos;/&apos; ，‘#’ hash是不用写的，默认就有</span><br></pre></td></tr></table></figure>

<p>2)监听<br>根据路径渲染div里面的内容</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">container.innerHTML = <span class="built_in">window</span>.location.hash;</span><br><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">'hashchange'</span>,<span class="function"><span class="keyword">function</span></span>&#123;</span><br><span class="line">    container.innerHTML = <span class="built_in">window</span>.location.hash;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="history"><a href="#history" class="headerlink" title="history"></a>history</h2><blockquote>
<p>window.history<br>window.history.pushState({},null,’/‘)</p>
</blockquote>
<p>默认我们的h5 history api 它不支持强制刷新，会找不到对应的路径（比如当前是/页面，通过window.history.pushState({},null,’/user’),路由改变为/user,这时候刷新，页面会显示 Cannot GET /user）<br>如果页面找不到对应的路径，可以跳转到首页，在通过window.history.pushState跳到这个/user页面上</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">onclick</span>=<span class="string">"push('/')"</span>&gt;</span>首页<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">onclick</span>=<span class="string">"push('/abort')"</span>&gt;</span>关于<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"container"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="keyword">function</span> <span class="title">push</span>(<span class="params">path</span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">window</span>.history.pushState(&#123;&#125;,<span class="literal">null</span>,path);</span></span><br><span class="line">        container.innerHTML = path;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>点击a标签可以看到页面和路径都变化，且浏览器最上角的前进后退按钮历史数据一直在叠加，可以通过window.history.length看到</p>
<p>1）默认前进、后退是不会调用pushState方法的</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">'popstate'</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="comment">// 只有在点击[前进][后退]按钮时才触发</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">window</span>.location); <span class="comment">// 路径相关的信息</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">window</span>.history); <span class="comment">// 历史相关的方法</span></span><br><span class="line">    container.innerHTML = <span class="built_in">window</span>.location.pathname;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h1 id="React中的路由"><a href="#React中的路由" class="headerlink" title="React中的路由"></a>React中的路由</h1><p>HashRouter | BrowserRouter</p>
<blockquote>
<p>npm install –save react-router-dom</p>
</blockquote>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span>;</span><br><span class="line"><span class="keyword">import</span> Home <span class="keyword">from</span> <span class="string">'./pages/Home'</span>;</span><br><span class="line"><span class="keyword">import</span> User <span class="keyword">from</span> <span class="string">'./pages/User'</span>;</span><br><span class="line"><span class="keyword">import</span> Profile <span class="keyword">from</span> <span class="string">'./pages/Profile'</span>;</span><br><span class="line"><span class="comment">// react路由需要引入 内部提供了很多组件</span></span><br><span class="line"><span class="comment">// 提供一个路由容器，里面放着一条条的路由</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果用BrowserRouter webpack 插件 history-fallback-api 如果路径找不到会跳转到首页</span></span><br><span class="line"><span class="comment">// 这里用HashRouter</span></span><br><span class="line"><span class="keyword">import</span> &#123;HashRouter <span class="keyword">as</span> Router, Route&#125; <span class="keyword">from</span> <span class="string">'react-router-dom'</span>;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(</span><br><span class="line">  <span class="comment">// 和react-redux一样 主要提供一些属性集合方法，Router提供属性和方法</span></span><br><span class="line">  &lt;Router&gt;</span><br><span class="line">    &lt;Route path=<span class="string">"/"</span> exact component=&#123;Home&#125; /&gt; </span><br><span class="line">    &lt;Route path=<span class="string">"/user"</span> component=&#123;User&#125; /&gt;</span><br><span class="line">    &lt;Route path=<span class="string">"/profile"</span> component=&#123;Profile&#125; /&gt;</span><br><span class="line">  &lt;<span class="regexp">/Router&gt;,</span></span><br><span class="line"><span class="regexp">  document.getElementById('root')</span></span><br><span class="line"><span class="regexp">);</span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ exact 精确匹配</span></span><br></pre></td></tr></table></figure>

<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>Router提供属性和方法，父组件提供，子组件(Route)拿<br>在Home组件中打印</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">render() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.props);</span><br></pre></td></tr></table></figure>

<p>打印如下：<br><img src="http://jiafei2333.github.io/html/images/react-router1-Picture.png" alt><br>这里的 history、location 不是原生windows上的，是自己封装的 math指匹配到的信息：路径、路径参数、是否是精确匹配</p>
<h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><p>1) HashRouter 要提供一个对象 history location match, 传递给后代组件 ，更新视图(setState)<br>2) Route 路由 主要的工作是拿到父组件中路径 和自己身上的path比较是否相等，如果相等渲染自己的component即可</p>
<h3 id="1"><a href="#1" class="headerlink" title="1."></a>1.</h3><p>index.js</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;HashRouter <span class="keyword">as</span> Router, Route&#125; <span class="keyword">from</span> <span class="string">'./react-router-dom'</span>;</span><br></pre></td></tr></table></figure>

<p>新建 ./src/react-router-dom/index.js</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> HashRouter <span class="keyword">from</span> <span class="string">'./HashRouter'</span>;</span><br><span class="line"><span class="keyword">import</span> Route <span class="keyword">from</span> <span class="string">'./Route'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> &#123;</span><br><span class="line">    HashRouter,</span><br><span class="line">    Route</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>新建 ./src/react-router-dom/HashRouter.js</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> Context <span class="keyword">from</span> <span class="string">'./context'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 提供一个对象</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HashRouter</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    render() &#123;</span><br><span class="line">        <span class="keyword">let</span> value = &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            &lt;Context.Provider value=&#123;value&#125;&gt;</span><br><span class="line">                &#123;<span class="keyword">this</span>.props.children&#125;</span><br><span class="line">            &lt;<span class="regexp">/Context.Provider&gt;</span></span><br><span class="line"><span class="regexp">        );</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp">export default HashRouter;</span></span><br></pre></td></tr></table></figure>

<p>父组件提供值</p>
<p>新建 ./src/react-router-dom/Route.js</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> context <span class="keyword">from</span> <span class="string">'./context'</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Route</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> contextType = context;</span><br><span class="line">    render() &#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                Route</span><br><span class="line">            &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">        );</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp">export default Route;</span></span><br></pre></td></tr></table></figure>

<p>子组件拿到值去匹配</p>
<p>新建 ./src/react-router-dom/context.js</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 提供一个上下文环境</span></span><br><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> React.createContext();</span><br></pre></td></tr></table></figure>

<h3 id="2"><a href="#2" class="headerlink" title="2."></a>2.</h3><p>HashRouter.js</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> Context <span class="keyword">from</span> <span class="string">'./context'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 提供一个对象</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HashRouter</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    state = &#123;</span><br><span class="line">        location: &#123;</span><br><span class="line">            <span class="comment">// 如果地址是#/user就直接赋过去，如果是起始localhost:3000,就加一个'#/'，‘#’因为是hash会自动添加</span></span><br><span class="line">            pathname: <span class="built_in">window</span>.location.hash.slice(<span class="number">1</span>) || <span class="string">'/'</span>,</span><br><span class="line">            state: <span class="literal">null</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    componentDidMount() &#123;</span><br><span class="line">        <span class="comment">// 组件加载完毕 默认跳转到首页，如果有就采用默认的</span></span><br><span class="line">        <span class="built_in">window</span>.location.hash = <span class="built_in">window</span>.location.hash.slice(<span class="number">1</span>) || <span class="string">'/'</span>;</span><br><span class="line">        <span class="built_in">window</span>.addEventListener(<span class="string">'hashchange'</span>,()=&gt;&#123;</span><br><span class="line">            <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">                location:&#123;</span><br><span class="line">                    ...this.state.location,</span><br><span class="line">                    pathname: <span class="built_in">window</span>.location.hash.slice(<span class="number">1</span>)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    render() &#123;</span><br><span class="line">        <span class="keyword">let</span> value = &#123;</span><br><span class="line">            location: <span class="keyword">this</span>.state.location</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            &lt;Context.Provider value=&#123;value&#125;&gt;</span><br><span class="line">                &#123;<span class="keyword">this</span>.props.children&#125;</span><br><span class="line">            &lt;<span class="regexp">/Context.Provider&gt;</span></span><br><span class="line"><span class="regexp">        );</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp">export default HashRouter;</span></span><br></pre></td></tr></table></figure>

<p>Route.js</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> context <span class="keyword">from</span> <span class="string">'./context'</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Route</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> contextType = context;</span><br><span class="line">    render() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.context); <span class="comment">// 获取到的是父组件(Router)提供的value的值</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.context.location.path);</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                Route</span><br><span class="line">            &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">        );</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp">export default Route;</span></span><br></pre></td></tr></table></figure>

<p>浏览器地址改为 <a href="http://localhost:3000/#/user" target="_blank" rel="noopener">http://localhost:3000/#/user</a> console.log输出： 3个location的对象和/user</p>
<h3 id="3"><a href="#3" class="headerlink" title="3."></a>3.</h3><p>在Route中匹配组件</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> context <span class="keyword">from</span> <span class="string">'./context'</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Route</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> contextType = context;</span><br><span class="line">    render() &#123;</span><br><span class="line">        <span class="comment">// 这个path属性是当前真正的请求路径</span></span><br><span class="line">        <span class="keyword">let</span> pathname = <span class="keyword">this</span>.context.location.pathname;</span><br><span class="line">        <span class="comment">// 获取我们在&lt;Route&gt;&lt;/Route&gt; 定义的路径和组件</span></span><br><span class="line">        <span class="comment">// exact 表示是否严格匹配</span></span><br><span class="line">        <span class="keyword">let</span> &#123; path, <span class="attr">component</span>: Component, exact=<span class="literal">false</span> &#125; = <span class="keyword">this</span>.props;</span><br><span class="line">        <span class="keyword">let</span> props = &#123; <span class="comment">// 将context中的属性传递下去，之前在Home组件中 this.props能打印出来</span></span><br><span class="line">            ...this.context <span class="comment">// context中有location</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果路径渲染成功，就渲染对应的组件</span></span><br><span class="line">        <span class="keyword">if</span>(path === pathname)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">Component</span> &#123;<span class="attr">...props</span>&#125; /&gt;</span></span></span><br><span class="line"><span class="xml">        &#125;</span></span><br><span class="line"><span class="xml">        // 否则就不进行渲染操作</span></span><br><span class="line"><span class="xml">        return null;</span></span><br><span class="line"><span class="xml">    &#125;</span></span><br><span class="line"><span class="xml">&#125;</span></span><br><span class="line"><span class="xml">export default Route;</span></span><br></pre></td></tr></table></figure>

<p>将地址栏地址改为<a href="http://localhost:3000/#/user" target="_blank" rel="noopener">http://localhost:3000/#/user</a> | <a href="http://localhost:3000/#/" target="_blank" rel="noopener">http://localhost:3000/#/</a> | <a href="http://localhost:3000/#/profile" target="_blank" rel="noopener">http://localhost:3000/#/profile</a> 都能匹配到相应的组件</p>
<h3 id="4-Link"><a href="#4-Link" class="headerlink" title="4. Link"></a>4. Link</h3><h4 id="4-1-原生"><a href="#4-1-原生" class="headerlink" title="4.1 原生"></a>4.1 原生</h4><p>index.js</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span>;</span><br><span class="line"><span class="keyword">import</span> Home <span class="keyword">from</span> <span class="string">'./pages/Home'</span>;</span><br><span class="line"><span class="keyword">import</span> User <span class="keyword">from</span> <span class="string">'./pages/User'</span>;</span><br><span class="line"><span class="keyword">import</span> Profile <span class="keyword">from</span> <span class="string">'./pages/Profile'</span>;</span><br><span class="line"><span class="comment">// Link</span></span><br><span class="line"><span class="keyword">import</span> &#123;HashRouter <span class="keyword">as</span> Router, Route, Link&#125; <span class="keyword">from</span> <span class="string">'react-router-dom'</span>;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(</span><br><span class="line">  &lt;Router&gt;</span><br><span class="line">    &lt;&gt;</span><br><span class="line">      &lt;nav&gt;</span><br><span class="line">        &lt;Link to=&#123;&#123;<span class="attr">pathname</span>:<span class="string">'/'</span>, <span class="attr">state</span>:&#123;<span class="attr">title</span>:<span class="string">'哈哈'</span>&#125;&#125;&#125;&gt;首页&lt;<span class="regexp">/Link&gt;</span></span><br><span class="line"><span class="regexp">        &lt;Link to="/u</span>ser<span class="string">"&gt;用户&lt;/Link&gt;</span></span><br><span class="line"><span class="string">        &lt;Link to="</span>/profile<span class="string">"&gt;个人中心&lt;/Link&gt;</span></span><br><span class="line"><span class="string">      &lt;/nav&gt;</span></span><br><span class="line"><span class="string">      &lt;Route path="</span>/<span class="string">" exact component=&#123;Home&#125; /&gt; </span></span><br><span class="line"><span class="string">      &lt;Route path="</span>/user<span class="string">" component=&#123;User&#125; /&gt;</span></span><br><span class="line"><span class="string">      &lt;Route path="</span>/profile<span class="string">" component=&#123;Profile&#125; /&gt;</span></span><br><span class="line"><span class="string">    &lt;/&gt;</span></span><br><span class="line"><span class="string">  &lt;/Router&gt;,</span></span><br><span class="line"><span class="string">  document.getElementById('root')</span></span><br><span class="line"><span class="string">);</span></span><br></pre></td></tr></table></figure>

<p>这里Link在页面上hash路由解析成如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;nav&gt;</span><br><span class="line">    &lt;a href=<span class="string">"#/"</span>&gt;首页&lt;<span class="regexp">/a&gt;</span></span><br><span class="line"><span class="regexp">    &lt;a href="#/u</span>ser<span class="string">"&gt;用户&lt;/a&gt;</span></span><br><span class="line">    &lt;a href="#/profile"&gt;个人中心&lt;/a&gt;</span><br><span class="line">&lt;<span class="regexp">/nav&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="4-2-手写"><a href="#4-2-手写" class="headerlink" title="4.2 手写"></a>4.2 手写</h4><p>新建./src/react-router-dom/Link.js</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> context <span class="keyword">from</span> <span class="string">'./context'</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Link</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> contextType = context;</span><br><span class="line">    render()&#123;</span><br><span class="line">        <span class="keyword">let</span> &#123;to&#125; = <span class="keyword">this</span>.props;</span><br><span class="line">        <span class="comment">// 这里有可能是hash也有可能是browser的，所以都采用方法点击的方式传递事件(hash的话直接href=”#/“跳转)</span></span><br><span class="line">        <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">a</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span>=&gt;</span>&#123;</span></span><br><span class="line"><span class="xml">            this.context.history.push(to) // 调用父组件的history的push方法，把写在Link上的to属性传过去</span></span><br><span class="line"><span class="xml">        &#125;&#125;&gt;&#123;this.props.children&#125;<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>HashRouter.js</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> Context <span class="keyword">from</span> <span class="string">'./context'</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HashRouter</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    state = &#123;</span><br><span class="line">        location: &#123;</span><br><span class="line">            pathname: <span class="built_in">window</span>.location.hash.slice(<span class="number">1</span>) || <span class="string">'/'</span>,</span><br><span class="line">            state: <span class="literal">null</span> <span class="comment">// 初始为null</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    componentDidMount() &#123;</span><br><span class="line">        <span class="built_in">window</span>.location.hash = <span class="built_in">window</span>.location.hash.slice(<span class="number">1</span>) || <span class="string">'/'</span>;</span><br><span class="line">        <span class="built_in">window</span>.addEventListener(<span class="string">'hashchange'</span>,()=&gt;&#123;</span><br><span class="line">            <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">                location:&#123;</span><br><span class="line">                    ...this.state.location,</span><br><span class="line">                    pathname: <span class="built_in">window</span>.location.hash.slice(<span class="number">1</span>),</span><br><span class="line">                    state: <span class="keyword">this</span>.locationState, <span class="comment">// 只有跳转的时候才会携带状态，如果用户刷新页面就会丢失，比如有一个列表，点击跳转详情页</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    locationState = <span class="literal">null</span>;</span><br><span class="line">    render() &#123;</span><br><span class="line">        <span class="keyword">let</span> value = &#123;</span><br><span class="line">            location: <span class="keyword">this</span>.state.location,</span><br><span class="line">            history: &#123;</span><br><span class="line">                push: <span class="function">(<span class="params">to</span>)=&gt;</span>&#123;</span><br><span class="line">                    <span class="keyword">if</span>(<span class="keyword">typeof</span> to === <span class="string">'object'</span>)&#123;</span><br><span class="line">                        <span class="keyword">let</span> &#123;pathname, state&#125; = to;</span><br><span class="line">                        <span class="keyword">this</span>.locationState = state; <span class="comment">// 跳转时先存起来当前的状态</span></span><br><span class="line">                        <span class="built_in">window</span>.location.hash = pathname;</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        <span class="comment">// 跳转路径，其实就是改变hash值</span></span><br><span class="line">                        <span class="built_in">window</span>.location.hash = to; <span class="comment">// 改变hash上面line16就会监听到从而改变state</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            &lt;Context.Provider value=&#123;value&#125;&gt;</span><br><span class="line">                &#123;<span class="keyword">this</span>.props.children&#125;</span><br><span class="line">            &lt;<span class="regexp">/Context.Provider&gt;</span></span><br><span class="line"><span class="regexp">        );</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp">export default HashRouter;</span></span><br></pre></td></tr></table></figure>

<h3 id="5-exact"><a href="#5-exact" class="headerlink" title="5. exact"></a>5. exact</h3><h4 id="5-1-path-to-regexp"><a href="#5-1-path-to-regexp" class="headerlink" title="5.1 path-to-regexp"></a>5.1 path-to-regexp</h4><p>将路径转化为正则</p>
<p>这个包react默认引用，不用安装</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 将路径转化成正则</span></span><br><span class="line"><span class="keyword">const</span> pathToRegExp = <span class="built_in">require</span>(<span class="string">"path-to-regexp"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> url = <span class="string">'/user'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> reg = pathToRegExp(url,[],&#123;<span class="attr">end</span>: <span class="literal">false</span>&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(reg); <span class="comment">// /^\/user\/?(?=\/|$)/i 打印匹配出的路径</span></span><br></pre></td></tr></table></figure>

<h4 id="5-2"><a href="#5-2" class="headerlink" title="5.2"></a>5.2</h4><p>Route.js</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> context <span class="keyword">from</span> <span class="string">'./context'</span>;</span><br><span class="line"><span class="keyword">import</span> pathToRegExp <span class="keyword">from</span> <span class="string">'path-to-regexp'</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Route</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> contextType = context;</span><br><span class="line">    render() &#123;</span><br><span class="line">        <span class="keyword">let</span> pathname = <span class="keyword">this</span>.context.location.pathname;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">let</span> &#123; path, <span class="attr">component</span>: Component, exact=<span class="literal">false</span> &#125; = <span class="keyword">this</span>.props;</span><br><span class="line">        <span class="keyword">let</span> reg = pathToRegExp(path,[],&#123;<span class="attr">end</span>: exact&#125;); <span class="comment">// 获取每个Route中path上的路径正则</span></span><br><span class="line">        <span class="keyword">let</span> props = &#123;</span><br><span class="line">            ...this.context </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 正则匹配路径</span></span><br><span class="line">        <span class="keyword">if</span>(reg.test(pathname))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">Component</span> &#123;<span class="attr">...props</span>&#125; /&gt;</span></span></span><br><span class="line"><span class="xml">        &#125;</span></span><br><span class="line"><span class="xml">        return null;</span></span><br><span class="line"><span class="xml">    &#125;</span></span><br><span class="line"><span class="xml">&#125;</span></span><br><span class="line"><span class="xml">export default Route;</span></span><br></pre></td></tr></table></figure>

<h3 id="6-Switch"><a href="#6-Switch" class="headerlink" title="6. Switch"></a>6. Switch</h3><p>这里使用原生的，当如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;Route path=<span class="string">"/"</span> exact=&#123;<span class="literal">false</span>&#125; component=&#123;Home&#125; /&gt; </span><br><span class="line">&lt;Route path=<span class="string">"/user"</span> component=&#123;User&#125; /&gt;</span><br><span class="line">&lt;Route path=<span class="string">"/user"</span> component=&#123;User&#125; /&gt;</span><br><span class="line">&lt;Route path=<span class="string">"/profile"</span> component=&#123;Profile&#125; /&gt;</span><br></pre></td></tr></table></figure>

<p>这里匹配到一个/user之后会继续向下匹配，当有多个匹配成功则页面上显示多个组件，使用 Switch之后</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;HashRouter <span class="keyword">as</span> Router, Route, Link, Switch&#125; <span class="keyword">from</span> <span class="string">'react-router-dom'</span>;</span><br><span class="line">&lt;Router&gt;</span><br><span class="line">    &lt;Switch&gt;</span><br><span class="line">        &lt;Route path=<span class="string">"/"</span> exact=&#123;<span class="literal">true</span>&#125; component=&#123;Home&#125; /&gt; </span><br><span class="line">        &lt;Route path=<span class="string">"/user"</span> component=&#123;User&#125; /&gt;</span><br><span class="line">        &lt;Route path=<span class="string">"/user"</span> component=&#123;User&#125; /&gt;</span><br><span class="line">        &lt;Route path=<span class="string">"/profile"</span> component=&#123;Profile&#125; /&gt;</span><br><span class="line">    &lt;<span class="regexp">/Switch&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>Router&gt;</span><br></pre></td></tr></table></figure>

<p>只匹配一次，匹配到了就不走下面了</p>
<h4 id="6-1-手写"><a href="#6-1-手写" class="headerlink" title="6.1 手写"></a>6.1 手写</h4><p>新建 ./src/react-router-dom/Switch.js</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 循环所有的孩子，如果一个路径匹配到就停止循环</span></span><br><span class="line"><span class="keyword">import</span> React, &#123; PureComponent &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> context <span class="keyword">from</span> <span class="string">'./context'</span>;</span><br><span class="line"><span class="keyword">import</span> pathToRegExp <span class="keyword">from</span> <span class="string">'path-to-regexp'</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Switch</span> <span class="keyword">extends</span> <span class="title">PureComponent</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> contextType = context;</span><br><span class="line">    render() &#123;</span><br><span class="line">        <span class="keyword">let</span> child = <span class="built_in">Array</span>.isArray(<span class="keyword">this</span>.props.children) ? <span class="keyword">this</span>.props.children : [<span class="keyword">this</span>.props.children];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; child.length; i++)&#123;</span><br><span class="line">            <span class="keyword">let</span> child = children[i]; <span class="comment">// 这里已经是解析后的虚拟dom了，不是Route那个组件</span></span><br><span class="line">            <span class="keyword">let</span> &#123;path=<span class="string">'/'</span>, exact=<span class="literal">false</span>&#125; = child.props; <span class="comment">// 虚拟DOM的机构里，属性就是在props里</span></span><br><span class="line">            <span class="keyword">let</span> &#123;pathname&#125; = <span class="keyword">this</span>.context.location;</span><br><span class="line">            <span class="keyword">let</span> reg = pathToRegExp(path,[],&#123;<span class="attr">end</span>: exact&#125;);</span><br><span class="line">            <span class="keyword">if</span>(reg.test(pathname))&#123;</span><br><span class="line">                <span class="keyword">return</span> child;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Switch;</span><br></pre></td></tr></table></figure>

<h3 id="7-Redirect"><a href="#7-Redirect" class="headerlink" title="7. Redirect"></a>7. Redirect</h3><p>当路径匹配不到就重定向到首页</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;HashRouter <span class="keyword">as</span> Router, Route, Link, Switch, Redirect&#125; <span class="keyword">from</span> <span class="string">'react-router-dom'</span>;</span><br><span class="line">&lt;Switch&gt;</span><br><span class="line">    &lt;Route path=<span class="string">"/"</span> exact=&#123;<span class="literal">true</span>&#125; component=&#123;Home&#125; /&gt; </span><br><span class="line">    &lt;Route path=<span class="string">"/user"</span> component=&#123;User&#125; /&gt;</span><br><span class="line">    &lt;Route path=<span class="string">"/user"</span> component=&#123;User&#125; /&gt;</span><br><span class="line">    &lt;Route path=<span class="string">"/profile"</span> component=&#123;Profile&#125; /&gt;</span><br><span class="line">    &lt;Redirect to=<span class="string">"/"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">Redirect</span>&gt;</span></span></span><br><span class="line">&lt;<span class="regexp">/Switch&gt;</span></span><br></pre></td></tr></table></figure>

<p>注意，这里Redirect必须要和Switch一起使用，不然导致死循环，因为/ 会一直向下匹配</p>
<h4 id="7-1-手写"><a href="#7-1-手写" class="headerlink" title="7.1 手写"></a>7.1 手写</h4><p>新建./src/react-router-dom/Redirect.js</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> context <span class="keyword">from</span> <span class="string">'./context'</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Redirect</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> contextType = context;</span><br><span class="line">    render() &#123;</span><br><span class="line">        <span class="keyword">this</span>.context.history.push(<span class="keyword">this</span>.props.to); <span class="comment">// 就是一个重定向的跳转</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Redirect;</span><br></pre></td></tr></table></figure>

<h3 id="8-render"><a href="#8-render" class="headerlink" title="8. render"></a>8. render</h3><p>Route进行渲染的时候，有三种方式：<br>1、 第一种是Component<br>2、 第二种是render，会渲染render这个函数返回的内容<br>3、第三种是children</p>
<p>权限判断，如果没有登录就去登录页面<br>index.js</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;Switch&gt;</span><br><span class="line">    &lt;Route path=<span class="string">"/"</span> exact=&#123;<span class="literal">true</span>&#125; component=&#123;Home&#125; /&gt; </span><br><span class="line">    &lt;Route path=<span class="string">"/user"</span> component=&#123;User&#125; /&gt;</span><br><span class="line">    &lt;Route path=<span class="string">"/user"</span> component=&#123;User&#125; /&gt;</span><br><span class="line">    &#123;<span class="comment">/* &lt;Route path="/profile" component=&#123;Profile&#125; /&gt; */</span>&#125;</span><br><span class="line">    &lt;Protected path=<span class="string">"/profile"</span> component=&#123;Profile&#125; /&gt;</span><br><span class="line">    &lt;Redirect to=<span class="string">"/"</span> /&gt;</span><br><span class="line">&lt;<span class="regexp">/Switch&gt;</span></span><br></pre></td></tr></table></figure>

<p>新建 ./src/pages/Protected.js</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; Route, Redirect &#125; <span class="keyword">from</span> <span class="string">'../react-router-dom'</span>;</span><br><span class="line"><span class="comment">// 在渲染这个Protected组件的时候要做判断，判断当前用户是否登录，如果登录了，直接渲染Profile组件</span></span><br><span class="line"><span class="comment">// 如果没有登录，则直接跳转到登录页，等登录后再跳转回来</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> (&#123;<span class="attr">component</span>:Component, ...rest&#125;)=&gt;(</span><br><span class="line">    &lt;Route &#123;...rest&#125; render=&#123;</span><br><span class="line">        props=&gt;( <span class="comment">// props=&#123;location, history, match&#125;       当前页的location.pathname:'/profile' 登录成功之后还要跳回来</span></span><br><span class="line">            localStorage.getItem(<span class="string">'isLogin'</span>) ? &lt;Component &#123;...props&#125; /&gt; : &lt;Redirect to=&#123;&#123;pathname:'/login',state:&#123;from: props.location.pathname&#125;&#125;&#125; /&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">    /&gt;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>Route.js</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> props = &#123;</span><br><span class="line">    location: <span class="keyword">this</span>.context.location,</span><br><span class="line">    history: <span class="keyword">this</span>.context.history,</span><br><span class="line">    match</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(Component)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">Component</span> &#123;<span class="attr">...props</span>&#125; /&gt;</span>;</span></span><br><span class="line"><span class="xml">&#125;else if(render)&#123;</span></span><br><span class="line"><span class="xml">    return render(props);</span></span><br><span class="line"><span class="xml">&#125;else&#123;</span></span><br><span class="line"><span class="xml">    return null;</span></span><br><span class="line"><span class="xml">&#125;</span></span><br></pre></td></tr></table></figure>

<p>新建 ./src/pages/Login.js</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Login</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  handleClick = <span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">    localStorage.setItem(<span class="string">'logined'</span>,<span class="string">'true'</span>);</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span>.props.location.state)</span><br><span class="line">      <span class="keyword">this</span>.props.history.push(<span class="keyword">this</span>.props.location.state.from);</span><br><span class="line">  &#125;  </span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;button className=<span class="string">"btn btn-primary"</span> onClick=&#123;<span class="keyword">this</span>.handleClick&#125;&gt;登录&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="9-withRouter"><a href="#9-withRouter" class="headerlink" title="9. withRouter"></a>9. withRouter</h3><p>把一个组件当成Route渲染出来，具有Route上的属性(history,location…等)</p>
<p>新建./src/react-router-dom/withRouter.js</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;Route&#125; <span class="keyword">from</span> <span class="string">'../react-router-dom'</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> (<span class="params">Component</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="params">props</span>=&gt;</span>(</span><br><span class="line">        &lt;Route component=&#123;Component&#125;&gt;&#125;/&gt;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>新建一个NavHeader.js组件</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"><span class="keyword">import</span> &#123;withRouter&#125; <span class="keyword">from</span> <span class="string">'../react-router-dom'</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NavHeader</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        &lt;div className=<span class="string">"navbar-heading"</span>&gt;</span><br><span class="line">            &lt;div className=<span class="string">"navbar-brand"</span> onClick=&#123;()=&gt;<span class="keyword">this</span>.props.history.push(<span class="string">'/'</span>)&#125;&gt;首页&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">        &lt;/</span>div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> withRouter(NavHeader);</span><br><span class="line"><span class="comment">// 用了withRouter，所以this.props.history.push有这个方法，这个history是Route上的属性</span></span><br></pre></td></tr></table></figure>

<h3 id="10-BrowserRouter"><a href="#10-BrowserRouter" class="headerlink" title="10. BrowserRouter"></a>10. BrowserRouter</h3><p>BrowserRouter 用的history对象来实现， history.pushState()</p>
<p>新建./src/react-router-dom/BrowserRouter.js</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"><span class="keyword">import</span> Context <span class="keyword">from</span> <span class="string">'./context'</span>;</span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params">history</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> pushState = history.pushState;</span><br><span class="line">    history.pushState = <span class="function"><span class="keyword">function</span> (<span class="params">state,title,pathname</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">window</span>.onpushstate == <span class="string">"function"</span>) &#123;</span><br><span class="line">            <span class="built_in">window</span>.onpushstate(state,pathname);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pushState.apply(history, <span class="built_in">arguments</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;)(<span class="built_in">window</span>.history);</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">BrowserRouter</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    state = &#123;</span><br><span class="line">        location: &#123; <span class="attr">pathname</span>: <span class="string">'/'</span> &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    getMessage = <span class="literal">null</span></span><br><span class="line">    componentDidMount() &#123;</span><br><span class="line">        <span class="comment">// 这个事件是原生支持的</span></span><br><span class="line">        <span class="built_in">window</span>.onpopstate = <span class="function">(<span class="params">event</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">                location: &#123;</span><br><span class="line">                    ...this.state.location,</span><br><span class="line">                    pathname:<span class="built_in">document</span>.location.pathname,</span><br><span class="line">                    state:event.state</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">// 自己实现调用history.pushState(state,title,path)</span></span><br><span class="line">        <span class="built_in">window</span>.onpushstate = <span class="function">(<span class="params">state,pathname</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">                location: &#123;</span><br><span class="line">                    ...this.state.location,</span><br><span class="line">                    pathname,</span><br><span class="line">                    state</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    render() &#123;</span><br><span class="line">        <span class="keyword">let</span> that = <span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">let</span> value = &#123;</span><br><span class="line">            location: that.state.location,</span><br><span class="line">            history: &#123;</span><br><span class="line">                push(to) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (that.block) &#123;</span><br><span class="line">                        <span class="keyword">let</span> allow = <span class="built_in">window</span>.confirm(that.getMessage(that.state.location));</span><br><span class="line">                        <span class="keyword">if</span> (!allow) <span class="keyword">return</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (<span class="keyword">typeof</span> to === <span class="string">'object'</span>) &#123;</span><br><span class="line">                        <span class="keyword">let</span> &#123; pathname, state &#125; = to;</span><br><span class="line">                        <span class="built_in">window</span>.history.pushState(state, <span class="string">''</span>, pathname);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="built_in">window</span>.history.pushState(<span class="string">''</span>, <span class="string">''</span>, to);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;,</span><br><span class="line">                block(getMessage) &#123;</span><br><span class="line">                    that.block = getMessage;</span><br><span class="line">                &#125;,</span><br><span class="line">                unblock() &#123;</span><br><span class="line">                    that.block = <span class="literal">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            &lt;Context.Provider value=&#123;value&#125;&gt;</span><br><span class="line">                &#123;<span class="keyword">this</span>.props.children&#125;</span><br><span class="line">            &lt;<span class="regexp">/Context.Provider&gt;</span></span><br><span class="line"><span class="regexp">        )</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>

<h1 id="相关文档"><a href="#相关文档" class="headerlink" title="相关文档"></a>相关文档</h1><p><a href="http://www.zhufengpeixun.cn/2020/html/64.1.router.html" target="_blank" rel="noopener">http://www.zhufengpeixun.cn/2020/html/64.1.router.html</a></p>
]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title>React源码理解</title>
    <url>/2020/04/13/ReactSoundCode/</url>
    <content><![CDATA[<p>不做具体代码分析，只是作为源码思想的解读</p>
<h1 id="虚拟DOM的实现"><a href="#虚拟DOM的实现" class="headerlink" title="虚拟DOM的实现"></a>虚拟DOM的实现</h1><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;p&gt;<span class="number">1</span>&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">        &lt;button&gt;+&lt;/</span>button&gt;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp">let element = &lt;App /</span>&gt;</span><br><span class="line"><span class="built_in">console</span>.log(element);</span><br><span class="line"></span><br><span class="line">ReactDOM.render(element, <span class="built_in">document</span>.getElementById(<span class="string">'root'</span>));</span><br></pre></td></tr></table></figure>

<p>打印出来的这个element对象就是虚拟DOM</p>
<p><img src="https://jiafei2333.github.io/html/images/react-vDom-Picture.jpg" alt><br>属性解析：<br>$$typeof:<br>        Symbol(react.element) 表示这是一个react元素；<br>        标识元素类型的，有：div，Class，Function….<br>        如果说$$typeof是Symbol的话可以仿XSS攻击，因为Symbol是唯一值,如果后台直接返虚拟DOM直接显示在页面上，带Symbol就可以防止后台返回的数据有恶意的虚拟DOM类型，可以避免这个问题，Symbol只有前端有，后台没有。<br>key: 就是唯一标识<br>props: 属性，这里没有所以为空<br>ref:<br>type: 类型就是这里的这个App Class 如果是函数组件就是函数App<br>_owner: 它的所有者是谁，谁创建了它 （带下划线的都是内部属性，不是核心属性）<br>_source: 是源代码哪个文件里的第几行</p>
<p>这就是React元素，它就是一个普通的对象，描述了真实DOM的样子</p>
<p>将上面line3 ~ line13 的代码放到babel中编译，如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> </span><br><span class="line">    React.createElement(<span class="string">"div"</span>, </span><br><span class="line">        <span class="literal">null</span>,</span><br><span class="line">        React.createElement(<span class="string">"p"</span>, <span class="literal">null</span>, <span class="string">"1"</span>), </span><br><span class="line">        React.createElement(<span class="string">"button"</span>, <span class="literal">null</span>, <span class="string">"+"</span>)</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> element = React.createElement(App, <span class="literal">null</span>);</span><br></pre></td></tr></table></figure>

<p>新建./react/ReactElement.js</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> ReactCurrentOwner <span class="keyword">from</span> <span class="string">'./ReactCurrentOwner'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; REACT_ELEMENT_TYPE &#125; <span class="keyword">from</span> <span class="string">'../shared/ReactSymbols'</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hasValidRef</span>(<span class="params">config</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> config.ref !== <span class="literal">undefined</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hasValidKey</span>(<span class="params">config</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> config.key !== <span class="literal">undefined</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> RESERVED_PROPS = &#123;</span><br><span class="line">    key: <span class="literal">true</span>,</span><br><span class="line">    ref: <span class="literal">true</span>,</span><br><span class="line">    __self: <span class="literal">true</span>,</span><br><span class="line">    __source: <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//是react-babel 将&lt;span&gt;A&lt;span&gt;&lt;span&gt;A&lt;span&gt;变成数组了吗？</span></span><br><span class="line"><span class="comment">//createElement(type,config,spanA,spanB);</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">createElement</span>(<span class="params">type, config, children</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> propName;<span class="comment">//定义一个变量叫属性名</span></span><br><span class="line">    <span class="keyword">const</span> props = &#123;&#125;;<span class="comment">//定义一个元素的props对象</span></span><br><span class="line">    <span class="keyword">let</span> key = <span class="literal">null</span>;<span class="comment">//在兄弟节点中唯一标识自己的唯一性的，在同一个的不同兄弟之间key要求不同</span></span><br><span class="line">    <span class="keyword">let</span> ref = <span class="literal">null</span>;<span class="comment">//ref=React.createRef() "username" this.refs.username &#123;input=&gt;this.username = input&#125; 从而得到真实的DOM元素</span></span><br><span class="line">    <span class="keyword">let</span> self = <span class="literal">null</span>;<span class="comment">//用来获取真实的this指针 </span></span><br><span class="line">    <span class="keyword">let</span> source = <span class="literal">null</span>;<span class="comment">//用来定位创建此虚拟DOM元素在源码的位置 哪个文件 哪一行 哪一列</span></span><br><span class="line">    <span class="keyword">if</span> (config !== <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (hasValidRef(config)) &#123;</span><br><span class="line">            ref = config.ref;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (hasValidKey(config)) &#123;</span><br><span class="line">            key = config.key;</span><br><span class="line">        &#125;</span><br><span class="line">        self = config.__self === <span class="literal">undefined</span> ? <span class="literal">null</span> : config.__self;</span><br><span class="line">        source = config.__source === <span class="literal">undefined</span> ? <span class="literal">null</span> : config.__source;</span><br><span class="line">        <span class="keyword">for</span> (propName <span class="keyword">in</span> config) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!RESERVED_PROPS.hasOwnProperty(propName)) &#123;</span><br><span class="line">                props[propName] = config[propName]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> childrenLength = <span class="built_in">arguments</span>.length - <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (childrenLength === <span class="number">1</span>) &#123;</span><br><span class="line">        props.children = children;<span class="comment">//如果说是独生子的话children是一个对象</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (childrenLength &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> childArray = <span class="built_in">Array</span>(childrenLength);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; childrenLength; i++) &#123;</span><br><span class="line">            childArray[i] = <span class="built_in">arguments</span>[i + <span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        props.children = childArray;<span class="comment">//如果说是有多个儿子的话，props.children就是一个数组了</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (type &amp;&amp; type.defaultProps) &#123;</span><br><span class="line">        <span class="keyword">const</span> defaultProps = type.defaultProps;</span><br><span class="line">        <span class="comment">//只有当属性对象没有此属性对应的值的时候，默认属性才会生效，否则直接忽略 </span></span><br><span class="line">        <span class="keyword">for</span> (propName <span class="keyword">in</span> defaultProps) &#123;</span><br><span class="line">            <span class="keyword">if</span> (props[propName] === <span class="literal">undefined</span>) &#123;</span><br><span class="line">                props[propName] = defaultProps[propName]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//ReactCurrentOwner此元素的拥有者</span></span><br><span class="line">    <span class="keyword">return</span> ReactElement(</span><br><span class="line">        type, key, ref, self, source, ReactCurrentOwner.current, props</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ReactElement</span>(<span class="params">type, key, ref, _self, _source, _owner, props</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> element = &#123;</span><br><span class="line">        $$<span class="keyword">typeof</span>: REACT_ELEMENT_TYPE,</span><br><span class="line">        type,</span><br><span class="line">        key,</span><br><span class="line">        ref,</span><br><span class="line">        props,</span><br><span class="line">        _owner,</span><br><span class="line">        _self,</span><br><span class="line">        _source</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> element; <span class="comment">// 这个最后生成的就是react元素即那个虚拟DOM</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将上述babel编辑的代码转换成表示虚拟DOM的那个对象</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Component.prototype.isReactComponent = &#123;&#125;;</span><br></pre></td></tr></table></figure>

<p>在React内部是凭借这个变量来判断是不是一个React组件的<br>因为组件定义有两种方式，一是类组件，一是函数组件，都被babel编译成函数</p>
<h1 id="虚拟DOM的渲染"><a href="#虚拟DOM的渲染" class="headerlink" title="虚拟DOM的渲染"></a>虚拟DOM的渲染</h1><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span>;</span><br><span class="line">ReactDOM.render(</span><br><span class="line">    element,</span><br><span class="line">    <span class="built_in">document</span>.getElementById(<span class="string">'root'</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>新建./react-dom/index.js</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createDOM &#125; <span class="keyword">from</span> <span class="string">'../react/vdom'</span>;</span><br><span class="line"><span class="comment">// element 就是那个虚拟DOM的对象，</span></span><br><span class="line"><span class="comment">// container 挂载的容器</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">render</span>(<span class="params">element, container</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//1.要把虚拟 DOM变成真实DOM</span></span><br><span class="line">    <span class="keyword">let</span> dom = createDOM(element);</span><br><span class="line">    <span class="comment">//2.把直实DOM挂载到container上</span></span><br><span class="line">    container.appendChild(dom);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    render</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>新建./react/vdom.js</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; TEXT, ELEMENT, CLASS_COMPONENT, FUNCTION_COMPONENT &#125; <span class="keyword">from</span> <span class="string">'./constants'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; onlyOne, setProps, flatten &#125; <span class="keyword">from</span> <span class="string">'./utils'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">createDOM</span>(<span class="params">element</span>) </span>&#123;</span><br><span class="line">    element = onlyOne(element);<span class="comment">//为什么要这么写? children是一个数组</span></span><br><span class="line">    <span class="keyword">let</span> &#123; $$<span class="keyword">typeof</span> &#125; = element;</span><br><span class="line">    <span class="keyword">let</span> dom = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (!$$<span class="keyword">typeof</span>) &#123;<span class="comment">// element 是一个字符串或者数字</span></span><br><span class="line">        dom = <span class="built_in">document</span>.createTextNode(element);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ($$<span class="keyword">typeof</span> == TEXT) &#123;<span class="comment">//对象&#123;$$typeof:TEXT&#125;</span></span><br><span class="line">        dom = <span class="built_in">document</span>.createTextNode(element.content);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ($$<span class="keyword">typeof</span> == ELEMENT) &#123;</span><br><span class="line">        <span class="comment">//如果此虚拟DOM是一个原生DOM节点</span></span><br><span class="line">        dom = createNativeDOM(element);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ($$<span class="keyword">typeof</span> == FUNCTION_COMPONENT) &#123;</span><br><span class="line">        <span class="comment">//如果此虚拟DOM是一个函数组件，就渲染此函数组件</span></span><br><span class="line">        dom = createFunctionComponentDOM(element);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ($$<span class="keyword">typeof</span> == CLASS_COMPONENT) &#123;</span><br><span class="line">        <span class="comment">//如果此虚拟DOM是一个类组件，就渲染此类组件</span></span><br><span class="line">        dom = createClassComponentDOM(element);</span><br><span class="line">    &#125;</span><br><span class="line">    element.dom = dom;<span class="comment">//不管是什么类型的元素，都让它的dom属性指向他创建出来的直实DOM元素</span></span><br><span class="line">    <span class="keyword">return</span> dom;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//创建函数组件对应的真实的DOM对象</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createFunctionComponentDOM</span>(<span class="params">element</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> &#123; <span class="attr">type</span>: FunctionCounter, props &#125; = element;<span class="comment">//type = FunctionCounter</span></span><br><span class="line">    <span class="keyword">let</span> renderElement = FunctionCounter(props);<span class="comment">//返回要渲染的react元素</span></span><br><span class="line">    element.renderElement = renderElement;<span class="comment">//需要缓存,方便下次对比</span></span><br><span class="line">    <span class="keyword">let</span> newDOM = createDOM(renderElement);</span><br><span class="line">    <span class="comment">//虚拟DOM的dom属性指向它创建出来的真实DOM</span></span><br><span class="line">    renderElement.dom = newDOM;<span class="comment">//我们从虚拟DOMReact元素创建出真实DOM，创建出来以后会把真实DOM添加到虚拟DOM的dom属性上</span></span><br><span class="line">    <span class="keyword">return</span> newDOM;</span><br><span class="line">    <span class="comment">//element.renderElement.dom=DIV真实DOM元素</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createClassComponentDOM</span>(<span class="params">element</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> &#123; <span class="attr">type</span>: ClassCounter, props &#125; = element;</span><br><span class="line">    <span class="keyword">let</span> componentInstance = <span class="keyword">new</span> ClassCounter(props);<span class="comment">//创建一个ClassCounter组件的实例</span></span><br><span class="line">    <span class="comment">//当创建类组件实例 后，会在类组件的虚拟DOM对象上添一个属性componentInstance,指向类组件实例 </span></span><br><span class="line">    element.componentInstance = componentInstance;<span class="comment">//以后组件运行当中componentInstance是不变的</span></span><br><span class="line">    <span class="keyword">let</span> renderElement = componentInstance.render();</span><br><span class="line">    <span class="comment">//在类组件实例上添加renderElement,指向上一次要渲染的虚拟DOM节点</span></span><br><span class="line">    <span class="comment">//因为后面组件更新的，我们会重新render,然后跟上一次的renderElement进行dom diff</span></span><br><span class="line">    componentInstance.renderElement = renderElement;</span><br><span class="line">    <span class="keyword">let</span> newDOM = createDOM(renderElement);</span><br><span class="line">    renderElement.dom = newDOM;</span><br><span class="line">    <span class="comment">// element.componentInstance.renderElement.dom=DIV真实DOM元素</span></span><br><span class="line">    <span class="keyword">return</span> newDOM;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">let element = React.createElement('button',</span></span><br><span class="line"><span class="comment">  &#123; id: 'sayHello', onClick &#125;,</span></span><br><span class="line"><span class="comment">  'say', React.createElement('span', &#123; color: 'red' &#125;, 'Hello')</span></span><br><span class="line"><span class="comment">);</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createNativeDOM</span>(<span class="params">element</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> &#123; type, props &#125; = element;<span class="comment">// span button div</span></span><br><span class="line">    <span class="keyword">let</span> dom = <span class="built_in">document</span>.createElement(type);<span class="comment">// 真实的BUTTON DOM对象</span></span><br><span class="line">    <span class="comment">//1.创建此虚拟DOM节点的子节点</span></span><br><span class="line">    createDOMChildren(dom, element.props.children);</span><br><span class="line">    setProps(dom, props);</span><br><span class="line">    <span class="comment">//2.给此DOM元素添加属性</span></span><br><span class="line">    <span class="keyword">return</span> dom;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createDOMChildren</span>(<span class="params">parentNode, children</span>) </span>&#123;</span><br><span class="line">    children &amp;&amp; flatten(children).forEach(<span class="function">(<span class="params">child, index</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">//child其实是虚拟DOM，我们会在虚拟DOM加一个属性_mountIndex,指向此虚拟DOM节点在父节点中的索引</span></span><br><span class="line">        <span class="comment">//在后面我们做dom-diff的时候会变得非常非常重要</span></span><br><span class="line">        child._mountIndex = index;</span><br><span class="line">        <span class="keyword">let</span> childDOM = createDOM(child);<span class="comment">//创建子虚拟DOM节点的真实DOM元素</span></span><br><span class="line">        parentNode.appendChild(childDOM);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">ReactElement</span>(<span class="params">$$typeof, type, key, ref, props</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> element = &#123;</span><br><span class="line">        $$<span class="keyword">typeof</span>, type, key, ref, props</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> element;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对$$typeof的判断，来创建真实DOM元素</p>
<h1 id="合成事件"><a href="#合成事件" class="headerlink" title="合成事件"></a>合成事件</h1><p>react本身模拟了一套事件机制</p>
<p>index.js</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> onClick = <span class="function">(<span class="params">event</span>)=&gt;</span>&#123;alert( event + <span class="string">'hello'</span>)&#125;;</span><br><span class="line"><span class="keyword">let</span> element = React.createElement(<span class="string">'button'</span>,</span><br><span class="line">    &#123;<span class="attr">id</span>: <span class="string">'sayHello'</span>, onClick&#125;,</span><br><span class="line">    <span class="string">'say'</span>, React.createElement(<span class="string">'span'</span>,&#123; <span class="attr">style</span>: &#123; <span class="attr">color</span>: <span class="string">'red'</span> &#125; &#125;, <span class="string">'hello'</span>);</span><br><span class="line">)</span><br><span class="line">ReactDOM.render(element, <span class="built_in">document</span>.getElementById(<span class="string">'root'</span>));</span><br></pre></td></tr></table></figure>

<p>分析：一个button按钮，id为sayHello，上面有一个onClick事件，包含say内容和一个span标签，span标签内容为hello，颜色为红色</p>
<p>新建./react/event.js</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; updateQueue &#125; <span class="keyword">from</span> <span class="string">'./component'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 在React中并不是把事件绑在要绑定的DOM节点上，而是绑定到document上，类似于事件委托</span></span><br><span class="line"><span class="comment">* 1、因为合成事件可以屏蔽浏览器的差异，不同浏览器绑定事件和触发的方式不一样 </span></span><br><span class="line"><span class="comment">* 2、合成事件可以实现事件对象复用，重用，减少垃圾回收，提高性能</span></span><br><span class="line"><span class="comment">* 3、因为默认我们要实现批量更新，setState 两个setState会合并成一次更新</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* @params dom 要绑定事件的DOM节点</span></span><br><span class="line"><span class="comment">* @params eventType 事件的类型 onClick onChange</span></span><br><span class="line"><span class="comment">* @params listener 事件处理函数</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">addEvent</span>(<span class="params">dom, eventType, listener</span>) </span>&#123;</span><br><span class="line">    eventType = eventType.toLowerCase(); <span class="comment">// onClick =&gt;onclick</span></span><br><span class="line">    <span class="comment">// 在要绑定的DOM节点上挂载一个对象，准备存放监听函数</span></span><br><span class="line">    <span class="keyword">let</span> eventStore = dom.eventStore || (dom.eventStore = &#123;&#125;);</span><br><span class="line">    <span class="comment">// eventStore.onclick = ()=&gt;&#123; alert('hello') &#125;;</span></span><br><span class="line">    eventStore[eventType] = listener;</span><br><span class="line">    <span class="comment">// document.addEventListener('click', dispatchEvent); </span></span><br><span class="line">    <span class="comment">// dispatchEvent 事件处理，向上冒泡，最终是document处理事件 </span></span><br><span class="line">    <span class="comment">// 第一阶段是捕获，第二阶段是冒泡，false冒泡阶段，true捕获阶段</span></span><br><span class="line">    <span class="built_in">document</span>.addEventListener(eventType.slice(<span class="number">2</span>), dispatchEvent, <span class="literal">false</span>);</span><br><span class="line">    <span class="comment">// 磨平差异</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="string">'chrome'</span>)&#123;</span><br><span class="line">        <span class="built_in">document</span>.addEventListener();</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="string">'ie6'</span>)&#123;</span><br><span class="line">        <span class="built_in">document</span>.attachEvent();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> syntheticEvent;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 真正事件触发的回调统一是这个dispatchEvent方法</span></span><br><span class="line"><span class="comment">// event是原生DOM事件对象，但是传递给我们的监听函数并不是它 </span></span><br><span class="line"><span class="comment">// 所有的事件处理函数都会进入dispatchEvent</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dispatchEvent</span>(<span class="params">event</span>) </span>&#123; </span><br><span class="line">    <span class="keyword">let</span> &#123; type, target &#125; = event; <span class="comment">// type=click , target=button</span></span><br><span class="line">    <span class="keyword">let</span> eventType = <span class="string">'on'</span> + type;</span><br><span class="line">    syntheticEvent = getSyntheticEvent(event);</span><br><span class="line">    <span class="comment">//在事件监听函数执行前先进入批量更新模式</span></span><br><span class="line">    updateQueue.isPending = <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">// 模拟事件冒泡</span></span><br><span class="line">    <span class="keyword">while</span> (target) &#123;</span><br><span class="line">        <span class="keyword">let</span> &#123; eventStore &#125; = target;</span><br><span class="line">        <span class="keyword">let</span> listener = eventStore &amp;&amp; eventStore[eventType];</span><br><span class="line">        <span class="keyword">if</span> (listener) &#123;</span><br><span class="line">            listener.call(target, syntheticEvent);</span><br><span class="line">        &#125;</span><br><span class="line">        target = target.parentNode;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 等所有的监听函数都执行完了，就可以清掉所有的属性了，供下次复用次syntheticEvent对象</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> syntheticEvent) &#123;</span><br><span class="line">        <span class="keyword">if</span> (syntheticEvent.hasOwnProperty(key))</span><br><span class="line">            <span class="keyword">delete</span> syntheticEvent[key];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//当事件处理函数执行完成后，把批量更新模式改为false</span></span><br><span class="line">    updateQueue.isPending = <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">//执行批量更新，就是把缓存的那个updater全部执行了</span></span><br><span class="line">    updateQueue.batchUpdate();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 持久化  异步调用事件会有问题，事件被清空了，用 事件对象.persist(); 持久化</span></span><br><span class="line"><span class="comment">// 如果执行了persist，就让syntheticEvent指向了新对象，while循环结束之后再清除的是新对象的属性</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">persist</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    syntheticEvent = &#123;&#125;;</span><br><span class="line">    <span class="built_in">Object</span>.setPrototypeOf(syntheticEvent, &#123;</span><br><span class="line">        persist</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getSyntheticEvent</span>(<span class="params">nativeEvent</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 第一次才会创建，以后不再创建，始终会用同一个</span></span><br><span class="line">    <span class="keyword">if</span> (!syntheticEvent) &#123;</span><br><span class="line">        persist();</span><br><span class="line">    &#125;</span><br><span class="line">    syntheticEvent.nativeEvent = nativeEvent;</span><br><span class="line">    syntheticEvent.currentTarget = nativeEvent.target;</span><br><span class="line">    <span class="comment">// 把原生事件上的方法和属性都拷贝到了合成对象上</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> nativeEvent) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> nativeEvent[key] == <span class="string">'function'</span>) &#123;</span><br><span class="line">            syntheticEvent[key] = nativeEvent[key].bind(nativeEvent);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            syntheticEvent[key] = nativeEvent[key];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> syntheticEvent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="unstable-batchedUpdates-批量强制更新"><a href="#unstable-batchedUpdates-批量强制更新" class="headerlink" title="unstable_batchedUpdates 批量强制更新"></a>unstable_batchedUpdates 批量强制更新</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 情况一</span></span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123;<span class="attr">number</span>: <span class="keyword">this</span>.state.number+<span class="number">1</span>&#125;);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.state.number); <span class="comment">// 1</span></span><br><span class="line">    <span class="keyword">this</span>.setState(&#123;<span class="attr">number</span>: <span class="keyword">this</span>.state.number+<span class="number">1</span>&#125;);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.state.number); <span class="comment">// 2</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 情况二 批量强制更新</span></span><br><span class="line"><span class="keyword">import</span> ReactDOM, &#123;unstable_batchedUpdates&#125; <span class="keyword">from</span> <span class="string">'react-dom'</span>;</span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">    unstable_batchedUpdates(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.setState(&#123;<span class="attr">number</span>: <span class="keyword">this</span>.state.number+<span class="number">1</span>&#125;);</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.state.number); <span class="comment">// 0</span></span><br><span class="line">        <span class="keyword">this</span>.setState(&#123;<span class="attr">number</span>: <span class="keyword">this</span>.state.number+<span class="number">1</span>&#125;);</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.state.number); <span class="comment">// 0</span></span><br><span class="line">    &#125;)</span><br><span class="line">    </span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>原理</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; updateQueue &#125; <span class="keyword">from</span> <span class="string">'./component'</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unstable_batchedUpdates</span>(<span class="params">fn</span>)</span>&#123;</span><br><span class="line">    updateQueue.isPending = <span class="literal">true</span>; <span class="comment">// 强行处理批量更新模式</span></span><br><span class="line">    fn();</span><br><span class="line">    updateQueue.isPending = <span class="literal">false</span>;</span><br><span class="line">    updateQueue.batchUpdate();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>补充一下updateQueue</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">let</span> updateQueue = &#123;</span><br><span class="line">    updaters: [], <span class="comment">// 这里面放着将要执行的更新器对象</span></span><br><span class="line">    isPending: <span class="literal">false</span>, <span class="comment">// 是否批量更新，如果 isPending=true 则处于批量更新模式</span></span><br><span class="line">    add(updater) &#123; <span class="comment">// 放进去就完事，不进行真正的更新</span></span><br><span class="line">        <span class="keyword">this</span>.updaters.push(updater);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 需要有人调用batchUpdate方法才会真正更新</span></span><br><span class="line">    batchUpdate() &#123;<span class="comment">// 强行全部更新 执行真正的更新</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.isPending) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.isPending = <span class="literal">true</span>; <span class="comment">// 进入批量更新模式</span></span><br><span class="line">        <span class="keyword">let</span> &#123; updaters &#125; = <span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">let</span> updater;</span><br><span class="line">        <span class="keyword">while</span> ((updater = updaters.pop())) &#123;</span><br><span class="line">            updater.updateComponent(); <span class="comment">// 更新所有脏 dirty 组件</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.isPending = <span class="literal">false</span>; <span class="comment">// 改为非批量更新</span></span><br><span class="line">    &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="DOM-DIFF"><a href="#DOM-DIFF" class="headerlink" title="DOM-DIFF"></a>DOM-DIFF</h1><ul>
<li>DOM 节点跨层级的移动操作特别少，可以忽略不计</li>
<li>拥有相同类的两个组件将会生成相似的树形结构，拥有不同类的两个组件将会生成不同的树形结构</li>
<li>对于同一层级的一组子节点，它们可以通过唯一key进行区分</li>
<li>DIFF算法在执行时有三个维度，分别是Tree DIFF、Component DIFF和Element DIFF，执行时按顺序依次执行，它们的差异仅仅因为DIFF粒度不同、执行先后顺序不同</li>
</ul>
<h2 id="Tree-DIFF"><a href="#Tree-DIFF" class="headerlink" title="Tree DIFF"></a>Tree DIFF</h2><ul>
<li>Tree DIFF是对树的每一层进行遍历，如果某组件不存在了，则会直接销毁</li>
</ul>
<p><img src="http://img.zhufengpeixun.cn/sametree.png" alt></p>
<ul>
<li>当出现节点跨层级移动时，并不会出现想象中的移动操作，而是以 A 为根节点的树被整个重新创建</li>
</ul>
<p><img src="http://img.zhufengpeixun.cn/movemytree.png" alt></p>
<h2 id="Component-DIFF"><a href="#Component-DIFF" class="headerlink" title="Component DIFF"></a>Component DIFF</h2><ul>
<li>如果是同一类型的组件，按照原策略继续比较</li>
<li>类型不同则直接替换</li>
</ul>
<p><img src="http://img.zhufengpeixun.cn/deleteall.png" alt></p>
<h3 id="原理分析"><a href="#原理分析" class="headerlink" title="原理分析"></a>原理分析</h3><p>老节点 A B C D<br>新节点 A C B E F<br><img src="https://jiafei2333.github.io/html/images/domdiff_01.png" alt></p>
<p>(1) 针对老节点做一个map映射，属性是老节点的key，值是老节点（即React元素节点）（A:A元素,B:B元素,C:C元素,D:D元素）<br>(2) lastIndex 指向老节点中可复用，上一个不需要移动的元素的索引<br>(3) _mountIndex 挂载索引，表示这个节点在兄弟节点中的位置 (0 1 2 3）</p>
<p>1、开始遍历新节点的数组<br> 1.1、在map里找有没有可复用的老节点，通过key去查找，如果新老两个元素key一样，type类型也是一样的，那就可以复用</p>
<p>【比较A节点】<br>通过key去查找老节点，key、type都一样，找到A<br> 可复用的A节点 _mountIndex &lt; lastIndex 则需要移动，否则不用移动可复用，现在对于A节点来说，_mountIndex 为0，lastIndex 为0，所以DOM节点A不用移动，复用老的DOM节点，用新属性更新这个DOM节点</p>
<p><img src="https://jiafei2333.github.io/html/images/domdiff_02.png" alt><br>如图，此时lastIndex还是指向0，_mountIndex 指向新的A节点的下标 0</p>
<p>【比较C节点】<br>继续，通过key去查找老节点，key、type都一样，找到C<br>可复用的老节点的_mountIndex:2, lastIndex:0 不移动，可复用，复用老的DOM节点，用新属性更新这个DOM节点，下标改为1<br>并且lastIndex = Math.max(lastIndex,老节点的挂载点_mountIndex 即2)，这里lastIndex为2<br><strong><em>每次比较都会取最大值给lastIndex，并且更新挂载点的索引</em></strong></p>
<p>【比较B节点】<br>继续，通过key去查找老节点，key、type都一样，找到B<br>老的B节点的_mountIndex: 1，现在lastIndex: 2， _mountIndex &lt; lastIndex ,移动节点，一定到新节点B的同下标位置 2<br><img src="https://jiafei2333.github.io/html/images/domdiff_03.png" alt></p>
<p>【比较节点E】<br>继续，通过key去查找老节点，没有找到，新节点E插入，挂载点是 3<br><img src="https://jiafei2333.github.io/html/images/domdiff_04.png" alt></p>
<p>【比较节点F】<br>继续，通过key去查找老节点，没有找到，新节点E插入，挂载点是 4</p>
<p>新数组遍历完了，将老节点中没用到的节点删除</p>
<p>【小结】<br>1、把老节点放在map里，属性为key，值为虚拟DOM<br>2、遍历新子元素数组，先去map里找有没有能复用的，如果找到了就更新DOM属性，并且判断_mountIndex是否小于lastIndex，如果小于则需要移动，从老节点原来的位置删除，并插入新数组的当前位置，然后把老节点的挂载点_mountIndex等于此节点在新数组中的索引，另外更新lastIndex为lastIndex和老挂载点的较大值<br>3、如果找不到可以复用的老节点，则直接在当前索引位置插入新节点<br>4、新数组遍历完成后，如果还有没有用到的老节点，删除。</p>
<p><strong><em>深度优先遍历，如果节点下还有子节点，会先去遍历子节点</em></strong><br>这里的类型比较是type，$$type大类型，可能都是element，而type则是比较的是div、span这种</p>
<p>【示例】<br>如果 A 下面有节点 B C，改成 A C B，会先去更新B C 下面的子节点，再整体移动 B 放到 C 的后边</p>
<p><img src="http://img.zhufengpeixun.cn/oldnewmove.png" alt><br><img src="http://img.zhufengpeixun.cn/oldnewmove2.png" alt><br><img src="http://img.zhufengpeixun.cn/oldnewmove3.png" alt></p>
<h3 id="部分代码实现"><a href="#部分代码实现" class="headerlink" title="部分代码实现"></a>部分代码实现</h3><p>更新子节点</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> diffQueue = [];<span class="comment">// 这是一个补丁包，记录了哪些节点需要删除，哪些节点需要添加</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">updateChildren</span>(<span class="params">dom, oldChildrenElements, newChildrenElements</span>)</span>&#123;</span><br><span class="line">    updateDepth++; <span class="comment">// 每进入一个新的子层级，就让updateDepth++</span></span><br><span class="line">    diff(dom, oldChildrenElements, newChildrenElements, diffQueue);</span><br><span class="line">    updateDepth--; <span class="comment">// 每比较完一层，返回上一级的时候，就updateDepth--</span></span><br><span class="line">    <span class="keyword">if</span>(updateDepth == <span class="number">0</span>)&#123; <span class="comment">// updateDepth = 0，就说明到最上面一层了，整个更新对比就完事了</span></span><br><span class="line">        path(diffQueue); <span class="comment">// 把收集到的差异补丁传给path方法进行更新</span></span><br><span class="line">        diffQueue.length = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 这里diffQueue的结构 </span></span><br><span class="line">diffQueue.push(&#123;</span><br><span class="line">    parentNode: parentNode, <span class="comment">// 我要移动哪个父节点下的元素</span></span><br><span class="line">    type: <span class="string">'MOVE'</span>, <span class="comment">// INSERT REMOVE</span></span><br><span class="line">    fromIndex: oldChildrenElement._mountIndex, <span class="comment">// 从哪里移动</span></span><br><span class="line">    toIndex: i,<span class="comment">// 移动到哪里</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>开始打包，这里操作的是真实的DOM元素</p>
<ul>
<li>第一步，把该删除的删除 MOVE REMOVE 移动的和删除的</li>
<li>第二步，插入移动的</li>
</ul>
<p>这里指的是移动的B 和 删除的 D，其中要把移动的B放在一个Map里面缓存起来后面复用</p>
<p>先更新父节点的属性，再更新子节点的属性<br>先移动子节点，再移动父节点</p>
<p>相关文章：<br><a href="http://www.zhufengpeixun.cn/2020/html/96.1.react16.html" target="_blank" rel="noopener">http://www.zhufengpeixun.cn/2020/html/96.1.react16.html</a></p>
<h1 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h1><h1 id="context"><a href="#context" class="headerlink" title="context"></a>context</h1><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createContext</span>(<span class="params">defaultValue</span>)</span>&#123;</span><br><span class="line">    Provider.value = defaultValue;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">Provider</span>(<span class="params">props</span>)</span>&#123;</span><br><span class="line">        Provider.value = props.value;</span><br><span class="line">        <span class="keyword">return</span> props.children;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">Consumer</span>(<span class="params">props</span>)</span>&#123;</span><br><span class="line">        <span class="comment">// return props.children(Provider.value);</span></span><br><span class="line">        <span class="keyword">return</span> onlyOne(props.children)(Provider.value);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &#123;Provider, Consumer&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> React = &#123;</span><br><span class="line">    createElement,</span><br><span class="line">    Component,</span><br><span class="line">    createRef,</span><br><span class="line">    createContext</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> React;</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">onlyOne</span>(<span class="params">obj</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Array</span>.isArray(obj) ? obj[<span class="number">0</span>] : obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式</title>
    <url>/2020/04/08/DesignMode/</url>
    <content><![CDATA[<h1 id="装饰器模式"><a href="#装饰器模式" class="headerlink" title="装饰器模式"></a>装饰器模式</h1><ul>
<li>在不改变原有的结构和功能 为对象添加功能</li>
<li>装饰模式有时候比继承更加灵活</li>
</ul>
<h2 id="在不改变原有的结构和功能-为对象添加功能"><a href="#在不改变原有的结构和功能-为对象添加功能" class="headerlink" title="在不改变原有的结构和功能 为对象添加功能"></a>在不改变原有的结构和功能 为对象添加功能</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Duck</span></span>&#123;</span><br><span class="line">    eat(food) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`吃<span class="subst">$&#123;food&#125;</span>`</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TangDuck</span></span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>() &#123;</span><br><span class="line">        <span class="keyword">this</span>.duck=<span class="keyword">new</span> Duck();</span><br><span class="line">    &#125;</span><br><span class="line">    eat(food) &#123;</span><br><span class="line">        <span class="keyword">this</span>.duck.eat(food);</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'谢谢'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> t = <span class="keyword">new</span> TangDuck();</span><br><span class="line">t.eat(<span class="string">'苹果'</span>);</span><br></pre></td></tr></table></figure>

<p>打印： 吃苹果 谢谢</p>
<p>解析：Duck原组件没有改变，TangDuck对它做了增强，除了原有的之外添加了额外的逻辑</p>
<h2 id="装饰模式有时候比继承更加灵活"><a href="#装饰模式有时候比继承更加灵活" class="headerlink" title="装饰模式有时候比继承更加灵活"></a>装饰模式有时候比继承更加灵活</h2><p>装饰器模式是将一个对象嵌入另一个对象之中，实际上相当于这个对象被另一个对象包装起来，形成一条包装链。请求随着这条链条依次传递到所有的对象，每个对象有处理这个请求的机会。</p>
<p>下面是链式的水+咖啡+奶+糖=13的示例</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Coffee</span></span>&#123;</span><br><span class="line">  make(water)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;water&#125;</span>+咖啡`</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  cost()&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MilkCoffee</span></span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(parent)&#123;</span><br><span class="line">        <span class="keyword">this</span>.parent = parent;</span><br><span class="line">    &#125;</span><br><span class="line">    make(water)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;<span class="keyword">this</span>.parent.make(water)&#125;</span>+牛奶`</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cost()&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.parent.cost()+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SugerCoffee</span></span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(parent)&#123;</span><br><span class="line">        <span class="keyword">this</span>.parent = parent;</span><br><span class="line">    &#125;</span><br><span class="line">    make(water)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;<span class="keyword">this</span>.parent.make(water)&#125;</span>+糖`</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cost()&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.parent.cost()+<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> coffee = <span class="keyword">new</span> Coffee();</span><br><span class="line"><span class="keyword">let</span> milkCoffee = <span class="keyword">new</span> MilkCoffee(coffee);</span><br><span class="line"><span class="keyword">let</span> milksugerCoffee = <span class="keyword">new</span> SugerCoffee(milkCoffee);</span><br><span class="line"><span class="built_in">console</span>.log(milksugerCoffee.make(<span class="string">'水'</span>)+<span class="string">'='</span>+milksugerCoffee.cost());</span><br></pre></td></tr></table></figure>

<h2 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h2><p>面向切面编程<br>就是在函数执行之前或之后添加一些额外的逻辑，而不需要函数的功能。</p>
<h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><h3 id="埋点"><a href="#埋点" class="headerlink" title="埋点"></a>埋点</h3><p>埋点分析，是网站分析的一种常用的数据采集方法</p>
<p>埋点方式</p>
<ul>
<li>服务器层面的：主要是通过客户端的请求进行分析</li>
<li>客户端层面的：通过埋点进行相应的分析<ul>
<li>代码埋点</li>
<li>自动化埋点：通过AOP思想对相应的方法进行统计</li>
<li>第三方实现 百度、友盟等…</li>
</ul>
</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">data-name</span>=<span class="string">"西瓜"</span> <span class="attr">id</span>=<span class="string">"watermelon"</span>&gt;</span>西瓜<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">data-name</span>=<span class="string">"苹果"</span> <span class="attr">id</span>=<span class="string">"apple"</span>&gt;</span>苹果<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"> <span class="keyword">let</span> watermelon = <span class="built_in">document</span>.getElementById(<span class="string">'watermelon'</span>);</span></span><br><span class="line"><span class="javascript"> <span class="keyword">let</span> apple = <span class="built_in">document</span>.getElementById(<span class="string">'apple'</span>);</span></span><br><span class="line"><span class="javascript"> <span class="built_in">Function</span>.prototype.after = <span class="function"><span class="keyword">function</span>(<span class="params">afterFn</span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> _this = <span class="keyword">this</span>;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">         _this.apply(<span class="keyword">this</span>,<span class="built_in">arguments</span>); <span class="comment">// 先执行15-17</span></span></span><br><span class="line"><span class="javascript">        afterFn.apply(<span class="keyword">this</span>,<span class="built_in">arguments</span>); <span class="comment">// 再执行19-22</span></span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="javascript"><span class="comment">// 这是正常逻辑</span></span></span><br><span class="line"><span class="javascript"> <span class="function"><span class="keyword">function</span> <span class="title">click</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">     <span class="built_in">console</span>.log(<span class="string">'点击'</span>+<span class="keyword">this</span>.dataset.name);</span></span><br><span class="line"> &#125;</span><br><span class="line"><span class="javascript"> <span class="comment">// 这是埋点逻辑</span></span></span><br><span class="line"><span class="javascript"> click = click.after(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">     <span class="keyword">let</span> img = <span class="keyword">new</span> Image();</span></span><br><span class="line"><span class="javascript">     img.src = <span class="string">`http://localhost:3000?name=<span class="subst">$&#123;<span class="keyword">this</span>.dataset.name&#125;</span>`</span>; <span class="comment">// 当前按钮点击的名字通过src发送给服务器端</span></span></span><br><span class="line"> &#125;);</span><br><span class="line"><span class="javascript"> <span class="built_in">Array</span>.from(<span class="built_in">document</span>.querySelectorAll(<span class="string">'button'</span>)).forEach(<span class="function"><span class="keyword">function</span>(<span class="params">button</span>)</span>&#123; <span class="comment">// 给每个button上都增加一个事件</span></span></span><br><span class="line"><span class="javascript">    button.addEventListener(<span class="string">'click'</span>,click);</span></span><br><span class="line"> &#125;);</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>);</span><br><span class="line"><span class="keyword">let</span> app = express();</span><br><span class="line">app.get(<span class="string">'/'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">req,res</span>)</span>&#123;</span><br><span class="line">   <span class="built_in">console</span>.log(<span class="string">'name'</span>,req.query.name);</span><br><span class="line">   res.end(<span class="string">'ok'</span>);</span><br><span class="line">&#125;);</span><br><span class="line">app.listen(<span class="number">3000</span>);</span><br></pre></td></tr></table></figure>

<h3 id="表单校验"><a href="#表单校验" class="headerlink" title="表单校验"></a>表单校验</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">""</span>&gt;</span></span><br><span class="line">        用户名<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"username"</span> <span class="attr">id</span>=<span class="string">"username"</span>&gt;</span></span><br><span class="line">        密码<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">id</span>=<span class="string">"password"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">"submit-btn"</span> &gt;</span>提交<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">         <span class="built_in">Function</span>.prototype.before = <span class="function"><span class="keyword">function</span>(<span class="params">beforeFn</span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">let</span> _this = <span class="keyword">this</span>;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">                <span class="keyword">let</span> ret = beforeFn.apply(<span class="keyword">this</span>,<span class="built_in">arguments</span>);</span></span><br><span class="line"><span class="javascript">                <span class="keyword">if</span>(ret)</span></span><br><span class="line"><span class="javascript">                _this.apply(<span class="keyword">this</span>,<span class="built_in">arguments</span>);</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="javascript">      <span class="function"><span class="keyword">function</span> <span class="title">submit</span>(<span class="params"></span>)</span>&#123; <span class="comment">// 业务逻辑</span></span></span><br><span class="line"><span class="javascript">          alert(<span class="string">'提交表单'</span>);</span></span><br><span class="line">      &#125;</span><br><span class="line"><span class="javascript">      <span class="keyword">let</span> checkUserNameNotNull= submit.before(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="comment">// 校验逻辑 和 业务逻辑分开</span></span></span><br><span class="line"><span class="javascript">          <span class="keyword">let</span> username = <span class="built_in">document</span>.getElementById(<span class="string">'username'</span>).value;</span></span><br><span class="line"><span class="javascript">          <span class="keyword">if</span>(username.length&lt;<span class="number">6</span>)&#123;</span></span><br><span class="line"><span class="javascript">              <span class="keyword">return</span> alert(<span class="string">'用户名不能少于6位'</span>);</span></span><br><span class="line">          &#125;</span><br><span class="line"><span class="javascript">          <span class="keyword">return</span> <span class="literal">true</span>;</span></span><br><span class="line">      &#125;);</span><br><span class="line"><span class="javascript">      <span class="keyword">let</span> checkUserNameMoreThanSix = checkUserNameNotNull.before(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="comment">// 校验逻辑 和 业务逻辑分开</span></span></span><br><span class="line"><span class="javascript">          <span class="keyword">let</span> username = <span class="built_in">document</span>.getElementById(<span class="string">'username'</span>).value;</span></span><br><span class="line"><span class="javascript">          <span class="keyword">if</span>(!username)&#123;</span></span><br><span class="line"><span class="javascript">              <span class="keyword">return</span> alert(<span class="string">'用户名不能为空'</span>);</span></span><br><span class="line">          &#125;</span><br><span class="line"><span class="javascript">          <span class="keyword">return</span> <span class="literal">true</span>;</span></span><br><span class="line">      &#125;);</span><br><span class="line"><span class="javascript">      <span class="built_in">document</span>.getElementById(<span class="string">'submit-btn'</span>).addEventListener(<span class="string">'click'</span>,checkUserNameMoreThanSix);</span></span><br></pre></td></tr></table></figure>

<p>express 不太一样，但是koa和这个原理是一样的<br>axios的interceptor就是依据这个写的</p>
<h3 id="类装饰器-方法装饰器"><a href="#类装饰器-方法装饰器" class="headerlink" title="类装饰器 | 方法装饰器"></a>类装饰器 | 方法装饰器</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">@testable </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h1><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Star</span></span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(name) &#123;</span><br><span class="line">        <span class="keyword">this</span>.name=name;</span><br><span class="line">        <span class="keyword">this</span>.state=<span class="string">''</span>;</span><br><span class="line">        <span class="keyword">this</span>.observers=[]; <span class="comment">// 观察者数组</span></span><br><span class="line">    &#125;</span><br><span class="line">    getState() &#123; <span class="comment">// 获取状态</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.state;</span><br><span class="line">    &#125;</span><br><span class="line">    setState(state) &#123;<span class="comment">// 改变状态</span></span><br><span class="line">        <span class="keyword">this</span>.state=state;</span><br><span class="line">        <span class="keyword">this</span>.notifyAllObservers();</span><br><span class="line">    &#125;</span><br><span class="line">    attach(observer) &#123; <span class="comment">// 绑定一个新的观察者</span></span><br><span class="line">        <span class="keyword">this</span>.observers.push(observer);</span><br><span class="line">    &#125;</span><br><span class="line">    notifyAllObservers() &#123; <span class="comment">// 通知所有的观察者更新自己</span></span><br><span class="line">        <span class="keyword">this</span>.observers.forEach(<span class="function"><span class="params">observer</span>=&gt;</span>observer.update());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fan</span></span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(name,subject) &#123;</span><br><span class="line">        <span class="keyword">this</span>.name=name;</span><br><span class="line">        <span class="keyword">this</span>.subject=subject;</span><br><span class="line">        <span class="keyword">this</span>.subject.attach(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    update() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;<span class="keyword">this</span>.subject.name&#125;</span>有新的状态-<span class="subst">$&#123;<span class="keyword">this</span>.subject.getState()&#125;</span>,<span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span>正在更新`</span>);    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> star=<span class="keyword">new</span> Star(<span class="string">'明星'</span>);</span><br><span class="line"><span class="keyword">let</span> fan1=<span class="keyword">new</span> Fan(<span class="string">'粉丝'</span>,star);</span><br><span class="line">star.setState(<span class="string">'结婚'</span>);</span><br></pre></td></tr></table></figure>

<p>观察者模式区别于发布订阅模式：</p>
<ul>
<li>被观察者和观察者是耦合的(被观察者内部保存观察者的引用地址的数组用来通知观察者的)</li>
<li>观察者的update动作是由被观察者调用的</li>
</ul>
<h1 id="发布订阅模式"><a href="#发布订阅模式" class="headerlink" title="发布订阅模式"></a>发布订阅模式</h1><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Agent</span></span>&#123; <span class="comment">// 中介</span></span><br><span class="line">    <span class="keyword">constructor</span>()&#123;</span><br><span class="line">        <span class="keyword">this</span>._events = &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// on addEventListener</span></span><br><span class="line">    subscribe(type,listener)&#123;</span><br><span class="line">        <span class="keyword">let</span> listeners = <span class="keyword">this</span>._events[type];</span><br><span class="line">        <span class="keyword">if</span>(listeners)&#123;</span><br><span class="line">            <span class="keyword">this</span>._events[type].push(listener);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">this</span>._events[type] = [listener];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// emit</span></span><br><span class="line">    publish(type)&#123;</span><br><span class="line">        <span class="keyword">let</span> listeners = <span class="keyword">this</span>._events[type];</span><br><span class="line">        <span class="keyword">let</span> args = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(listeners)&#123;</span><br><span class="line">            listeners.forEach(<span class="function"><span class="params">listener</span>=&gt;</span>listener(...args));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LandLord</span></span>&#123; <span class="comment">// 房东</span></span><br><span class="line">    <span class="keyword">constructor</span>(name)&#123;<span class="keyword">this</span>.name=name;&#125;</span><br><span class="line">    lend(agent,area,money)&#123; <span class="comment">// 向外出租</span></span><br><span class="line">        agent.publish(<span class="string">'house'</span>,area,money);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tenant</span></span>&#123; <span class="comment">// 租房的人</span></span><br><span class="line">    <span class="keyword">constructor</span>(name)&#123;<span class="keyword">this</span>.name=name;&#125;</span><br><span class="line">    rent(agent,area,money)&#123; <span class="comment">//租房</span></span><br><span class="line">        agent.subscribe(<span class="string">'house'</span>,(area,money)=&gt;&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">`我看到中介的新房源了 <span class="subst">$&#123;area&#125;</span>平 <span class="subst">$&#123;money&#125;</span>元`</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> agent = <span class="keyword">new</span> Agent();</span><br><span class="line"><span class="keyword">let</span> t1 = <span class="keyword">new</span> Tenant(<span class="string">'张三'</span>);</span><br><span class="line"><span class="keyword">let</span> t2 = <span class="keyword">new</span> Tenant(<span class="string">'李四'</span>);</span><br><span class="line">t1.rent(agent);</span><br><span class="line">t2.rent(agent);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> landLord = <span class="keyword">new</span> LandLord();</span><br><span class="line">landLord.lend(agent,<span class="number">60</span>,<span class="number">4000</span>); <span class="comment">// 发布房源</span></span><br></pre></td></tr></table></figure>

<p>打印</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">我看到中介的新房源了 60平 4000元</span><br><span class="line">我看到中介的新房源了 60平 4000元</span><br></pre></td></tr></table></figure>

<h2 id="应用场景："><a href="#应用场景：" class="headerlink" title="应用场景："></a>应用场景：</h2><p>微信公众号，你关注了微信公众号，微信公众号就会给粉丝推消息，微信公众号就是一个主题，粉丝就是观察者。<br>微博，观察者模式的精髓就是，主题持有观察者的引用，所以才能实现 主题发生改变，观察者能响应到主题发生的变化。一个动作发生了改变，其他几个动作也要发生改变。业务场景就这样。</p>
]]></content>
      <categories>
        <category>js基础</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>100道前端面试题</title>
    <url>/2020/04/01/Interview-all/</url>
    <content><![CDATA[<h1 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h1><h2 id="Q-已知如下代码，如何修改才能让图片宽度为-300px-？注意下面代码不可修改。"><a href="#Q-已知如下代码，如何修改才能让图片宽度为-300px-？注意下面代码不可修改。" class="headerlink" title="[Q] 已知如下代码，如何修改才能让图片宽度为 300px ？注意下面代码不可修改。"></a>[Q] 已知如下代码，如何修改才能让图片宽度为 300px ？注意下面代码不可修改。</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;img src=<span class="string">"1.jpg"</span> style=<span class="string">"width:480px!important;”&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="Q-介绍下-BFC-及其应用"><a href="#Q-介绍下-BFC-及其应用" class="headerlink" title="[Q] 介绍下 BFC 及其应用"></a>[Q] 介绍下 BFC 及其应用</h2><p>【解答】</p>
<p>块级格式化上下文 (Block Formatting Context)</p>
<p>怎样才能形成BFC:<br>1、根元素<br>2、float的值不能为none<br>3、overflow的值不能为visible<br>4、display的值为table-cell, table-caption, inline-block，flex中的任何一个<br>5、position的值不为relative和static </p>
<p>[BFC] <a href="https://juejin.im/post/5a4dbe026fb9a0452207ebe6" target="_blank" rel="noopener">https://juejin.im/post/5a4dbe026fb9a0452207ebe6</a><br>[BFC] <a href="https://zhuanlan.zhihu.com/p/25321647" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/25321647</a><br>[清除浮动] <a href="https://www.cnblogs.com/dolphinX/p/3508869.html" target="_blank" rel="noopener">https://www.cnblogs.com/dolphinX/p/3508869.html</a></p>
<h2 id="Q-vw-vh-是什么意思"><a href="#Q-vw-vh-是什么意思" class="headerlink" title="[Q] vw vh 是什么意思"></a>[Q] vw vh 是什么意思</h2><p>【解答】<br>vw：相对于视口的宽度，视口被均分为100单位的vw<br>vh：相当于视口的宽度</p>
<h2 id="A"><a href="#A" class="headerlink" title="[A]"></a>[A]</h2><p>没有顺序，置前置后都生效<br>1、<code>max-width: 300px;</code><br>2、<code>transform: scale(0.625,0.625);</code><br>3、<code>zoom: 0.5;</code>    （zoom的缩放是相对于左上角的；而scale默认是居中缩放。）<br>4、<code>padding: 0 90px; box-sizing: border-box;</code><br>5、用js <code>document.getElementsByTagName(&quot;img&quot;)[0].setAttribute(&quot;style&quot;,&quot;width:300px!important;&quot;);</code><br>6、给图片设置动画</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">img</span> &#123;</span><br><span class="line">    <span class="attribute">animation</span>: test <span class="number">0s</span> forwards;</span><br><span class="line">&#125;</span><br><span class="line">@<span class="keyword">keyframes</span> test &#123;</span><br><span class="line">    <span class="selector-tag">from</span> &#123;</span><br><span class="line">        <span class="attribute">width</span>: <span class="number">300px</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="selector-tag">to</span> &#123;</span><br><span class="line">        <span class="attribute">width</span>: <span class="number">300px</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>原理是CSS动画的样式优先级高于!important的特性</p>
<h2 id="Q-用css画出三角形"><a href="#Q-用css画出三角形" class="headerlink" title="[Q] 用css画出三角形"></a>[Q] 用css画出三角形</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span><span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">"text/css"</span>&gt;</span></span><br><span class="line"><span class="css">        <span class="comment">/* css3绘制三角形 */</span></span></span><br><span class="line"><span class="css">        <span class="selector-class">.triangle</span>&#123;</span></span><br><span class="line"><span class="css">            <span class="selector-tag">width</span>: 0<span class="selector-tag">px</span>;                           <span class="comment">/*设置宽高为0，所以div的内容为空，从才能形成三角形尖角*/</span></span></span><br><span class="line">            height: 0px;</span><br><span class="line"><span class="css">            <span class="selector-tag">border-bottom</span>: 200<span class="selector-tag">px</span> <span class="selector-tag">solid</span> <span class="selector-id">#00a3af</span>;</span></span><br><span class="line"><span class="css">            <span class="selector-tag">border-left</span>: 200<span class="selector-tag">px</span> <span class="selector-tag">solid</span> <span class="selector-tag">transparent</span>;    <span class="comment">/*transparent 表示透明*/</span></span></span><br><span class="line">            border-right: 200px solid transparent;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"triangle"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><a href="https://blog.csdn.net/weixin_36270908/article/details/98947183" target="_blank" rel="noopener">https://blog.csdn.net/weixin_36270908/article/details/98947183</a></p>
<h2 id="清除浮动详解"><a href="#清除浮动详解" class="headerlink" title="清除浮动详解"></a>清除浮动详解</h2><p><a href="https://www.cnblogs.com/iyangyuan/archive/2013/03/27/2983813.html" target="_blank" rel="noopener">https://www.cnblogs.com/iyangyuan/archive/2013/03/27/2983813.html</a></p>
<h2 id="Q-三栏布局"><a href="#Q-三栏布局" class="headerlink" title="[Q] 三栏布局"></a>[Q] 三栏布局</h2><p>当中间内容超出时 <a href="https://jiafei2333.github.io/interview/layout_overflow.html" target="_blank" rel="noopener">https://jiafei2333.github.io/interview/layout_overflow.html</a> 中float中间部分超出 若希望中间内容不到左边去 可以给中间设为bfc 因为bfc不与float重叠 例如 overflow:hidden | overflow:auto;</p>
<p><code>box-sizing: content-box;</code> 默认</p>
<h1 id="React-Vue"><a href="#React-Vue" class="headerlink" title="React/Vue"></a>React/Vue</h1><h2 id="Q-写-React-Vue-项目时为什么要在列表组件中写-key，其作用是什么？"><a href="#Q-写-React-Vue-项目时为什么要在列表组件中写-key，其作用是什么？" class="headerlink" title="[Q] 写 React / Vue 项目时为什么要在列表组件中写 key，其作用是什么？"></a>[Q] 写 React / Vue 项目时为什么要在列表组件中写 key，其作用是什么？</h2><p><a href="https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/1" target="_blank" rel="noopener">https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/1</a><br>在交叉对比中，当新节点跟旧节点头尾交叉对比没有结果时，会根据新节点的key去对比旧节点数组中的key，从而找到相应旧节点（这里对应的是一个key =&gt; index 的map映射）。如果没找到就认为是一个新增节点。而如果没有key，那么就会采用遍历查找的方式去找到对应的旧节点。一种一个map映射，另一种是遍历查找。相比而言。map映射的速度更快。</p>
<p>key的作用是为了在diff算法执行时更快的找到对应的节点，提高diff速度。</p>
<h3 id="【拓展】"><a href="#【拓展】" class="headerlink" title="【拓展】"></a>【拓展】</h3><p>React/Vue Diff算法</p>
<h2 id="Q-React-中-setState-什么时候是同步的，什么时候是异步的？"><a href="#Q-React-中-setState-什么时候是同步的，什么时候是异步的？" class="headerlink" title="[Q] React 中 setState 什么时候是同步的，什么时候是异步的？"></a>[Q] React 中 setState 什么时候是同步的，什么时候是异步的？</h2><p>在React中，如果是由React引发的事件处理（比如通过onClick引发的事件处理），调用setState不会同步更新this.state，除此之外的setState调用会同步执行this.state。所谓“除此之外”，指的是绕过React通过addEventListener直接添加的事件处理函数，还有通过setTimeout/setInterval产生的异步调用。</p>
<p><strong>原因：</strong>在React的setState函数实现中，会根据一个变量isBatchingUpdates判断是直接更新this.state还是放到队列中回头再说，而isBatchingUpdates默认是false，也就表示setState会同步更新this.state，但是，有一个函数batchedUpdates，这个函数会把isBatchingUpdates修改为true，而当React在调用事件处理函数之前就会调用这个batchedUpdates，造成的后果，就是由React控制的事件处理过程setState不会同步更新this.state。</p>
<h2 id="Q-聊聊-Redux-和-Vuex-的设计思想"><a href="#Q-聊聊-Redux-和-Vuex-的设计思想" class="headerlink" title="[Q] 聊聊 Redux 和 Vuex 的设计思想"></a>[Q] 聊聊 Redux 和 Vuex 的设计思想</h2><h2 id="Q-聊聊-Vue-的双向数据绑定，Model-如何改变-View，View-又是如何改变-Model-的？"><a href="#Q-聊聊-Vue-的双向数据绑定，Model-如何改变-View，View-又是如何改变-Model-的？" class="headerlink" title="[Q] 聊聊 Vue 的双向数据绑定，Model 如何改变 View，View 又是如何改变 Model 的？"></a>[Q] 聊聊 Vue 的双向数据绑定，Model 如何改变 View，View 又是如何改变 Model 的？</h2><h2 id="Q-Virtual-DOM-真的比操作原生-DOM-快吗？谈谈你的想法。"><a href="#Q-Virtual-DOM-真的比操作原生-DOM-快吗？谈谈你的想法。" class="headerlink" title="[Q] Virtual DOM 真的比操作原生 DOM 快吗？谈谈你的想法。"></a>[Q] Virtual DOM 真的比操作原生 DOM 快吗？谈谈你的想法。</h2><h2 id="Q-react的constructor中为什么要写super-prop"><a href="#Q-react的constructor中为什么要写super-prop" class="headerlink" title="[Q] react的constructor中为什么要写super(prop"></a>[Q] react的constructor中为什么要写super(prop</h2><p>【解答】</p>
<p>1、我们为什么要调用super？能不能不调用它？</p>
<p>在 JavaScript 中，super 指代父类的构造函数。<br>在你调用父类构造函数之前，你无法在构造函数中使用 this。JavaScript 不会允许你这么做。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Checkbox</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="comment">//  这时候还不能使用 `this`</span></span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">    <span class="comment">//  现在开始可以了</span></span><br><span class="line">    <span class="keyword">this</span>.state = &#123; <span class="attr">isOn</span>: <span class="literal">true</span> &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>JavaScript 强制你在使用 this 前运行父类构造函数有一个很好的理由。考虑这样一个类结构：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(name) &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PolitePerson</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(name) &#123;</span><br><span class="line">    <span class="keyword">this</span>.greetColleagues(); <span class="comment">//  这是不允许的，下面会解释原因</span></span><br><span class="line">    <span class="keyword">super</span>(name);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  greetColleagues() &#123;</span><br><span class="line">    alert(<span class="string">'Good morning folks!'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>想象一下如果在调用 <code>super</code> 前使用 <code>this</code> 是被允许的。一个月之后。我们或许会改变 <code>greetColleagues</code> 把 <code>person</code> 的 <code>name</code> 加到消息中。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">greetColleagues() &#123;</span><br><span class="line">  alert(<span class="string">'Good morning folks!'</span>);</span><br><span class="line">  alert(<span class="string">'My name is '</span> + <span class="keyword">this</span>.name + <span class="string">', nice to meet you!'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但我们忘了 this.greetColleagues() 是在 super() 设置 this.name 之前被调用的。this.name 甚至还没被定义！如你所见，像这样的代码理解起来会很困难。</p>
<p>为了避免这样的陷阱，JavaScript 强制规定，如果你想在构造函数中用this，就必须先调用 super。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">  <span class="keyword">super</span>(props);</span><br><span class="line">  <span class="comment">// ✅ 现在可以使用 `this` 了</span></span><br><span class="line">  <span class="keyword">this</span>.state = &#123; <span class="attr">isOn</span>: <span class="literal">true</span> &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2、另一个问题：为什么要传 props？<br>事实上即便在调用 super() 时没有传入 props 参数，你依然能够在 render 和其它方法中访问 this.props<br>但在 super() 调用一直到构造函数结束之前，this.props 依然是未定义的</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// React 内部</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">this</span>.props = props;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 你的代码</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Button</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(); <span class="comment">//  我们忘了传入 props</span></span><br><span class="line">    <span class="built_in">console</span>.log(props);      <span class="comment">//  &#123;&#125;</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.props); <span class="comment">//  undefined</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这也是推荐总是使用 super(props) 的写法，即便这是非必要的。</p>
<p>1、调用super的原因：在ES6中，在子类的constructor中必须先调用super才能引用this；根本原因是constructor会覆盖父类的constructor，导致你父类构造函数没执行，所以手动执行下。<br>2、super(props)的目的：在constructor中可以使用this.props。</p>
<p>参看文章：<br><a href="https://juejin.im/post/5c04fea5f265da6133565696" target="_blank" rel="noopener">https://juejin.im/post/5c04fea5f265da6133565696</a></p>
<h1 id="JS"><a href="#JS" class="headerlink" title="JS"></a>JS</h1><h2 id="Q-‘1’-‘2’-‘3’-map-parseInt-what-amp-why"><a href="#Q-‘1’-‘2’-‘3’-map-parseInt-what-amp-why" class="headerlink" title="[Q] [‘1’, ‘2’, ‘3’].map(parseInt) what &amp; why ?"></a>[Q] [‘1’, ‘2’, ‘3’].map(parseInt) what &amp; why ?</h2><p>parseInt() 参数：<br>string    必需。要被解析的字符串。<br>radix    可选。表示要解析的数字的基数。该值介于 2 ~ 36 之间。如果省略该参数或其值为 0，则数字将以 10 为基础来解析。如果它以 “0x” 或 “0X” 开头，将以 16 为基数。如果该参数小于 2 或者大于 36，则 parseInt() 将返回 NaN。</p>
<p>解析：<a href="https://github.com/sisterAn/blog/issues/19" target="_blank" rel="noopener">https://github.com/sisterAn/blog/issues/19</a></p>
<h3 id="【拓展】-1"><a href="#【拓展】-1" class="headerlink" title="【拓展】"></a>【拓展】</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>、</span><br><span class="line">[<span class="string">'10'</span>,<span class="string">'10'</span>,<span class="string">'10'</span>,<span class="string">'10'</span>,<span class="string">'10'</span>,<span class="string">'10'</span>,<span class="string">'10'</span>,<span class="string">'10'</span>,<span class="string">'10'</span>,<span class="string">'10'</span>,<span class="string">'10'</span>,<span class="string">'10'</span>,<span class="string">'10'</span>,<span class="string">'10'</span>,<span class="string">'10'</span>,<span class="string">'10'</span>,<span class="string">'10'</span>,<span class="string">'10'</span>].map(<span class="built_in">parseInt</span>);</span><br><span class="line">[<span class="number">10</span>, <span class="literal">NaN</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span>, <span class="number">14</span>, <span class="number">15</span>, <span class="number">16</span>, <span class="number">17</span>]</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>、</span><br><span class="line">[<span class="string">'9'</span>,<span class="string">'9'</span>,<span class="string">'9'</span>,<span class="string">'9'</span>,<span class="string">'9'</span>,<span class="string">'9'</span>,<span class="string">'9'</span>,<span class="string">'9'</span>,<span class="string">'9'</span>,<span class="string">'9'</span>,<span class="string">'9'</span>,<span class="string">'9'</span>,<span class="string">'9'</span>,].map(<span class="built_in">parseInt</span>);</span><br><span class="line">[<span class="number">9</span>, <span class="literal">NaN</span>, <span class="literal">NaN</span>, <span class="literal">NaN</span>, <span class="literal">NaN</span>, <span class="literal">NaN</span>, <span class="literal">NaN</span>, <span class="literal">NaN</span>, <span class="literal">NaN</span>, <span class="literal">NaN</span>, <span class="number">9</span>, <span class="number">9</span>, <span class="number">9</span>]</span><br><span class="line"></span><br><span class="line"><span class="number">3</span>、</span><br><span class="line">[<span class="string">'11'</span>,<span class="string">'11'</span>,<span class="string">'11'</span>,<span class="string">'11'</span>,<span class="string">'11'</span>,<span class="string">'11'</span>,<span class="string">'11'</span>,<span class="string">'11'</span>,<span class="string">'11'</span>,<span class="string">'11'</span>,<span class="string">'11'</span>,<span class="string">'11'</span>,<span class="string">'11'</span>,<span class="string">'11'</span>,<span class="string">'11'</span>,<span class="string">'11'</span>,<span class="string">'11'</span>,<span class="string">'11'</span>].map(<span class="built_in">parseInt</span>);</span><br><span class="line">[<span class="number">11</span>,   <span class="literal">NaN</span>, <span class="number">3</span>,   <span class="number">4</span>,   <span class="number">5</span>,   <span class="number">6</span>,   <span class="number">7</span>,   <span class="number">8</span>,   <span class="number">9</span>,   <span class="number">10</span>,  <span class="number">11</span>,  <span class="number">12</span>,  <span class="number">13</span>,  <span class="number">14</span>,  <span class="number">15</span>,  <span class="number">16</span>,  <span class="number">17</span>,  <span class="number">18</span>]</span><br></pre></td></tr></table></figure>

<h3 id="【拓展】-2"><a href="#【拓展】-2" class="headerlink" title="【拓展】"></a>【拓展】</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> unary = <span class="function"><span class="params">fn</span> =&gt;</span> <span class="function"><span class="params">val</span> =&gt;</span> fn(val)</span><br><span class="line"><span class="keyword">let</span> parse = unary(<span class="built_in">parseInt</span>)</span><br><span class="line"><span class="built_in">console</span>.log([<span class="string">'1.1'</span>, <span class="string">'2'</span>, <span class="string">'0.3'</span>].map(parse))</span><br></pre></td></tr></table></figure>

<h2 id="Q-什么是防抖和节流？有什么区别？如何实现？"><a href="#Q-什么是防抖和节流？有什么区别？如何实现？" class="headerlink" title="[Q] 什么是防抖和节流？有什么区别？如何实现？"></a>[Q] 什么是防抖和节流？有什么区别？如何实现？</h2><p>【时间起因】<a href="https://github.com/mqyqingfeng/Blog/issues/22" target="_blank" rel="noopener">https://github.com/mqyqingfeng/Blog/issues/22</a> (只看原因，不看这里的原理解析)<br>【简洁归纳】防抖是虽然事件持续触发，但只有等事件停止触发后 n 秒才执行函数，节流是持续触发的时候，每 n 秒执行一次函数。</p>
<p><a href="https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/5" target="_blank" rel="noopener">https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/5</a></p>
<h3 id="防抖"><a href="#防抖" class="headerlink" title="防抖"></a>防抖</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">id</span>=<span class="string">"inp"</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> timeout = <span class="literal">null</span>; <span class="comment">// 创建一个标记用来存放定时器的返回值</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    clearTimeout(timeout); <span class="comment">// 每当用户输入的时候把前一个 setTimeout clear 掉</span></span><br><span class="line">    timeout = setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123; <span class="comment">// 然后又创建一个新的 setTimeout, 这样就能保证输入字符后的 interval 间隔内如果还有字符输入的话，就不会执行 fn 函数</span></span><br><span class="line">      fn.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>); <span class="comment">// line12 输出 input DOM</span></span><br><span class="line">      <span class="comment">// fn(); // line12 输出 Window对象</span></span><br><span class="line">    &#125;, <span class="number">2000</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayHi</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'防抖成功'</span>,<span class="keyword">this</span>); <span class="comment">// 当前调用sayHi方法的this</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> inp = <span class="built_in">document</span>.getElementById(<span class="string">'inp'</span>);</span><br><span class="line">inp.addEventListener(<span class="string">'input'</span>, debounce(sayHi)); <span class="comment">// 防抖 n 之间后执行一次 最后一次触发，2000后执行</span></span><br><span class="line"><span class="comment">//inp.addEventListener('input', sayHi); // 每次input中输入都触发</span></span><br></pre></td></tr></table></figure>

<p>[疑问] fn.apply(this, arguments);而不是这样 fn()<br>[解答] 为了确保上下文环境为当前的this，所以不能直接用fn。<br>如果单单为了打印那句console.log(‘防抖成功’);确实可以直接fn()，但我们得考虑实际情况，让sayHi的this指向input是必要的,例如我们需要在输入完改变字体颜色，如下:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayHi</span>(<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(<span class="string">'防抖成功'</span>); <span class="keyword">this</span>.style.color = <span class="string">'red'</span>; &#125;</span><br></pre></td></tr></table></figure>

<p>这个时候 <code>fn.apply(this, arguments);</code>的作用就显而易见了</p>
<h3 id="节流"><a href="#节流" class="headerlink" title="节流"></a>节流</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> canRun = <span class="literal">true</span>; <span class="comment">// 通过闭包保存一个标记</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!canRun) <span class="keyword">return</span>; <span class="comment">// 在函数开头判断标记是否为true，不为true则return</span></span><br><span class="line">    canRun = <span class="literal">false</span>; <span class="comment">// 立即设置为false</span></span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123; <span class="comment">// 将外部传入的函数的执行放在setTimeout中</span></span><br><span class="line">      fn.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">      <span class="comment">// 最后在setTimeout执行完毕后再把标记设置为true(关键)表示可以执行下一次循环了。当定时器没有执行的时候标记永远是false，在开头被return掉</span></span><br><span class="line">      canRun = <span class="literal">true</span>;</span><br><span class="line">    &#125;, <span class="number">500</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayHi</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(e.target.innerWidth, e.target.innerHeight);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">'resize'</span>, throttle(sayHi));</span><br></pre></td></tr></table></figure>

<p>【应用场景】防抖可以是提交按钮一直点，但是在一定的时间内只会触发一次；节流可以是scroll，用滚动条计算高度的时候原先会实时计算，用节流，可以每隔例如300ms计算一次。</p>
<h2 id="Q-介绍下-Set、Map、WeakSet-和-WeakMap-的区别？"><a href="#Q-介绍下-Set、Map、WeakSet-和-WeakMap-的区别？" class="headerlink" title="[Q] 介绍下 Set、Map、WeakSet 和 WeakMap 的区别？"></a>[Q] 介绍下 Set、Map、WeakSet 和 WeakMap 的区别？</h2><h2 id="Q-介绍下深度优先遍历和广度优先遍历，如何实现？"><a href="#Q-介绍下深度优先遍历和广度优先遍历，如何实现？" class="headerlink" title="[Q] 介绍下深度优先遍历和广度优先遍历，如何实现？"></a>[Q] 介绍下深度优先遍历和广度优先遍历，如何实现？</h2><h2 id="A-1"><a href="#A-1" class="headerlink" title="[A]"></a>[A]</h2><h2 id="Q-有以下-3-个判断数组的方法，请分别介绍它们之间的区别和优劣Object-prototype-toString-call-、-instanceof-以及-Array-isArray"><a href="#Q-有以下-3-个判断数组的方法，请分别介绍它们之间的区别和优劣Object-prototype-toString-call-、-instanceof-以及-Array-isArray" class="headerlink" title="[Q] 有以下 3 个判断数组的方法，请分别介绍它们之间的区别和优劣Object.prototype.toString.call() 、 instanceof 以及 Array.isArray() ?"></a>[Q] 有以下 3 个判断数组的方法，请分别介绍它们之间的区别和优劣Object.prototype.toString.call() 、 instanceof 以及 Array.isArray() ?</h2><h3 id="A-2"><a href="#A-2" class="headerlink" title="[A]"></a>[A]</h3><ol>
<li>Object.prototype.toString.call()</li>
</ol>
<p>每一个继承 Object 的对象都有 toString 方法，如果 toString 方法没有重写的话，会返回 [Object type]，其中 type 为对象的类型。但当除了 Object 类型的对象外，其他类型直接使用 toString 方法时，会直接返回都是内容的字符串，所以我们需要使用call或者apply方法来改变toString方法的执行上下文。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> an = [<span class="string">'Hello'</span>,<span class="string">'An'</span>];</span><br><span class="line">an.toString(); <span class="comment">// "Hello,An"</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(an); <span class="comment">// "[object Array]"</span></span><br></pre></td></tr></table></figure>

<p>这种方法对于所有基本的数据类型都能进行判断，即使是 null 和 undefined 。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="string">'An'</span>) <span class="comment">// "[object String]"</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="number">1</span>) <span class="comment">// "[object Number]"</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="built_in">Symbol</span>(<span class="number">1</span>)) <span class="comment">// "[object Symbol]"</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="literal">null</span>) <span class="comment">// "[object Null]"</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="literal">undefined</span>) <span class="comment">// "[object Undefined]"</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;) <span class="comment">// "[object Function]"</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(&#123;<span class="attr">name</span>: <span class="string">'An'</span>&#125;) <span class="comment">// "[object Object]"</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>instanceof</li>
</ol>
<p>instanceof 运算符用于检测构造函数的 prototype 属性是否出现在某个实例对象的原型链上。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">[]  <span class="keyword">instanceof</span> <span class="built_in">Array</span>; <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">M</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line"><span class="keyword">let</span> obj = <span class="keyword">new</span> M();</span><br><span class="line"><span class="built_in">console</span>.log(obj <span class="keyword">instanceof</span> M); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(obj <span class="keyword">instanceof</span> <span class="built_in">Object</span>); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(M <span class="keyword">instanceof</span> <span class="built_in">Object</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>Array.isArray()</li>
</ol>
<p>Array.isArray() 用于确定传递的值是否是一个 Array。</p>
<ul>
<li>当检测Array实例时, Array.isArray 优于 instanceof,因为Array.isArray能检测iframes.</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> iframe = <span class="built_in">document</span>.createElement(<span class="string">'iframe'</span>);</span><br><span class="line"><span class="built_in">document</span>.body.appendChild(iframe);</span><br><span class="line">xArray = <span class="built_in">window</span>.frames[<span class="built_in">window</span>.frames.length<span class="number">-1</span>].Array;</span><br><span class="line"><span class="keyword">var</span> arr = <span class="keyword">new</span> xArray(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>); <span class="comment">// [1,2,3]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Correctly checking for Array</span></span><br><span class="line"><span class="built_in">Array</span>.isArray(arr);  <span class="comment">// true</span></span><br><span class="line"><span class="comment">// Considered harmful, because doesn't work though iframes</span></span><br><span class="line">arr <span class="keyword">instanceof</span> <span class="built_in">Array</span>; <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<ul>
<li>Array.isArray() 与 Object.prototype.toString.call()</li>
</ul>
<p>Array.isArray()是ES5新增的方法，当不存在 Array.isArray() ，可以用 Object.prototype.toString.call() 实现。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (!<span class="built_in">Array</span>.isArray) &#123;</span><br><span class="line">  <span class="built_in">Array</span>.isArray = <span class="function"><span class="keyword">function</span>(<span class="params">arg</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Object</span>.prototype.toString.call(arg) === <span class="string">'[object Array]'</span>;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Q-全局作用域中，用-const-和-let-声明的变量不在-window-上，那到底在哪里？如何去获取？"><a href="#Q-全局作用域中，用-const-和-let-声明的变量不在-window-上，那到底在哪里？如何去获取？" class="headerlink" title="[Q] 全局作用域中，用 const 和 let 声明的变量不在 window 上，那到底在哪里？如何去获取？"></a>[Q] 全局作用域中，用 const 和 let 声明的变量不在 window 上，那到底在哪里？如何去获取？</h2><p>ES6规定，var 命令和 function 命令声明的全局变量，依旧是顶层对象的属性，但 let命令、const命令、class命令声明的全局变量，不属于顶层对象的属性。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">12</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.a); <span class="comment">// 12</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.f); <span class="comment">// f()&#123;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> aa = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">const</span> bb = <span class="number">2</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.aa); <span class="comment">// undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.bb); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>

<p><a href="https://jiafei2333.github.io/html/images/js-base04.png" target="_blank" rel="noopener"></a><br><a href="https://jiafei2333.github.io/html/images/js-base05.png" target="_blank" rel="noopener"></a><br>通过上图也可以看到，在全局作用域中，用 let 和 const 声明的全局变量并没有在全局对象中，只是一个块级作用域（Script）中</p>
<h2 id="Q-cookie-和-token-都存放在-header-中，为什么不会劫持-token？"><a href="#Q-cookie-和-token-都存放在-header-中，为什么不会劫持-token？" class="headerlink" title="[Q] cookie 和 token 都存放在 header 中，为什么不会劫持 token？"></a>[Q] cookie 和 token 都存放在 header 中，为什么不会劫持 token？</h2><p>【XSS攻击】<br>恶意攻击者往Web页面里插入恶意Script代码，当用户浏览该页之时，嵌入其中Web里面的Script代码会被执行，从而达到恶意攻击用户的目的。<br>【XSS危害】</p>
<ul>
<li>窃取网页浏览中的cookie值<br>登录完毕之后服务端会返回一个cookie值。这个cookie值相当于一个令牌，拿着这张令牌就等同于证明了你是某个用户。如果你的cookie值被窃取，那么攻击者很可能能够直接利用你的这张令牌不用密码就登录你的账户。如果想要通过script脚本获得当前页面的cookie值，通常会用到document.cookie。（不过某些厂商的cookie有其他验证措施如：Http-Only保证同一cookie不能被滥用）</li>
<li>劫持流量实现恶意跳转<br>这个很简单，就是在网页中想办法插入一句像这样的语句：<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;<span class="built_in">window</span>.location.href=<span class="string">"http://www.baidu.com"</span>;<span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>【CSRF攻击】<br>跨站请求伪造：攻击者诱导受害者进入第三方网站，在第三方网站中，向被攻击网站发送跨站请求。利用受害者在被攻击网站已经获取的注册凭证，绕过后台的用户验证，达到冒充用户对被攻击的网站执行某项操作的目的。<br>一个典型的CSRF攻击有着如下的流程：</p>
<ul>
<li>受害者登录a.com，并保留了登录凭证（Cookie）。</li>
<li>攻击者引诱受害者访问了b.com。</li>
<li>b.com 向 a.com 发送了一个请求：a.com/act=xx。浏览器会…</li>
<li>a.com接收到请求后，对请求进行验证，并确认是受害者的凭证，误以为是受害者自己发送的请求。</li>
<li>a.com以受害者的名义执行了act=xx。</li>
<li>攻击完成，攻击者在受害者不知情的情况下，冒充受害者，让a.com执行了自己定义的操作。</li>
</ul>
<p>浏览器发送请求的时候不会自动带上token，而cookie在浏览器发送请求的时候会被自动带上。csrf就是利用的这一特性，所以token可以防范csrf，而cookie不能。<br>1、首先token不是防止XSS的，而是为了防止CSRF的；<br>2、CSRF攻击的原因是浏览器会自动带上cookie，而浏览器不会自动带上token</p>
<h2 id="Q-下面的代码打印什么内容，为什么？"><a href="#Q-下面的代码打印什么内容，为什么？" class="headerlink" title="[Q] 下面的代码打印什么内容，为什么？"></a>[Q] 下面的代码打印什么内容，为什么？</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> b = <span class="number">10</span>;</span><br><span class="line">(<span class="function"><span class="keyword">function</span> <span class="title">b</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  b = <span class="number">20</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(b) <span class="comment">// [Function b]</span></span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure>

<p>【拓展】 自执行的具名函数A内部修改A的值无效</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> <span class="title">A</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(A); <span class="comment">// [Function A]</span></span><br><span class="line">    A = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">window</span>.A); <span class="comment">// undefined</span></span><br><span class="line">    <span class="built_in">console</span>.log(A); <span class="comment">// [Function A]</span></span><br><span class="line">&#125;())</span><br><span class="line"></span><br><span class="line">(<span class="function"><span class="keyword">function</span> <span class="title">A</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(A); <span class="comment">// undefined</span></span><br><span class="line">    <span class="keyword">var</span> A = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">window</span>.A); <span class="comment">// undefined</span></span><br><span class="line">    <span class="built_in">console</span>.log(A); <span class="comment">// 1</span></span><br><span class="line">&#125;())</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">A</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(A); <span class="comment">// [Function A]</span></span><br><span class="line">    A = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">window</span>.A); <span class="comment">// 1</span></span><br><span class="line">    <span class="built_in">console</span>.log(A); <span class="comment">// 1</span></span><br><span class="line">&#125;</span><br><span class="line">A();</span><br></pre></td></tr></table></figure>

<p>【拓展】</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> b = <span class="number">10</span>;</span><br><span class="line">(<span class="function"><span class="keyword">function</span> <span class="title">b</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">   <span class="comment">// 内部作用域，会先去查找是有已有变量b的声明，有就直接赋值20，确实有了呀。发现了具名函数 function b()&#123;&#125;，拿此b做赋值；</span></span><br><span class="line">   <span class="comment">// IIFE的函数无法进行赋值（内部机制，类似const定义的常量），所以无效。</span></span><br><span class="line">  <span class="comment">// （这里说的“内部机制”，想搞清楚，需要去查阅一些资料，弄明白IIFE在JS引擎的工作方式，堆栈存储IIFE的方式等）</span></span><br><span class="line">    b = <span class="number">20</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(b); <span class="comment">// [Function b]</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">window</span>.b); <span class="comment">// 10，不是20</span></span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>

<p>所以严格模式下能看到错误：Uncaught TypeError: Assignment to constant variable</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> b = <span class="number">10</span>;</span><br><span class="line">(<span class="function"><span class="keyword">function</span> <span class="title">b</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="meta">  'use strict'</span></span><br><span class="line">  b = <span class="number">20</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(b)</span><br><span class="line">&#125;)() <span class="comment">// "Uncaught TypeError: Assignment to constant variable."</span></span><br></pre></td></tr></table></figure>

<p>其他情况例子：<br>有window：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> b = <span class="number">10</span>;</span><br><span class="line">(<span class="function"><span class="keyword">function</span> <span class="title">b</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">window</span>.b = <span class="number">20</span>; </span><br><span class="line">    <span class="built_in">console</span>.log(b); <span class="comment">// [Function b]</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">window</span>.b); <span class="comment">// 20是必然的</span></span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>

<p>有var</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> b = <span class="number">10</span>;</span><br><span class="line">(<span class="function"><span class="keyword">function</span> <span class="title">b</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> b = <span class="number">20</span>; <span class="comment">// IIFE内部变量</span></span><br><span class="line">    <span class="built_in">console</span>.log(b); <span class="comment">// 20</span></span><br><span class="line">   <span class="built_in">console</span>.log(<span class="built_in">window</span>.b); <span class="comment">// 10 </span></span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>

<h2 id="Q-简单改造下面的代码，使之分别打印-10-和-20。"><a href="#Q-简单改造下面的代码，使之分别打印-10-和-20。" class="headerlink" title="[Q] 简单改造下面的代码，使之分别打印 10 和 20。"></a>[Q] 简单改造下面的代码，使之分别打印 10 和 20。</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> b = <span class="number">10</span>;</span><br><span class="line">(<span class="function"><span class="keyword">function</span> <span class="title">b</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    b = <span class="number">20</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(b); </span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>

<p>【解答】</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> b = <span class="number">10</span>;</span><br><span class="line">(<span class="function"><span class="keyword">function</span> <span class="title">b</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    b = <span class="number">20</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">window</span>.b); </span><br><span class="line">&#125;)();</span><br><span class="line"><span class="comment">// 打印10 方法一</span></span><br><span class="line"><span class="keyword">var</span> b = <span class="number">10</span>;</span><br><span class="line">(<span class="function"><span class="keyword">function</span> <span class="title">b</span>(<span class="params">b</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">window</span>.b = <span class="number">20</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(b); </span><br><span class="line">&#125;)(b);</span><br><span class="line"><span class="comment">// 打印10 方法二</span></span><br><span class="line"><span class="keyword">var</span> b = <span class="number">10</span>;</span><br><span class="line">(<span class="function"><span class="keyword">function</span> <span class="title">b</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> b = <span class="number">20</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(b); </span><br><span class="line">&#125;)();</span><br><span class="line"><span class="comment">// 打印20 方法一</span></span><br><span class="line"><span class="keyword">var</span> b = <span class="number">10</span>;</span><br><span class="line">(<span class="function"><span class="keyword">function</span> <span class="title">b</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> b = <span class="number">20</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(b); </span><br><span class="line">&#125;)();</span><br><span class="line"><span class="comment">// 打印20 方法二</span></span><br><span class="line"><span class="keyword">var</span> b = <span class="number">10</span>;</span><br><span class="line">(<span class="function"><span class="keyword">function</span> <span class="title">b</span>(<span class="params">b</span>)</span>&#123;</span><br><span class="line">    b = <span class="number">20</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(b); </span><br><span class="line">&#125;)(b);</span><br><span class="line"><span class="comment">// 打印20 方法三</span></span><br></pre></td></tr></table></figure>

<h2 id="Q-下面代码输出什么？"><a href="#Q-下面代码输出什么？" class="headerlink" title="[Q] 下面代码输出什么？"></a>[Q] 下面代码输出什么？</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">10</span>;</span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a)</span><br><span class="line">    a = <span class="number">5</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">window</span>.a)</span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">20</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(a)</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure>

<p>【解答】<br>undefined<br>10<br>20</p>
<h2 id="Q-实现一个-sleep-函数，比如-sleep-1000-意味着等待1000毫秒，可从-Promise、Generator、Async-Await-等角度"><a href="#Q-实现一个-sleep-函数，比如-sleep-1000-意味着等待1000毫秒，可从-Promise、Generator、Async-Await-等角度" class="headerlink" title="[Q] 实现一个 sleep 函数，比如 sleep(1000) 意味着等待1000毫秒，可从 Promise、Generator、Async/Await 等角度"></a>[Q] 实现一个 sleep 函数，比如 sleep(1000) 意味着等待1000毫秒，可从 Promise、Generator、Async/Await 等角度</h2><h2 id="Q-Object-assign-和-…-的区别"><a href="#Q-Object-assign-和-…-的区别" class="headerlink" title="[Q] Object.assign() 和 … 的区别"></a>[Q] Object.assign() 和 … 的区别</h2><ul>
<li>当一个 Object 使用了 Object.defineProperty 修改了 set 方法，因为调用 Object.assign 会触发 setter 方法，会触发意想不到的错误</li>
<li>如果将空对象作为第一个参数传递给Object.assign()，看起来 Object spread 会更快。</li>
</ul>
<h2 id="Q-为什么要用闭包-全部放在全局不好吗？"><a href="#Q-为什么要用闭包-全部放在全局不好吗？" class="headerlink" title="[Q] 为什么要用闭包 全部放在全局不好吗？"></a>[Q] 为什么要用闭包 全部放在全局不好吗？</h2><p>【解答】<br>垃圾回收：会去获取变量、方法被调用的次数，被调用的次数为0就会销毁；<br>把变量、方法等全部定义在全局是可以的，随着代码的执行早晚会被销毁；变量都在全局太多会重名 出现污染的情况所以要用闭包(避免全局变量污染)；闭包的缺点：内存泄漏 add = 一个方法（闭包方法）;add和这个方法形成一个调用栈，add不会释放，闭包里面的变量也不会释放，只能手动释放 add = null</p>
<h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><h2 id="Q-谈谈你对-TCP-三次握手和四次挥手的理解"><a href="#Q-谈谈你对-TCP-三次握手和四次挥手的理解" class="headerlink" title="[Q] 谈谈你对 TCP 三次握手和四次挥手的理解"></a>[Q] 谈谈你对 TCP 三次握手和四次挥手的理解</h2><p>【三次握手】</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">三次握手之所以是三次是保证client和server均让对方知道自己的接收和发送能力没问题而保证的最小次数。</span><br><span class="line"></span><br><span class="line">第一次client =&gt; server 只能server判断出client具备发送能力</span><br><span class="line">第二次 server =&gt; client client就可以判断出server具备发送和接受能力。此时client还需让server知道自己接收能力没问题于是就有了第三次</span><br><span class="line">第三次 client =&gt; server 双方均保证了自己的接收和发送能力没有问题</span><br><span class="line"></span><br><span class="line">其中，为了保证后续的握手是为了应答上一个握手，每次握手都会带一个标识 seq，后续的ACK都会对这个seq进行加一来进行确认。</span><br></pre></td></tr></table></figure>

<p>或者</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">1、客户端发送位码为syn＝1,随机产生seq number=1234567的数据包到服务器，服务器由SYN=1知道客户端要求建立联机（客户端：我要连接你）</span><br><span class="line">2、服务器收到请求后要确认联机信息，向A发送ack number=(客户端的seq+1),syn=1,ack=1,随机产生seq=7654321的包（服务器：好的，你来连吧）</span><br><span class="line">3、客户端收到后检查ack number是否正确，即第一次发送的seq number+1,以及位码ack是否为1，若正确，客户端会再发送ack number=(服务器的seq+1),ack=1，服务器收到后确认seq值与ack=1则连接建立成功。（客户端：好的，我来了）</span><br></pre></td></tr></table></figure>

<p>【拓展】<br>提问：为什么http建立连接需要三次握手，不是两次或四次？<br>回答: 三次是最少的安全次数，两次不安全，四次浪费资源</p>
<p>【四次挥手】</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">为什么要四次挥手？TCP是全双工，何为全双工就是客户端与服务端建立两条通道，通道1:客户端的输出连接服务端的输入；通道2:客户端的输入连接服务端的输出。两个通道可以同时工作：客户端向服务端发送信号的同时服务端也可以向客户端发送信号。所以关闭双通道的时候就是这样：</span><br><span class="line">客户端：我要关闭输入通道了。</span><br><span class="line">服务端：好的，你关闭吧，我这边也关闭这个通道。</span><br><span class="line"></span><br><span class="line">服务端：我也要关闭输入通道了。</span><br><span class="line">客户端：好的你关闭吧，我也把这个通道关闭。</span><br></pre></td></tr></table></figure>

<h2 id="Q-介绍下重绘和回流（Repaint-amp-Reflow），以及如何进行优化"><a href="#Q-介绍下重绘和回流（Repaint-amp-Reflow），以及如何进行优化" class="headerlink" title="[Q] 介绍下重绘和回流（Repaint &amp; Reflow），以及如何进行优化 ?"></a>[Q] 介绍下重绘和回流（Repaint &amp; Reflow），以及如何进行优化 ?</h2><h3 id="浏览器的渲染过程"><a href="#浏览器的渲染过程" class="headerlink" title="浏览器的渲染过程"></a>浏览器的渲染过程</h3><p>1、解析HTML，生成DOM树，解析CSS，生成CSSOM树<br>2、将DOM树和CSSOM树结合，生成渲染树(Render Tree)<br>3、根据RenderTree，我们就知道了所有节点的样式，然后计算他们在页面上的大小和位置，最后把节点绘制到页面上。<br>需要明白，这几个步骤并不一定一次性顺序完成。如果 DOM 或 CSSOM 被修改，以上过程需要重复执行，这样才能计算出哪些像素需要在屏幕上进行重新渲染。实际页面中，CSS 与 JavaScript 往往会多次修改 DOM 和 CSSOM。<br><a href="https://github.com/chenjigeng/blog/issues/4" target="_blank" rel="noopener">https://github.com/chenjigeng/blog/issues/4</a><br><a href="https://juejin.im/post/5a8e242c5188257a6b060000" target="_blank" rel="noopener">https://juejin.im/post/5a8e242c5188257a6b060000</a></p>
<h2 id="Q-浏览器输入URL后发生了什么？"><a href="#Q-浏览器输入URL后发生了什么？" class="headerlink" title="[Q] 浏览器输入URL后发生了什么？"></a>[Q] 浏览器输入URL后发生了什么？</h2><p><a href="https://www.xuecaijie.com/it/157.html#1Q64p5DeC8dKFF" target="_blank" rel="noopener">https://www.xuecaijie.com/it/157.html#1Q64p5DeC8dKFF</a></p>
<h2 id="Q-请求时浏览器缓存-from-memory-cache-和-from-disk-cache-的依据是什么，哪些数据什么时候存放在-Memory-Cache-和-Disk-Cache中"><a href="#Q-请求时浏览器缓存-from-memory-cache-和-from-disk-cache-的依据是什么，哪些数据什么时候存放在-Memory-Cache-和-Disk-Cache中" class="headerlink" title="[Q] 请求时浏览器缓存 from memory cache 和 from disk cache 的依据是什么，哪些数据什么时候存放在 Memory Cache 和 Disk Cache中"></a>[Q] 请求时浏览器缓存 from memory cache 和 from disk cache 的依据是什么，哪些数据什么时候存放在 Memory Cache 和 Disk Cache中</h2><p>了解下： <a href="https://juejin.im/post/5c22ee806fb9a049fb43b2c5?utm_source=gold_browser_extension" target="_blank" rel="noopener">https://juejin.im/post/5c22ee806fb9a049fb43b2c5?utm_source=gold_browser_extension</a></p>
<h1 id="Node"><a href="#Node" class="headerlink" title="Node"></a>Node</h1><h2 id="Q-介绍下-npm-模块安装机制，为什么输入-npm-install-就可以自动安装对应的模块？"><a href="#Q-介绍下-npm-模块安装机制，为什么输入-npm-install-就可以自动安装对应的模块？" class="headerlink" title="[Q] 介绍下 npm 模块安装机制，为什么输入 npm install 就可以自动安装对应的模块？"></a>[Q] 介绍下 npm 模块安装机制，为什么输入 npm install 就可以自动安装对应的模块？</h2><ul>
<li>发出npm install命令</li>
<li>查询node_modules目录之中是否已经存在指定模块<ul>
<li>若存在，不再重新安装</li>
<li>若不存在<ul>
<li>npm 向 registry 查询模块压缩包的网址 (<a href="https://registry.npmjs.org/react" target="_blank" rel="noopener">https://registry.npmjs.org/react</a> 跟模块名， 就会看到 react 模块所有版本的信息。) </li>
<li>下载压缩包，存放在根目录下的.npm目录里</li>
<li>解压压缩包到当前项目的node_modules目录</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>【拓展】<br>注意，一个模块安装以后，本地其实保存了两份。一份是<del>/.npm目录下的压缩包，另一份是node_modules目录下解压后的代码。<br>但是，运行npm install的时候，只会检查node_modules目录，而不会检查</del>/.npm目录。也就是说，如果一个模块在～/.npm下有压缩包，但是没有安装在node_modules目录中，npm 依然会从远程仓库下载一次新的压缩包。</p>
<h2 id="Q-浏览器和Node-事件循环的区别"><a href="#Q-浏览器和Node-事件循环的区别" class="headerlink" title="[Q] 浏览器和Node 事件循环的区别"></a>[Q] 浏览器和Node 事件循环的区别</h2><p><a href="https://jiafei2333.github.io/2019/09/16/EventLoop/" target="_blank" rel="noopener">https://jiafei2333.github.io/2019/09/16/EventLoop/</a></p>
<h1 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h1><h2 id="Q-两个数组合并成一个数组"><a href="#Q-两个数组合并成一个数组" class="headerlink" title="[Q] 两个数组合并成一个数组"></a>[Q] 两个数组合并成一个数组</h2><p>请把两个数组 [‘A1’, ‘A2’, ‘B1’, ‘B2’, ‘C1’, ‘C2’, ‘D1’, ‘D2’] 和 [‘A’, ‘B’, ‘C’, ‘D’]，合并为 [‘A1’, ‘A2’, ‘A’, ‘B1’, ‘B2’, ‘B’, ‘C1’, ‘C2’, ‘C’, ‘D1’, ‘D2’, ‘D’]。</p>
<p><a href="https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/39" target="_blank" rel="noopener">https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/39</a></p>
<h2 id="Q-改造下面的代码，使之输出0-9，写出你能想到的所有解法。"><a href="#Q-改造下面的代码，使之输出0-9，写出你能想到的所有解法。" class="headerlink" title="[Q] 改造下面的代码，使之输出0 - 9，写出你能想到的所有解法。"></a>[Q] 改造下面的代码，使之输出0 - 9，写出你能想到的所有解法。</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i&lt; <span class="number">10</span>; i++)&#123;</span><br><span class="line">	setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">		<span class="built_in">console</span>.log(i);</span><br><span class="line">    &#125;, <span class="number">1000</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>解法：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1 错  10个10</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i&lt; <span class="number">10</span>; i++)&#123;</span><br><span class="line">	setTimeout(<span class="function">(<span class="params">i</span>) =&gt;</span> &#123;</span><br><span class="line">		<span class="built_in">console</span>.log(i);</span><br><span class="line">    &#125;, <span class="number">1000</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 2 对</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i&lt; <span class="number">10</span>; i++)&#123;</span><br><span class="line">	setTimeout(<span class="function">(<span class="params">i</span>) =&gt;</span> &#123;</span><br><span class="line">		<span class="built_in">console</span>.log(i);</span><br><span class="line">    &#125;, <span class="number">1000</span>,i)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 3 对</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i&lt; <span class="number">10</span>; i++)&#123;</span><br><span class="line">	setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">		<span class="built_in">console</span>.log(i);</span><br><span class="line">    &#125;, <span class="number">1000</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 4 错 10个10</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i&lt; <span class="number">10</span>; i++)&#123;</span><br><span class="line">	setTimeout(<span class="function">(<span class="params">i</span>) =&gt;</span> &#123;</span><br><span class="line">		<span class="built_in">console</span>.log(i);</span><br><span class="line">    &#125;, <span class="number">1000</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 5 错 10个10</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i&lt; <span class="number">10</span>; i++)&#123;</span><br><span class="line">  (<span class="function"><span class="keyword">function</span>(<span class="params">i</span>)</span>&#123;</span><br><span class="line">    setTimeout(<span class="function">(<span class="params">i</span>) =&gt;</span> &#123;</span><br><span class="line">		  <span class="built_in">console</span>.log(i);</span><br><span class="line">    &#125;, <span class="number">1000</span>)</span><br><span class="line">  &#125;)(i)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 6 对</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i&lt; <span class="number">10</span>; i++)&#123;</span><br><span class="line">  (<span class="function"><span class="keyword">function</span>(<span class="params">i</span>)</span>&#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">		  <span class="built_in">console</span>.log(i);</span><br><span class="line">    &#125;, <span class="number">1000</span>)</span><br><span class="line">  &#125;)(i)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 7 对</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i&lt; <span class="number">10</span>; i++)&#123;</span><br><span class="line">  <span class="keyword">try</span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> i;</span><br><span class="line">  &#125;<span class="keyword">catch</span>(i)&#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">		  <span class="built_in">console</span>.log(i);</span><br><span class="line">    &#125;, <span class="number">1000</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 8 对</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i&lt;<span class="number">10</span>; i++) &#123;</span><br><span class="line">   <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">         resolve(i)</span><br><span class="line">   &#125;).then(<span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">        setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">           <span class="built_in">console</span>.log(data)</span><br><span class="line">      &#125;, <span class="number">1000</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 9 对</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i&lt;<span class="number">10</span>; i++) &#123;</span><br><span class="line">  setTimeout(<span class="built_in">console</span>.log.bind(<span class="literal">null</span>, i), <span class="number">1000</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>【拓展】<br>bind(null, …)</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">multiply</span> (<span class="params">x, y, z</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x * y * z;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> double = multiply.bind(<span class="literal">null</span>, <span class="number">2</span>);</span><br><span class="line"><span class="built_in">console</span>.log(double(<span class="number">3</span>, <span class="number">4</span>)); <span class="comment">// 24</span></span><br></pre></td></tr></table></figure>

<p>例如这里第一次就传了x的值，那么yz的值就后续调用里面传入的。</p>
<blockquote>
<p>bind() 的另一个最简单的用法是使一个函数拥有预设的初始参数。只要将这些参数（如果有的话）作为 bind() 的参数写在 this 后面。当绑定函数被调用时，这些参数会被插入到目标函数的参数列表的开始位置，传递给绑定函数的参数会跟在它们后面。</p>
</blockquote>
<h2 id="Q-使用迭代的方式实现-flatten-函数"><a href="#Q-使用迭代的方式实现-flatten-函数" class="headerlink" title="[Q] 使用迭代的方式实现 flatten 函数"></a>[Q] 使用迭代的方式实现 flatten 函数</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,[<span class="number">4</span>,<span class="number">5</span>],[<span class="number">6</span>,[<span class="number">7</span>,[<span class="number">8</span>]]]]</span><br></pre></td></tr></table></figure>

<p>【解答】</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,[<span class="number">4</span>,<span class="number">5</span>],[<span class="number">6</span>,[<span class="number">7</span>,[<span class="number">8</span>]]]]</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> flatten = <span class="function">(<span class="params">data</span>)=&gt;</span>&#123;</span><br><span class="line">  <span class="keyword">let</span> _temp = [];</span><br><span class="line">  (<span class="function"><span class="keyword">function</span> <span class="title">flattening</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">    data.forEach(<span class="function"><span class="params">item</span>=&gt;</span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(<span class="built_in">Array</span>.isArray(item))&#123;</span><br><span class="line">        <span class="keyword">return</span> flattening(item);</span><br><span class="line">      &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        _temp.push(item);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)(data)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> _temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(flatten(arr));</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,[<span class="number">4</span>,<span class="number">5</span>],[<span class="number">6</span>,[<span class="number">7</span>,[<span class="number">8</span>]]]]</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> flatten = <span class="function">(<span class="params">data</span>) =&gt;</span>&#123;</span><br><span class="line">  <span class="keyword">while</span>(data.some(<span class="function"><span class="params">item</span>=&gt;</span><span class="built_in">Array</span>.isArray(item)))&#123;</span><br><span class="line">    data = [].concat(...data);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> data;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(flatten(arr));</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,[<span class="number">4</span>,<span class="number">5</span>],[<span class="number">6</span>,[<span class="number">7</span>,[<span class="number">8</span>]]]]</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> flatten = <span class="function"><span class="params">data</span> =&gt;</span> data.reduce(<span class="function">(<span class="params">acc,cur</span>)=&gt;</span> (<span class="built_in">Array</span>.isArray(cur) ? [...acc, ...flatten(cur)] : [...acc, cur]), [])</span><br><span class="line"><span class="built_in">console</span>.log(flatten(arr));</span><br></pre></td></tr></table></figure>

<h2 id="Q-下面代码中-a-在什么情况下会打印-1？"><a href="#Q-下面代码中-a-在什么情况下会打印-1？" class="headerlink" title="[Q] 下面代码中 a 在什么情况下会打印 1？"></a>[Q] 下面代码中 a 在什么情况下会打印 1？</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = ?;</span><br><span class="line"><span class="keyword">if</span>(a == <span class="number">1</span> &amp;&amp; a == <span class="number">2</span> &amp;&amp; a == <span class="number">3</span>)&#123;</span><br><span class="line"> 	<span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>【解答】</p>
<p>== 会进行隐式类型转换 所以我们重写toString方法就可以了<br>这题考察的是类型的隐式转换,考引用类型在比较运算符时候,隐式转换会调用本类型toString或valueOf方法.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = &#123;</span><br><span class="line">  num: <span class="number">1</span>,</span><br><span class="line">  toString: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.num ++</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(a == <span class="number">1</span> &amp;&amp; a == <span class="number">2</span> &amp;&amp; a == <span class="number">3</span>)&#123;</span><br><span class="line"> 	<span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = &#123;</span><br><span class="line">  num: <span class="number">1</span>,</span><br><span class="line">  valueOf: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.num ++</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(a == <span class="number">1</span> &amp;&amp; a == <span class="number">2</span> &amp;&amp; a == <span class="number">3</span>)&#123;</span><br><span class="line"> 	<span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>valueOf优先级大于toString, 同时存在，会调用valueOf</p>
<h2 id="Q-筛选id相同和不相同的值"><a href="#Q-筛选id相同和不相同的值" class="headerlink" title="[Q] 筛选id相同和不相同的值"></a>[Q] 筛选id相同和不相同的值</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr1 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</span><br><span class="line"><span class="keyword">let</span> arr2 = [<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>];</span><br><span class="line">[...arr1,...arr2].reduce(<span class="function">(<span class="params">result,v</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> index=result.diff.indexOf(v)</span><br><span class="line">    <span class="keyword">if</span>(index!==<span class="number">-1</span>)&#123;</span><br><span class="line">        result.same.push(result.diff.splice(index,<span class="number">1</span>)[<span class="number">0</span>]);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        result.diff.push(v);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;,&#123;<span class="attr">same</span>:[],<span class="attr">diff</span>:[]&#125;)</span><br><span class="line"><span class="comment">// 打印结果：</span></span><br><span class="line">&#123;</span><br><span class="line">  diff:[<span class="number">2</span>,<span class="number">4</span>,<span class="number">7</span>],</span><br><span class="line">  same:[<span class="number">1</span>,<span class="number">2</span>,<span class="number">5</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Q-用最短的代码实现去重"><a href="#Q-用最短的代码实现去重" class="headerlink" title="[Q] 用最短的代码实现去重"></a>[Q] 用最短的代码实现去重</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">[...new <span class="built_in">Set</span>([<span class="number">1</span>,<span class="string">'1'</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">3</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印结果：</span></span><br><span class="line"><span class="comment">// [1, "1", 2, 3]</span></span><br></pre></td></tr></table></figure>

<h1 id="网站优化"><a href="#网站优化" class="headerlink" title="网站优化"></a>网站优化</h1><p>1、css、js文件压缩</p>
<p>2、dns预解析<link rel="ds-prefetch" href="//static.360buyimg.com"> 加载静态资源快 优先加载<br>3、双核浏览器 例如 360、搜狗 都是ie和chrome内核 <meta name="renderer" content="webkit">   表示渲染页面优先使用weikit</p>
<h1 id="语音面试题"><a href="#语音面试题" class="headerlink" title="语音面试题"></a>语音面试题</h1><h2 id="Q-什么是高阶组件，你在工作是如何应用的？"><a href="#Q-什么是高阶组件，你在工作是如何应用的？" class="headerlink" title="[Q] 什么是高阶组件，你在工作是如何应用的？"></a>[Q] 什么是高阶组件，你在工作是如何应用的？</h2><p>高阶组件（HOC）是 React 中用于复用组件逻辑的一种高级技巧。高阶组件是参数为组件，返回值为新组件的函数(高阶组件时一个函数，并不是组件)。组件是将 props 转换为 UI，而高阶组件是将组件转换为另一个组件。<br>请注意，HOC 不会修改传入的组件，也不会使用继承来复制其行为。相反，HOC 通过将组件包装在容器组件中来组成新组件。HOC 是纯函数，没有副作用。<br>不要在 render 方法中使用 HOC（render中的高阶组件会在每次render时重新mount，重新挂载组件会导致该组件及其所有子组件的状态丢失。）<br>重要：<a href="https://zh-hans.reactjs.org/docs/higher-order-components.html" target="_blank" rel="noopener">https://zh-hans.reactjs.org/docs/higher-order-components.html</a><br>应用场景： react-redux 的connect，react-router-dom withRouter，全局loading封装，Form.create()对表单form域中的数据进行统一的管理和处理,数据埋点？logger？，<br>代码复用: 将组件重复部分抽出来，在通过高阶组件拓展，增删改props，达到组件可复用的目的。<br>条件渲染：控制组件的渲染逻辑，常见：鉴权， 判断页面权限<br>生命周期捕获/劫持：借助父组件子组件生命周期规则捕获子组件的生命周期，常见case：打点。</p>
<p>高阶组件其实是装饰者模式在react中的一种实现，它类似于高阶函数，接收react组件 作为参数，返回一个新的react组件，高阶函数的实现方法有两种，分别是属性代理和反向代理，在工作中属性代理使用的比较多，例如用户权限页面的控制，我们基本上用的属性代理，这个原理其实是跟react-redux中的connect很相似，另一种就是组件的复用。<br>通常都是有一个函数传入一个组件，然后返回一个被增强的组件，目标就是把通用的业务逻辑抽象到高阶组件上，然后高阶组件通过属性传递给子组件，解决通用代码逻辑复用的问题，但是他会有两个问题，就是如果嵌套层级过深的话，会造成传值的数据流难以维护，重复的属性会被覆盖，还有就是这样子组件的使用权权在高阶组件本身，不够灵活。<br>反向继承、劫持、渲染劫持、切面编程 有点aop面向编程，有点装饰者设计模式的感觉</p>
<p>useState、useEffects可以代替高阶组件</p>
<p>分为代理方式的高阶组件；继承方式的高阶组件</p>
<h2 id="Q-展示组件-Presentational-component-和容器组件-Container-component-之间有何不同"><a href="#Q-展示组件-Presentational-component-和容器组件-Container-component-之间有何不同" class="headerlink" title="[Q] 展示组件(Presentational component)和容器组件(Container component)之间有何不同?"></a>[Q] 展示组件(Presentational component)和容器组件(Container component)之间有何不同?</h2><p>1、有状态【Stateful】和 无状态【Stateless】:<br>  容器组件倾向于有状态，展示组件倾向于无状态，这不是硬性规定，因为容器组件和展示组件都可以是有状态的。<br>2、类【Classes】 和 函数【Functions】<br>3、纯粹【Pure】 和 不纯粹 【Impure】:<br>    纯粹：输入什么就输出什么，不会再其中做相应的变动。<br>不管是展示组件还是容器组件都会有上面的二分特性。在我看来，展示组件往往是没有状态的纯函数，而容器组件往往是有状态的纯类。<br>这里把素材库的例子聚一下，中间card这块就是纯函数组件，可以视频、音频、图片多处复用解耦了逻辑和页面展示，取值、属性、方法回调什么的。</p>
<h2 id="Q-React中Refs的作用是什么？"><a href="#Q-React中Refs的作用是什么？" class="headerlink" title="[Q] React中Refs的作用是什么？"></a>[Q] React中Refs的作用是什么？</h2><p><a href="http://react.html.cn/docs/refs-and-the-dom.html" target="_blank" rel="noopener">http://react.html.cn/docs/refs-and-the-dom.html</a></p>
<p>三种创建方式：<br>1、直接指定ref = ‘xxx’ ref 是一个字符串，react不推荐使用了<br>2、通过React.createRef()创建，创建的ref 有个 current属性，函数组件如果需要使用，需要使用React.forwardRef 转发一下ref。hoc组件传递ref也存在同样的问题，需要使用React.forwardRef 转发<br>3、通过函数 ref={input =&gt; this.userName = input} ,获取值需要使用 this.userName.value</p>
<ul>
<li>当 ref 属性被用于一个普通的 HTML 元素时，React.createRef() 将接收底层 DOM 元素作为它的 current 属性以创建 ref 。</li>
<li>当 ref 属性被用于一个自定义类组件时，ref 对象将接收该组件已挂载的实例作为它的 current 。</li>
<li>你不能在函数式组件上使用 ref 属性，因为它们没有实例。如果要用就用React.forwardRef转发一下ref(…这里放函数组件)</li>
</ul>
<p>在非受控组件中使用，获取真实dom元素的值，或者获取焦点、控制video、audio的播放状态、或者是一些动画</p>
<p> useRef()？</p>
<h2 id="Q-组件的-状态-state-和属性-props-之间有何不同？"><a href="#Q-组件的-状态-state-和属性-props-之间有何不同？" class="headerlink" title="[Q] (组件的)状态(state)和属性(props)之间有何不同？"></a>[Q] (组件的)状态(state)和属性(props)之间有何不同？</h2><p>共同点： props 和 state 都属于 react 数据接口，他们都可以决定组件的行为和状态<br>不同点：<br>props 属于对外接口，state 属于对内接口，props 主要是父组件传递参数配置该组件，组件内部无法控制也无法修改。想要获取父组件的数据只能通过回调函数的形式（即在自组件中调用父组件的方法）。<br>state 主要用于保存，控制，修改组件自身状态，你可以理解state是一个局部的，只能被组件自身控制的数据源。不能被外界获取和修改。我们可以通过this.setState更新数据，setState导致组件重新渲染。<br>总之props是让外部对组件进行配置，state是让组件控制自己的状态<br>工作中：没有state的组件叫无状态组件，反之有状态组件，工作中尽量多无状态组件，尽量少写有状态组件，增加代码的可维护性和复用性。</p>
<h2 id="Q-React-context-是什么？有什么用？"><a href="#Q-React-context-是什么？有什么用？" class="headerlink" title="[Q] React context 是什么？有什么用？"></a>[Q] React context 是什么？有什么用？</h2><p>1、React Context优点：能够让数据在组件树中传递，基于树形结构共享数据的方式，在某个节点组件开启提供context后，所有后代节点组件都可以获取到共享的数据。<br>而props或者state进行多级数据传递，则数据需要自顶下流经过每一级组件，无法跨级。<br>2、React Context缺点：<br>（1）context相当于全局变量， 难以追溯数据源<br>（2）耦合度高，即不利于组件复用也不利于测试<br>（3）当 props 改变或者 setState 被调用，生成新的 context，但是 shouldComponentUpdate 返回的 false 会 block 住 context，导致没有更新。<br>3、React Context使用：可以通过Provider组件的value来传递数据，也可以通过调用react.createContext()来产生context，然后在Consumer组件获得context中的数据。</p>
<h2 id="Q-了解Redux么，说一下redux吧"><a href="#Q-了解Redux么，说一下redux吧" class="headerlink" title="[Q] 了解Redux么，说一下redux吧"></a>[Q] 了解Redux么，说一下redux吧</h2><p>Redux 本身是个状态管理框架,核心或者说目的一句话就能概括, 清晰的描述应用的状态 。<br>Redux 核心和原则<br>1.这个应用的状态是一个唯一的状态树<br>2.状态是只读的, 只能通过 action 来触发修改, 其实实际修改状态的是 reducer<br>3修改状态只能通过纯函数<br>Redux 中的概念<br>1.reducer<br>reducer 就是实际改变 state 的函数, 在 redux 中, 也只有 reducer 能够改变 state.<br>根据 redux 的原则, 整个应用只有一个唯一的状态树, 这样, 理论上只要一个 reducer 就够了. 但是, 实际编码时, 如果应用稍具规模, 只有一个 reducer 文件, 显然不利于分模块合作开发, 也不利于代码维护.<br>所以, reducer 一般是按模块, 或者根据你所使用的框架来组织, 会分散在多个文件夹中. 这时, 可以通过 redux 提供的 API combineReducers 来合并多个 reducer, 形成一个唯一的状态树.<br>reducer 的使用只要注意 2 点:1、必须是纯函数2、多个 reducer 文件时, 确保每个 reducer 处理不同的 action, 否则可能会出现后面的 reducer 被覆盖的情况<br>2.state<br>state 或者说是 store, 其实就是整个应用的状态.<br>3.action<br>redux 中的 action 其实就是一个 包含 type 字段的plain object. type 字段决定了要执行哪个 reducer, 其他字段作为 reducer 的参数.<br>4.action creator<br>action creator 本质是一个函数, 返回值是一个满足 action 的定义的 plain object. 使用 action creator 的目的就是简化 action 的定义<br>5.dispatch<br>　view层通过action来改变store从而改变当前的state，但是action只是一个对象而已,store.dispatch() 就是 view 发出 Action对象的唯一方法。<br>dispatch的中文意思就是派遣、发送的意思。 即将action发送到store.<br>6.subscribe<br> store允许使用 store.subscribe 方法设置监听函数，一旦 state 发生变化， 就自动执行这个函数。<br>7.middleware<br>redux 的 middleware 发生在 dispatching an action 和 reaches the reducer 之间. 在这个时间点, 除了可以实现异步操作, 还可以实现 logging等等.</p>
<h2 id="Q-什么是受控组件和非受控组件？"><a href="#Q-什么是受控组件和非受控组件？" class="headerlink" title="[Q] 什么是受控组件和非受控组件？"></a>[Q] 什么是受控组件和非受控组件？</h2><p>由React控制值的表单元素称为受控组件。受控组件的特点：<br>1.由React通过JSX渲染出来<br>2.由React控制值的改变，也就是说想要改变元素的值，只能通过React提供的方法来修改，并且只能通过setState来设置受控组件的值。<br>非受控组件则是将真实数据储存在DOM节点中，由表单元素本身维持自身状态，并根据用户输入进行更新。非受控组件的特点：<br>1.由元素本身维持自身状态，不需要为状态更新编写数据处理；<br>2.在React中设置默认值需要设置defaultValue，获取值需要使用ref。<br>在大多数情况下，建议使用受控组件来实现表单，因为非受控组对比受控组件，有以下一些缺点：<br>1.无法即时校验（提前校验用户输入）；<br>2.无法根据输入值的变化禁用提交按钮（通过禁用提交来约束用户输入）；<br>3.无法强制输入格式；<br>4.无法响应值的输入（如即时获得用户的输入来改变其他状态显示）；<br>5.无法动态输入。</p>
<h2 id="Q-怎么实现React组件的国际化？"><a href="#Q-怎么实现React组件的国际化？" class="headerlink" title="[Q] 怎么实现React组件的国际化？"></a>[Q] 怎么实现React组件的国际化？</h2><p>【解答】<br>一般像多语言国际化这种全局需求，我们可以使用 React 的 context 来全局共享一份相关数据，包含：“当前语言” 和一些通用词汇的语言包。</p>
<p>同时，React 组件本身也可以维护一套自己的语言包，比如时间选择器等，通过获取全局的 “当前语言”，然后通过映射获取指定位置的字符，进行拼接或展示。</p>
<p>在应用过程中，注意几点：</p>
<ol>
<li>切换语言是一个低频需求，但语言包可能会比较大，可以按需加载</li>
<li>限制词语或句子的长度，在语言切换时，长度可能会变化，比如英文单词可能比中文单词长，会影响布局</li>
<li>注意颜色在不同语言、文化中的差异</li>
<li>注意日期和货币格式在不同国家和地区的差异显示</li>
</ol>
<h2 id="Q-React为什么要搞Hooks，React-Hooks帮我们解决了哪些问题？"><a href="#Q-React为什么要搞Hooks，React-Hooks帮我们解决了哪些问题？" class="headerlink" title="[Q] React为什么要搞Hooks，React Hooks帮我们解决了哪些问题？"></a>[Q] React为什么要搞Hooks，React Hooks帮我们解决了哪些问题？</h2><p>【解答】</p>
<ol>
<li>class 组件需要编译成函数，增加了代码体积，hook 用在函数组件不会产生冗余代码</li>
<li>class 复用逻辑需要借助高阶组件，高阶组件嵌套会导致不能直接获取真实 ref，嵌套多个也会比较复杂，hook 可以使用自定义 hook 来复用逻辑</li>
<li>函数组件中没有 this，可以避免之前事件的绑定 this 问题</li>
<li>hook 的 useEffect 可以将订阅与取消订阅逻辑写在一处，减少重复代码</li>
<li>useEffect useCallback useMemo 第二个参数可以优化性能，只在依赖项改变时才会更新，不用像之前写在 shouldComponentUpdate 中再比较 props 去确认是否更新</li>
</ol>
<p>上面这部分可以参考，然后自己总结一版</p>
<h2 id="Q-创建React动画有哪些方式？"><a href="#Q-创建React动画有哪些方式？" class="headerlink" title="[Q] 创建React动画有哪些方式？"></a>[Q] 创建React动画有哪些方式？</h2><p>【解答】<br>创建React动画有以下几种：1.基于定时器或requestAnimationFrame的间隔动画；使用定时器可能会有掉帧问题，而使用requestAnimationFrame则性能较好，完全使用js，不依赖css，帧数跟屏幕刷新率一致，页面运行到后台会自动暂停提高性能。2.基于css3中的animation和transition简单动画；有较高的性能，代码量少，但是只能依赖于css效果，对于复杂动画比较难实现跟控制。3.React动画插件CssTransitionGroup；性能比较好，但限定于入场跟出场场景。4.其他第三方动画库。</p>
<h2 id="Q-你对immutable有了解吗？它有什么作用？"><a href="#Q-你对immutable有了解吗？它有什么作用？" class="headerlink" title="[Q] 你对immutable有了解吗？它有什么作用？"></a>[Q] 你对immutable有了解吗？它有什么作用？</h2><p>1、Immutable实现的原理<br>Immutable实现的原理是利用结构共享形成持久化数据结构，也就是使用旧数据创建新数据时，要保证旧数据同时可用且不变。同时为了避免 deepCopy 把所有节点都复制一遍带来的性能损耗，Immutable使用了结构共享，即如果对象树中一个节点发生变化，只修改这个节点和受它影响的父节点，其它节点则进行共享。<br>2、Immutable的优点<br>（1）节约内存<br>JavaScript 中的对象一般是可变的（Mutable），因为使用了引用赋值，新的对象简单的引用了原始对象，改变新的对象将影响到原始对象。为了解决这个问题，一般的做法是使用shallowCopy（浅拷贝）或 deepCopy（深拷贝）来避免被修改，但这样做造成了CPU和内存的浪费。Immutable 可以很好地解决这些问题。<br>（2）Undo/Redo，Copy/Paste，时间轴等功能容易实现<br>因为每次数据都是不一样的，只要把这些数据放到一个数组里储存起来，想回退到哪里就拿出对应数据即可，很容易开发出撤销重做这种功能。<br>（3）并发安全<br>Immutable Data一旦创建，就不能再被更改,也就不需要并发锁。<br>3、Immutable使用<br>（1）与React搭配使用，Immutable简洁高效的判断数据是否变化，提高渲染速度及性能<br>（2）与Redux/flux搭配使用</p>
<p>【或者】</p>
<p>immutable是实现Immutable data的库，这个库有大量的api可以产生不可被修改的数据，对Immutable对象的任何修改或添加删除操作都会返回一个新的Immutable对象。其实现原理是持久化数据结构，相对于深拷贝而言，通过旧数据来创建新数据的时候，只修改发生变化的节点及其父节点，他们节点保持共享，性能更好，处理速度更快。<br>跟React配合使用能提高性能：一方面如果在state中保存了一份有深层结构的引用类型的数据，如果没有Immutable.js，则需要深拷贝一份再做修改(Object.assign及react中的setState都是属于浅拷贝)。而用Immutable.js将state中的数据包装一下，不需深拷贝就可以直接修改。另一方面由于修改后返回的是新对象，React.js只需要在oldState.obj === newState.obj这一层就能判断出obj产生了变化，不需要深入obj的深层结构。</p>
<h2 id="Q-React性能优化有哪些方法？【未完】"><a href="#Q-React性能优化有哪些方法？【未完】" class="headerlink" title="[Q] React性能优化有哪些方法？【未完】"></a>[Q] React性能优化有哪些方法？【未完】</h2><p>【解答】<br>1.Code Splitting。利用webpack打包分离去重实现动态导入，减少重复性代码块。<br>React.memo包裹函数组件，进行组件记忆<br>如果使用Component那就需要shouldComponent进行优化，也可以使用使用pureComponent组件代替Component，前提是组件的状态是值类型，如果是引用类型则会出现异常。<br>使用react中的lazy,Suspense懒加载组件<br>使用React Fragments避免额外渲染<br>不要使用内联函数，不要再render方法中操作状态，render函数应该保证纯净<br>使用immutable数据，避免很多浑然不知的bug<br>组件尽可能的拆分解耦，可以让部分组件避免不必要的domdiff；给列表类组件提供key，让domdiff可以实现最少的更新操作；<br>在constructor中使用bind来绑定this，而不在使用时绑定或减少使用箭头函数，因为constructor只在组件初始化时执行一次，而使用时绑定是每次render都会执行，箭头函数也是如此；按需引入props，避免多余更新；使用css隐藏节点而不是强制加载和卸载；使用React.Fragment减少不必要DOM。<br>使用事件节流和防抖<br>使用CND托管文件和资源<br>使用Reselect避免重复计算样式：<br>组件少写内联样式<br>使用css动画代替js动画<br>transform: rotate(0deg) 开启css加速，屏蔽非标准webkit带来的bug<br>6.使用SSR，可以在服务端生成html后返回到客户端，使客服端能快速看到完整渲染的页面。<br>7.使用react性能查看工具了解组件加载到卸载的情况，方便优化代码。</p>
<h2 id="Q-描述事件在React中的处理方式？"><a href="#Q-描述事件在React中的处理方式？" class="headerlink" title="[Q] 描述事件在React中的处理方式？"></a>[Q] 描述事件在React中的处理方式？</h2>]]></content>
      <categories>
        <category>面试题</category>
      </categories>
      <tags>
        <tag>面试题</tag>
      </tags>
  </entry>
  <entry>
    <title>Redux</title>
    <url>/2020/03/16/Redux/</url>
    <content><![CDATA[<p><img src="https://jiafei2333.github.io/html/images/redux01.png" alt title="简单原理图"></p>
<p><img src="http://img.zhufengpeixun.cn/redux-flow.png" alt title="Redux工作流"></p>
<blockquote>
<p>redux是个数据流，并不依赖于react，可以和任何框架结合使用</p>
</blockquote>
<h2 id="Redux-三大原则"><a href="#Redux-三大原则" class="headerlink" title="Redux 三大原则"></a>Redux 三大原则</h2><ul>
<li>整个应用的 state 被储存在一棵 object tree 中，并且这个 object tree 只存在于唯一一个 store 中</li>
<li>State 是只读的，惟一改变 state 的方法就是触发 action，action 是一个用于描述已发生事件的普通对象 使用纯函数来执行修改，为了描述action如何改变state tree ，你需要编写 reducers</li>
<li>单一数据源的设计让React的组件之间的通信更加方便，同时也便于状态的统一管理</li>
</ul>
<h2 id="Redux"><a href="#Redux" class="headerlink" title="Redux"></a>Redux</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> initialState = &#123;</span><br><span class="line">    title: &#123;<span class="attr">color</span>:<span class="string">'red'</span>,<span class="attr">text</span>:<span class="string">'标题'</span>&#125;,</span><br><span class="line">    content: &#123;<span class="attr">color</span>:<span class="string">'green'</span>,<span class="attr">text</span>:<span class="string">'内容'</span>&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reducer</span>(<span class="params">state = initialState, action</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (action.type) &#123;</span><br><span class="line">        <span class="keyword">case</span> UPDATE_TITLE_COLOR:</span><br><span class="line">            <span class="keyword">return</span> &#123;</span><br><span class="line">                ...state,</span><br><span class="line">                title:&#123;</span><br><span class="line">                    ...state.title,</span><br><span class="line">                    color: action.payload</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">return</span> state;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">createStore</span>(<span class="params">reducer</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> state;</span><br><span class="line">    <span class="keyword">let</span> listener;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">getState</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> state;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// action有格式要求，第一个必须是一个纯对象，new Object&#123;&#125;,第二个必须要有一个type属性</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">dispatch</span>(<span class="params">action</span>)</span>&#123;</span><br><span class="line">        state = reducer(state,action);</span><br><span class="line">        <span class="comment">// 发布</span></span><br><span class="line">        listener.forEach(<span class="function"><span class="params">item</span>=&gt;</span>item());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 订阅 当state状态改变的时候能自动去render页面</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">subscribe</span>(<span class="params">listener</span>)</span>&#123;</span><br><span class="line">        listener.push(listener);</span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123; <span class="comment">// 返回取消订阅方法</span></span><br><span class="line">            <span class="keyword">return</span> listener.filter(<span class="function"><span class="params">item</span> =&gt;</span> !item === listener);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 这步的目的是，初始reducer中的state是undefined的，派发这个动作，将initiState赋值给reducer中的state</span></span><br><span class="line">    <span class="comment">// 所以以后调用 store.dispatch(&#123;type:'UPDATE_TITLE_COLOR',payload:'block'&#125;);这种时只需要传action的值即可</span></span><br><span class="line">    dispatch(&#123;<span class="attr">type</span>:<span class="string">'@@REDUX/INIT'</span>&#125;);</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        getState,</span><br><span class="line">        dispatch,</span><br><span class="line">        subscribe</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> store = createStore(reducer);</span><br><span class="line">store.getState();</span><br><span class="line">store.dispatch(&#123;<span class="attr">type</span>:<span class="string">'...'</span>, <span class="attr">payload</span>: <span class="string">'...'</span>&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 假设这里有一个渲染的方法 </span></span><br><span class="line">renderApp(); <span class="comment">// 第一次需要手动渲染</span></span><br><span class="line"><span class="comment">// 订阅 - 监听</span></span><br><span class="line"><span class="keyword">let</span> unSubscribe = store.subscribe(renderApp);</span><br><span class="line"><span class="comment">// 取消订阅</span></span><br><span class="line">unSubscribe();</span><br></pre></td></tr></table></figure>

<h2 id="React-Redux"><a href="#React-Redux" class="headerlink" title="React + Redux"></a>React + Redux</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; createStore &#125; <span class="keyword">from</span> <span class="string">'../redux'</span>;</span><br><span class="line"><span class="keyword">import</span> store <span class="keyword">from</span> <span class="string">'../store'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Counter</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">        <span class="keyword">super</span>(props);</span><br><span class="line">        <span class="keyword">this</span>.state = &#123; <span class="attr">value</span>: <span class="number">0</span> &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    componentDidMount() &#123;</span><br><span class="line">        <span class="comment">// 监听() =&gt; this.setState(&#123; value: store.getState() &#125;) ，当reducer中状态改变时执行setStatet方法render页面</span></span><br><span class="line">        <span class="keyword">this</span>.unsubscribe = store.subscribe(<span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">this</span>.setState(&#123; <span class="attr">value</span>: store.getState() &#125;));</span><br><span class="line">    &#125;</span><br><span class="line">    componentWillUnmount() &#123;</span><br><span class="line">        <span class="comment">// 组件卸载时取消监听事件，如果不取消，组件卸载之后this.setState中的this实例没有就会报错</span></span><br><span class="line">        <span class="keyword">this</span>.unsubscribe();</span><br><span class="line">    &#125;</span><br><span class="line">    render() &#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                &lt;p&gt;&#123;<span class="keyword">this</span>.state.value&#125;&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">                &lt;button onClick=&#123;() =&gt; store.dispatch(&#123; type: 'INCREMENT' &#125;)&#125;&gt;+&lt;/</span>button&gt;</span><br><span class="line">                &lt;button onClick=&#123;() =&gt; store.dispatch(&#123; <span class="attr">type</span>: <span class="string">'DECREMENT'</span> &#125;)&#125;&gt;-<span class="xml"><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">            &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">        )</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>

<h2 id="bindActionCreators"><a href="#bindActionCreators" class="headerlink" title="bindActionCreators"></a>bindActionCreators</h2><h3 id="1-actionCreate"><a href="#1-actionCreate" class="headerlink" title="[1] actionCreate"></a>[1] actionCreate</h3><p><code>() =&gt; store.dispatch({ type: &#39;INCREMENT&#39; })</code> 如何简化这个写法</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">increment</span>(<span class="params"></span>)</span>&#123; <span class="comment">// actionCreator  action的创建函数</span></span><br><span class="line">    <span class="keyword">return</span>&#123; <span class="attr">type</span>: <span class="string">'INCREMENT'</span> &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">decrement</span>(<span class="params"></span>)</span>&#123; <span class="comment">// actionCreator  action的创建函数</span></span><br><span class="line">    <span class="keyword">return</span>&#123; <span class="attr">type</span>: <span class="string">'DECREMENT'</span> &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;button onClick=&#123;() =&gt; store.dispatch(increment())&#125;&gt;+<span class="xml"><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">&lt;button onClick=&#123;() =&gt; store.dispatch(decrement())&#125;&gt;-<span class="xml"><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<h3 id="2-bindActionCreators"><a href="#2-bindActionCreators" class="headerlink" title="[2] bindActionCreators"></a>[2] bindActionCreators</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; bindActionCreators &#125; <span class="keyword">from</span> <span class="string">'redux'</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">increment</span>(<span class="params"></span>)</span>&#123; <span class="comment">// actionCreator  action的创建函数</span></span><br><span class="line">    <span class="keyword">return</span>&#123; <span class="attr">type</span>: <span class="string">'INCREMENT'</span> &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">decrement</span>(<span class="params"></span>)</span>&#123; <span class="comment">// actionCreator  action的创建函数</span></span><br><span class="line">    <span class="keyword">return</span>&#123; <span class="attr">type</span>: <span class="string">'DECREMENT'</span> &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// bindActionCreators 绑定actionCreators  actionCreators跟dispatch自动绑定在一起</span></span><br><span class="line">increment = bindActionCreators(increment, store.dispatch);</span><br><span class="line">decrement = bindActionCreators(decrement, store.dispatch);</span><br><span class="line"></span><br><span class="line">&lt;button onClick=&#123;increment&#125;&gt;+<span class="xml"><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">&lt;button onClick=&#123;decrement&#125;&gt;-<span class="xml"><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<h3 id="3-手写-bindActionCreator"><a href="#3-手写-bindActionCreator" class="headerlink" title="[3] 手写 bindActionCreator"></a>[3] 手写 bindActionCreator</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// bindAcrionCreators.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> (<span class="params">actionCreator,dispatch</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> dispatch(actionCreator());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-绑定多个-bindActionCreators"><a href="#4-绑定多个-bindActionCreators" class="headerlink" title="[4] 绑定多个 bindActionCreators"></a>[4] 绑定多个 bindActionCreators</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; bindActionCreators &#125; <span class="keyword">from</span> <span class="string">'./redux'</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">increment</span>(<span class="params"></span>)</span>&#123; <span class="comment">// actionCreator  action的创建函数</span></span><br><span class="line">    <span class="keyword">return</span>&#123; <span class="attr">type</span>: <span class="string">'INCREMENT'</span> &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">decrement</span>(<span class="params"></span>)</span>&#123; <span class="comment">// actionCreator  action的创建函数</span></span><br><span class="line">    <span class="keyword">return</span>&#123; <span class="attr">type</span>: <span class="string">'DECREMENT'</span> &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> actions = &#123;increment, decrement&#125;;</span><br><span class="line">actions = bindActionCreators(actions, store.dispatch);</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// bindAcrionCreators.js</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 此方法只能接受一个actionCreator   actionCreator是一个函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bindActionCreator</span>(<span class="params">actionCreator,dispatch</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> dispatch(actionCreator());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span>(<span class="params">actionCreators, dispatch</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">typeof</span> actionCreators == <span class="string">'function'</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> bindActionCreator(actionCreators, dispatch);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> bundActionCreators = &#123;&#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> key <span class="keyword">in</span> actionCreators)&#123;</span><br><span class="line">        bundActionCreators[key] = bindActionCreator(actionCreators[key],dispatch);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> bundActionCreators;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-bindActionCreators-传参"><a href="#5-bindActionCreators-传参" class="headerlink" title="[5] bindActionCreators 传参"></a>[5] bindActionCreators 传参</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bindActionCreator</span>(<span class="params">actionCreator,dispatch</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">...args</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> dispatch(actionCreator(...args));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span>(<span class="params">actionCreators, dispatch</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">typeof</span> actionCreators == <span class="string">'function'</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> bindActionCreator(actionCreators, dispatch);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> bundActionCreators = &#123;&#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> key <span class="keyword">in</span> actionCreators)&#123;</span><br><span class="line">        bundActionCreators[key] = bindActionCreator(actionCreators[key],dispatch);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> bundActionCreators;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">----</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; bindActionCreators &#125; <span class="keyword">from</span> <span class="string">'./redux'</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">increment</span>(<span class="params">payload</span>)</span>&#123; </span><br><span class="line">    <span class="keyword">return</span>&#123; <span class="attr">type</span>: <span class="string">'INCREMENT'</span>, payload &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">decrement</span>(<span class="params">payload</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span>&#123; <span class="attr">type</span>: <span class="string">'DECREMENT'</span>, payload&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> actions = &#123;increment, decrement&#125;;</span><br><span class="line">actions = bindActionCreators(actions, store.dispatch);</span><br><span class="line"></span><br><span class="line">-----</span><br><span class="line"></span><br><span class="line">&lt;button onClick=&#123;()=&gt;action.increment(<span class="number">2</span>)&#125;&gt;+<span class="xml"><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">&lt;button onClick=&#123;()=&gt;action.decrement(<span class="number">3</span>)&#125;&gt;-<span class="xml"><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<h2 id="combineReducers"><a href="#combineReducers" class="headerlink" title="combineReducers"></a>combineReducers</h2><h3 id="1-用法"><a href="#1-用法" class="headerlink" title="[1] 用法"></a>[1] 用法</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; combineReducers &#125; <span class="keyword">from</span> <span class="string">'redux'</span>;</span><br><span class="line"><span class="keyword">import</span> conuter1 <span class="keyword">from</span> <span class="string">'./counter1'</span>;</span><br><span class="line"><span class="keyword">let</span> reducer = combineReducers(&#123;</span><br><span class="line">    conuter1,</span><br><span class="line">    conuter2</span><br><span class="line">    ...</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="2-手写combineReducers"><a href="#2-手写combineReducers" class="headerlink" title="[2] 手写combineReducers"></a>[2] 手写combineReducers</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">combindReducers</span>(<span class="params">reducers</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 合并完了之后状态树 key是合并的状态树的属性名，值就是那个reducer</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">state=&#123;&#125;,action</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">let</span> nextState = &#123;&#125;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> key <span class="keyword">in</span> reducers)&#123;</span><br><span class="line">            nextState[key] = reducers[key](state[key],action);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nextState;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="react-redux"><a href="#react-redux" class="headerlink" title="react-redux"></a>react-redux</h2><p>react组件和redux仓库进行自动关联的一个库</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// index.js</span></span><br><span class="line"><span class="keyword">import</span> store <span class="keyword">from</span> <span class="string">'./store'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;Provider&#125; <span class="keyword">from</span> <span class="string">'./react-redux'</span>;</span><br><span class="line">ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">Provider</span> <span class="attr">store</span>=<span class="string">&#123;store&#125;</span>&gt;</span> ... <span class="tag">&lt;/<span class="name">Provider</span>&gt;</span></span>,<span class="built_in">document</span>.getElementById(<span class="string">'root'</span>));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Counter.js</span></span><br><span class="line"><span class="keyword">import</span> &#123;connect&#125; <span class="keyword">from</span> <span class="string">'react-redux'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> mapStateToProps = <span class="function"><span class="params">state</span>=&gt;</span>(&#123;<span class="attr">value</span>:state.counter&#125;);</span><br><span class="line"><span class="keyword">let</span> mapDispatchToProps = ;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> connect(</span><br><span class="line">    mapStateToProps,</span><br><span class="line">    mapDispatchToProps</span><br><span class="line">)(Counter)</span><br></pre></td></tr></table></figure>

<h3 id="1-手写connect"><a href="#1-手写connect" class="headerlink" title="[1] 手写connect"></a>[1] 手写connect</h3><p>// react-redux/Provider.js</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> Context <span class="keyword">from</span> <span class="string">'./Context'</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Provider</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span></span>&#123;</span><br><span class="line">    render()&#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            &lt;Context.Provider value=&#123;&#123;<span class="attr">store</span>: <span class="keyword">this</span>.props.store&#125;&#125;&gt;</span><br><span class="line">                &#123;<span class="keyword">this</span>.props.children&#125;</span><br><span class="line">            &lt;<span class="regexp">/Context.Provider&gt;</span></span><br><span class="line"><span class="regexp">        )</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>

<p>// react-redux/Context</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> React.createContext();</span><br></pre></td></tr></table></figure>

<p>// react-redux/connect.js</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">"react"</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; bindActionCreators &#125; <span class="keyword">from</span> <span class="string">"../redux"</span>;</span><br><span class="line"><span class="keyword">import</span>  Context  <span class="keyword">from</span> <span class="string">"./Context"</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span>(<span class="params">mapStateToProps, mapDispatchToProps</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">wrapWithConnect</span>(<span class="params">WrappedComponent</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="class"><span class="keyword">class</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">      <span class="keyword">static</span> contextType = Context;</span><br><span class="line">      <span class="keyword">constructor</span>(props, context) &#123;</span><br><span class="line">        <span class="keyword">super</span>(props);</span><br><span class="line">        <span class="keyword">this</span>.state = mapStateToProps(context.store.getState());</span><br><span class="line">      &#125;</span><br><span class="line">      componentDidMount() &#123;</span><br><span class="line">        <span class="keyword">this</span>.unsubscribe = <span class="keyword">this</span>.context.store.subscribe(<span class="function"><span class="params">()</span> =&gt;</span></span><br><span class="line">          <span class="keyword">this</span>.setState(mapStateToProps(<span class="keyword">this</span>.context.store.getState()))</span><br><span class="line">        );</span><br><span class="line">      &#125;</span><br><span class="line">      shouldComponentUpdate() &#123;</span><br><span class="line">          <span class="comment">// 判断新老状态是否一样，一样就不更新</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.state === mapStateToProps(<span class="keyword">this</span>.context.store.getState())) &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      componentWillUnmount() &#123;</span><br><span class="line">        <span class="keyword">this</span>.unsubscribe();</span><br><span class="line">      &#125;</span><br><span class="line">      render() &#123;</span><br><span class="line">        <span class="keyword">let</span> actions = bindActionCreators(</span><br><span class="line">          mapDispatchToProps,</span><br><span class="line">          <span class="keyword">this</span>.context.store.dispatch</span><br><span class="line">        );</span><br><span class="line">        <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">WrappedComponent</span> &#123;<span class="attr">...this.props</span>&#125; &#123;<span class="attr">...this.state</span>&#125; &#123;<span class="attr">...actions</span>&#125; /&gt;</span>;</span></span><br><span class="line"><span class="xml">      &#125;</span></span><br><span class="line"><span class="xml">    &#125;;</span></span><br><span class="line"><span class="xml">  &#125;;</span></span><br><span class="line"><span class="xml">&#125;</span></span><br></pre></td></tr></table></figure>

<h2 id="Redux中间件"><a href="#Redux中间件" class="headerlink" title="Redux中间件"></a>Redux中间件</h2><p>中间件派发action之后，reducer之前<br>原理：拦截dispatch，增强dispatch</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1、缓存老的dispatch</span></span><br><span class="line"><span class="comment">// 2、重写dispatch方法</span></span><br><span class="line"><span class="keyword">let</span> oldDispatch = store.dispatch;</span><br><span class="line">store.dispatch = <span class="function"><span class="keyword">function</span>(<span class="params">action</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'%c prev state'</span>,<span class="string">'font:bold;color:gray'</span>,store.getState());</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'%c action'</span>, <span class="string">'font:bold;color:green'</span>,action);</span><br><span class="line">    oldDispatch(action);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'%c next state'</span>,<span class="string">'font:bold;color:blue'</span>,store.getState());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以理解为面向切面编程，AOP</p>
<h3 id="redux-logger"><a href="#redux-logger" class="headerlink" title="redux-logger"></a>redux-logger</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// getState获取仓库状态</span></span><br><span class="line"><span class="comment">// dispatch用来重新派发动作(这个dispatch就是改造后的最终的dispatch，不是原来的dispatch)</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> (<span class="params">&#123;getState, dispatch&#125;</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">next</span>)</span>&#123; <span class="comment">// 代表下一个中间件next</span></span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">action</span>)</span>&#123; <span class="comment">// 动作action</span></span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'%c prev state'</span>,<span class="string">'font:bold;color:gray'</span>,getState());</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'%c action'</span>, <span class="string">'font:bold;color:green'</span>,action);</span><br><span class="line">            next(action);</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'%c next state'</span>,<span class="string">'font:bold;color:blue'</span>,getState());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>中间件的原理和koa是一样的</p>
</blockquote>
<h3 id="redux-thunk"><a href="#redux-thunk" class="headerlink" title="redux-thunk"></a>redux-thunk</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> (<span class="params">&#123;getState, dispatch&#125;</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">next</span>)</span>&#123; <span class="comment">// 代表下一个中间件next</span></span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">action</span>)</span>&#123; <span class="comment">// 动作action</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">typeof</span> action === <span class="string">'function'</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> action(dispatch, getState);</span><br><span class="line">            &#125;</span><br><span class="line">            next(action);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="redux-promise"><a href="#redux-promise" class="headerlink" title="redux-promise"></a>redux-promise</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> (<span class="params">&#123;getState, dispatch&#125;</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">next</span>)</span>&#123; <span class="comment">// 代表下一个中间件next</span></span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">action</span>)</span>&#123; <span class="comment">// 动作action</span></span><br><span class="line">            <span class="keyword">if</span>(action.then &amp;&amp; <span class="keyword">typeof</span> action.then === <span class="string">'function'</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> action.then(dispatch);</span><br><span class="line">            &#125;</span><br><span class="line">            next(action);∂</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="compose"><a href="#compose" class="headerlink" title="compose"></a>compose</h3><p>[拓展]</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> result = add3(add2(add1(<span class="string">'ceshi'</span>)));</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">let</span> result = compose(add3, add2, add1)(<span class="string">'ceshi'</span>);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">compose</span>(<span class="params">...fns</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(fns.length === <span class="number">0</span>) <span class="keyword">return</span> <span class="function"><span class="params">args</span>=&gt;</span>args;</span><br><span class="line">    <span class="keyword">if</span>(fns.length === <span class="number">1</span>) <span class="keyword">return</span> fns[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">return</span> fns.reduce(<span class="function">(<span class="params">a,b</span>) =&gt;</span> <span class="function">(<span class="params">...args</span>) =&gt;</span> (a(b(...args))));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="applyMiddleware"><a href="#applyMiddleware" class="headerlink" title="applyMiddleware"></a>applyMiddleware</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// let store = createStore(reducer);</span></span><br><span class="line"><span class="keyword">let</span> store = applyMiddleware(promise, thunk, logger)(createStore)(reducer);</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> store;</span><br></pre></td></tr></table></figure>

<p>【applyMiddleware 实现】</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">applyMiddleware</span>(<span class="params">...middlewares</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 返回一个方法 传入 (createStore)</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">createStore</span>)</span>&#123;</span><br><span class="line">        <span class="comment">// 返回一个方法 传入 (reducer)</span></span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">reduce</span>)</span>&#123;</span><br><span class="line">            <span class="keyword">let</span> store = createStore(reducer);</span><br><span class="line">            <span class="keyword">let</span> dispatch;</span><br><span class="line">            <span class="keyword">let</span> middlewareAPI = &#123;</span><br><span class="line">                getState: store.getState,</span><br><span class="line">                dispatch: <span class="function">(<span class="params">...args</span>) =&gt;</span> dispatch(...args)</span><br><span class="line">            &#125;</span><br><span class="line">            middlewares = middlewares.map(<span class="function"><span class="params">middleware</span> =&gt;</span> middleware(middlewareAPI));</span><br><span class="line">            <span class="comment">// store.dispatch传给logger的next参数，结果再传给thunk的next，结果再传给promise的next参数，最终返回pormise的dispatch方法</span></span><br><span class="line">            dispatch = compose(...middlewares)(store.dispatch);</span><br><span class="line">            <span class="keyword">return</span> &#123;</span><br><span class="line">                ...store,</span><br><span class="line">                dispatch</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="redux-persist"><a href="#redux-persist" class="headerlink" title="redux-persist"></a>redux-persist</h3><p>redux数据缓存在内存中，页面一刷新就初始化了，可以使用redux-persist持久化缓存数据</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">npm install redux-persist -D</span><br></pre></td></tr></table></figure>

<p>官网的用法 <a href="https://github.com/rt2zz/redux-persist" target="_blank" rel="noopener">https://github.com/rt2zz/redux-persist</a></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; persistStore, persistReducer &#125; <span class="keyword">from</span> <span class="string">'redux-persist'</span>;</span><br><span class="line"><span class="keyword">import</span> storage <span class="keyword">from</span> <span class="string">'redux-persist/lib/storage'</span>;</span><br><span class="line"><span class="keyword">const</span> persistConfig = &#123; <span class="comment">// 持久化，持久到哪里？到localStore ajax接口里 localStore.setItem('root:')</span></span><br><span class="line">    key: <span class="string">'root'</span>, <span class="comment">// 持久化的key</span></span><br><span class="line">    storage <span class="comment">// 存储的位置，默认值</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 持久化reducer</span></span><br><span class="line"><span class="keyword">const</span> persistedReducer = persistReducer(persistConfig, reducer);</span><br><span class="line"><span class="keyword">let</span> store = applyMiddleware(promise, thunk, logger)(createStore)(persistedReducer);</span><br><span class="line"><span class="comment">// 持久化store</span></span><br><span class="line"><span class="keyword">let</span> persistor = persistStore(store);</span><br><span class="line"><span class="keyword">export</span> &#123;</span><br><span class="line">    persistor,</span><br><span class="line">    store</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>页面中引入</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; PersistGate &#125; <span class="keyword">from</span> <span class="string">'redux-persist/integration/react'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> App = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;Provider store=&#123;store&#125;&gt;</span><br><span class="line">      &lt;PersistGate loading=&#123;<span class="literal">null</span>&#125; persistor=&#123;persistor&#125;&gt;</span><br><span class="line">        &lt;RootComponent /&gt;</span><br><span class="line">      &lt;<span class="regexp">/PersistGate&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>Provider&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="redux-saga"><a href="#redux-saga" class="headerlink" title="redux-saga"></a>redux-saga</h3><p><code>npm install redux react-redux redux-saga -D</code></p>
<p>在 redux-saga 的世界里，Sagas 都用 Generator 函数实现。我们从 Generator 里 yield 纯 JavaScript 对象以表达 Saga 逻辑。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createStore, applyMiddleware &#125; <span class="keyword">from</span> <span class="string">'redux'</span></span><br><span class="line"><span class="keyword">import</span> createSagaMiddleware <span class="keyword">from</span> <span class="string">'redux-saga'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> reducer <span class="keyword">from</span> <span class="string">'./reducers'</span></span><br><span class="line"><span class="keyword">import</span> mySaga <span class="keyword">from</span> <span class="string">'./sagas'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// create the saga middleware</span></span><br><span class="line"><span class="keyword">const</span> sagaMiddleware = createSagaMiddleware()</span><br><span class="line"><span class="comment">// mount it on the Store</span></span><br><span class="line"><span class="keyword">const</span> store = createStore(</span><br><span class="line">  reducer,</span><br><span class="line">  applyMiddleware(sagaMiddleware)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// then run the saga</span></span><br><span class="line">sagaMiddleware.run(mySaga)</span><br><span class="line"></span><br><span class="line"><span class="comment">// render the application</span></span><br></pre></td></tr></table></figure>

<p>派发动作都是同步的，要异步就使用saga</p>
<p>明天验证：yield call 不但可以调用一个返回promise的函数，还可以调用另一个saga<br>thunk比较</p>
<h4 id="fork"><a href="#fork" class="headerlink" title="fork"></a>fork</h4><p>表示开启了一个新的子进程去处理这个请求，<br>如果调用了fork则代码不会阻塞在此，而是会向下执行。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// let result = yield call(login, username, password); // 这个请求是阻塞的，只有请求login方法返回之后才能执行下面的代码</span></span><br><span class="line"><span class="keyword">const</span> task = <span class="keyword">yield</span> fork(login, username, password); <span class="comment">// 开辟的子进程，所以这里也不能直接拿到值了,逻辑可以放到login方法中写</span></span><br><span class="line"><span class="comment">// 这里task代表新的子任务本身，而非login方法返回值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 取消任务</span></span><br><span class="line"><span class="keyword">yield</span> cancel(task);</span><br></pre></td></tr></table></figure>

<p>[中文官网]<a href="https://redux-saga-in-chinese.js.org/" target="_blank" rel="noopener">https://redux-saga-in-chinese.js.org/</a><br><a href="http://www.zhufengpeixun.cn/2020/html/63.4.redux-saga.html" target="_blank" rel="noopener">http://www.zhufengpeixun.cn/2020/html/63.4.redux-saga.html</a></p>
<h2 id="参考文章："><a href="#参考文章：" class="headerlink" title="参考文章："></a>参考文章：</h2><p><a href="http://www.zhufengpeixun.cn/2020/html/63.1.redux.html" target="_blank" rel="noopener">http://www.zhufengpeixun.cn/2020/html/63.1.redux.html</a><br><a href="http://www.ruanyifeng.com/blog/2016/09/redux_tutorial_part_one_basic_usages.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2016/09/redux_tutorial_part_one_basic_usages.html</a><br><a href="http://www.ruanyifeng.com/blog/2016/09/redux_tutorial_part_two_async_operations.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2016/09/redux_tutorial_part_two_async_operations.html</a><br><a href="http://www.ruanyifeng.com/blog/2016/09/redux_tutorial_part_three_react-redux.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2016/09/redux_tutorial_part_three_react-redux.html</a></p>
]]></content>
      <categories>
        <category>Redux</category>
      </categories>
      <tags>
        <tag>Redux</tag>
      </tags>
  </entry>
  <entry>
    <title>前端面试题4天训练营</title>
    <url>/2020/02/28/Interview-base/</url>
    <content><![CDATA[<h2 id="第一天非常有必要和大家聊的三个话题"><a href="#第一天非常有必要和大家聊的三个话题" class="headerlink" title="第一天非常有必要和大家聊的三个话题"></a>第一天非常有必要和大家聊的三个话题</h2><h3 id="1-大前端时代需要掌握的技术栈"><a href="#1-大前端时代需要掌握的技术栈" class="headerlink" title="1. 大前端时代需要掌握的技术栈"></a>1. 大前端时代需要掌握的技术栈</h3><h4 id="HTML5"><a href="#HTML5" class="headerlink" title="HTML5"></a>HTML5</h4><blockquote>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/Guide/HTML/HTML5" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/Guide/HTML/HTML5</a></p>
</blockquote>
<ul>
<li>语义化标签类</li>
</ul>
<p><code>&lt;article&gt;&lt;/article&gt;、&lt;footer&gt;&lt;/footer&gt;、&lt;header&gt;&lt;/header&gt;</code></p>
<ul>
<li>音视频处理</li>
</ul>
<p>本次升级最大的亮点就是audio、video，新媒体解决方案代替了传统的flash。这可以说是html5最大的亮点。</p>
<ul>
<li><p>canvas / webGL</p>
</li>
<li><p>history API</p>
</li>
</ul>
<p>vue\react框架中做spa单页应用的话会用到路由，路由分为hash和browser，其中browser路由就是利用提供的histor API实现的</p>
<ul>
<li>requestAnimationFrame</li>
</ul>
<p><a href="https://segmentfault.com/a/1190000020639465?utm_source=tag-newest" target="_blank" rel="noopener">https://segmentfault.com/a/1190000020639465?utm_source=tag-newest</a></p>
<ul>
<li>地理位置</li>
</ul>
<p>getCurrentPosition() 方法来获得用户的位置</p>
<ul>
<li>web scoket</li>
</ul>
<p>………….</p>
<h4 id="CSS3"><a href="#CSS3" class="headerlink" title="CSS3"></a>CSS3</h4><ul>
<li><p>常规</p>
</li>
<li><p>动画</p>
</li>
<li><p>盒子模型</p>
</li>
<li><p>响应式布局</p>
</li>
</ul>
<p>………….</p>
<h4 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h4><ul>
<li>ECMAScript 3/5/6/7/8/9</li>
<li>DOM</li>
<li>BOM</li>
<li>设计模式</li>
<li>底层原理<ul>
<li>堆栈内存</li>
<li>闭包作用域 AO/VO/GO/EC/ECSTACK-</li>
<li>面向对象OOP</li>
<li>THI </li>
<li>EventLoop</li>
<li>浏览器渲染原理</li>
<li>回流重绘</li>
</ul>
</li>
</ul>
<p>………….</p>
<h4 id="网络通信层"><a href="#网络通信层" class="headerlink" title="网络通信层"></a>网络通信层</h4><ul>
<li>AJAX / Fetch / axios</li>
<li>HTTP1.0 / 2.0</li>
<li>TCP</li>
<li>跨域处理方案</li>
<li>性能优化</li>
</ul>
<h4 id="Hybrid或者APP再或者小程序"><a href="#Hybrid或者APP再或者小程序" class="headerlink" title="Hybrid或者APP再或者小程序"></a>Hybrid或者APP再或者小程序</h4><ul>
<li>Hybrid</li>
<li>uni-app</li>
<li>RN</li>
<li>Flutter</li>
<li>小程序 MPVUE</li>
<li>Weex</li>
<li>PWA</li>
</ul>
<p>…………..</p>
<h4 id="工程化方面"><a href="#工程化方面" class="headerlink" title="工程化方面"></a>工程化方面</h4><ul>
<li>webpack</li>
<li>git</li>
<li>linux / nginx</li>
</ul>
<p>…………..</p>
<h4 id="全栈方面"><a href="#全栈方面" class="headerlink" title="全栈方面"></a>全栈方面</h4><ul>
<li>node</li>
<li>express</li>
<li>koa2</li>
<li>mongodb</li>
<li>nuxt.js / next.js</li>
</ul>
<p>…………..</p>
<h4 id="框架方面"><a href="#框架方面" class="headerlink" title="框架方面"></a>框架方面</h4><ul>
<li>Vue<ul>
<li>基础知识</li>
<li>核心原理</li>
<li>vue-router</li>
<li>vue-cli</li>
<li>vuex</li>
<li>element ui</li>
<li>vant</li>
<li>cube</li>
<li>SSR</li>
<li>优化</li>
</ul>
</li>
</ul>
<ul>
<li>React<ul>
<li>基础知识</li>
<li>核心原理</li>
<li>react-router-dom</li>
<li>redux</li>
<li>react-redux</li>
<li>dva</li>
<li>umi</li>
<li>mobix</li>
<li>antd</li>
<li>antd pro</li>
<li>SSR</li>
<li>优化</li>
</ul>
</li>
</ul>
<h4 id="游戏方向"><a href="#游戏方向" class="headerlink" title="游戏方向"></a>游戏方向</h4><h4 id="可视化或者AI方向"><a href="#可视化或者AI方向" class="headerlink" title="可视化或者AI方向"></a>可视化或者AI方向</h4><p>……………</p>
<h3 id="3-BAT-TMD这种大公司到底是怎样面试的"><a href="#3-BAT-TMD这种大公司到底是怎样面试的" class="headerlink" title="3. BAT/TMD这种大公司到底是怎样面试的"></a>3. BAT/TMD这种大公司到底是怎样面试的</h3><p>一个问题就知道你会不会CSS了，(￣ε(#￣)☆╰╮(￣▽￣///)</p>
<ul>
<li>什么是标签语义化？</li>
</ul>
<p>用合理的标签干合适的事情</p>
<ul>
<li>都有哪些标签，都是啥意思？</li>
</ul>
<p>有块状标签、有行内标签、有行内块状标签，分部是 如下：</p>
<ul>
<li>块级标签和行内标签的区别？</li>
</ul>
<p>行内元素：相邻的行内元素在同一行，行内元素的宽度、高度、内边距的 top/bottom和外边距的top/bottom都是不可改变的，但 padding 和 margin 的 left 和 right 是可以设置的。常见的行内元素有：span、a、br、em、i… 块级元素：独占一行，他们的宽度、高度、内边距和外边距都可控制。常见的块级元素有：table、form、ul li、div、p、h1-6、article、header、footer….行内块元素（inline-block）：即融合了行内元素和块级元素的特性，即在一行显示，又能设置宽高。常见的行内块元素有：img、input、button…..</p>
<ul>
<li><p>如何转换</p>
</li>
<li><p>display除了这几个值还有哪些？</p>
</li>
</ul>
<p><code>display: table</code> <code>display: flex</code> </p>
<ul>
<li>display:none<ul>
<li>让元素隐藏，你可以怎么做</li>
<li>display:none和visibility:hidden的区别?</li>
<li>opacity的兼容处理？ (用 filter)</li>
<li>filter(滤镜)还能做哪些事情？ （修改所有图片的颜色为黑白: filter: grayscale(100%);）</li>
</ul>
</li>
<li>display:flex<ul>
<li>项目中你什么时候用到了flex</li>
<li>除了这种方式能居中还有哪些？</li>
<li>响应式布局还可以怎么做？</li>
<li>都有哪些盒子模型</li>
</ul>
</li>
</ul>
<p>o(╥﹏╥)o</p>
<p>好了，咱们换下一个题….</p>
<hr>

<p><strong>说一下，你自己感觉自己擅长哪些？</strong> </p>
<p>(#^.^#)  没事的，在我们眼里，你擅长的点我比你更擅长，如果不是，没关系，后面还有P7/P8们兜着呢！^_^</p><p></p>
<hr>

<p><strong>说一下，这个需求怎么做？</strong> <br>
还有吗 (￣▽￣)／ <br>
还有吗 (￣▽￣)／ <br>
…… <br>
那说一下，你感觉这几种方式哪个更好，各自有啥问题……</p>

<hr>

<p>总之一句话，不把你问“死”，算我这次面试失败！！！</p>

<p><strong>“ 在面试介绍的时候要突出自己精心准备的面试题：在哪些公司呆过，自己擅长哪些技术栈，平时有什么爱好，比较擅长原生js，比较擅长promise设计模式 ”</strong></p>
<h2 id="几道前端经典的面试题"><a href="#几道前端经典的面试题" class="headerlink" title="几道前端经典的面试题"></a>几道前端经典的面试题</h2><h3 id="1-掌握盒子水平垂直居中的五大方案"><a href="#1-掌握盒子水平垂直居中的五大方案" class="headerlink" title="1.掌握盒子水平垂直居中的五大方案"></a>1.掌握盒子水平垂直居中的五大方案</h3><ul>
<li>定位： 三种</li>
</ul>
<p>第一种：需要知道具体宽高，才能用margin left top设置值</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">50px</span>; </span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">margin-top</span>: -<span class="number">25px</span>;</span><br><span class="line">  <span class="attribute">margin-left</span>: -<span class="number">50px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第二种：有宽高，不需要考虑具体是多少</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">50px</span>; </span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">right</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">bottom</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">margin</span>: auto;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第三种：可以不设置宽高</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">translate</span>(-50%, -50%);</span><br><span class="line">  <span class="attribute">-webkit-transform</span>: <span class="built_in">translate</span>(-50%, -50%);</span><br><span class="line">  <span class="attribute">-moz-transform</span>: <span class="built_in">translate</span>(-50%, -50%);</span><br><span class="line">  <span class="attribute">-ms-transform</span>: <span class="built_in">translate</span>(-50%, -50%);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>display: flex</li>
</ul>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 父标签 */</span></span><br><span class="line"><span class="selector-tag">body</span>&#123;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">  <span class="attribute">justify-content</span>: center;</span><br><span class="line">  <span class="attribute">align-items</span>: center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>javascript</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> HTML = <span class="built_in">document</span>.documentElement,</span><br><span class="line">    winW = HTML.clientWidth,</span><br><span class="line">    winH = HTML.clientHeight,</span><br><span class="line">    boxW = box.offsetWidth,</span><br><span class="line">    boxH = box.offsetHeight;</span><br><span class="line">  box.style.position = <span class="string">"absolute"</span>;</span><br><span class="line">  box.style.left = (winW - boxW) / <span class="number">2</span> + <span class="string">'px'</span>;</span><br><span class="line">  box.style.top = (winH - boxH) / <span class="number">2</span> + <span class="string">'px'</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>display: table-cell</li>
</ul>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: table-cell; <span class="comment">/* */</span></span><br><span class="line">  <span class="attribute">vertical-align</span>: middle;</span><br><span class="line">  <span class="attribute">text-align</span>: center;</span><br><span class="line">  <span class="comment">/* 父级需要固定宽高 百分比不算固定宽高*/</span></span><br><span class="line">  <span class="attribute">width</span>: <span class="number">500px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">500px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: inline-block;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-关于CSS3中盒模型的几道面试题"><a href="#2-关于CSS3中盒模型的几道面试题" class="headerlink" title="2.关于CSS3中盒模型的几道面试题"></a>2.关于CSS3中盒模型的几道面试题</h3><ul>
<li>标准盒子模型</li>
</ul>
<p><img src="https://jiafei2333.github.io/html/images/css-box-sizing.png" alt></p>
<ul>
<li>IE盒子模型（怪异盒子模型）</li>
</ul>
<p>border</p>
<ul>
<li>FLEX盒模型</li>
</ul>
<p><img src="https://jiafei2333.github.io/html/images/css-flex.png" alt></p>
<h3 id="3-掌握几大经典布局方案"><a href="#3-掌握几大经典布局方案" class="headerlink" title="3.掌握几大经典布局方案"></a>3.掌握几大经典布局方案</h3><ul>
<li>圣杯布局</li>
<li>双飞翼布局</li>
</ul>
<p>即 左右固定，中间自适应<br>这里看有道上面的例子</p>
<h3 id="4-移动端响应式布局开发的三大方案"><a href="#4-移动端响应式布局开发的三大方案" class="headerlink" title="4.移动端响应式布局开发的三大方案"></a>4.移动端响应式布局开发的三大方案</h3><ul>
<li>media（pc端 + 移动端 用同一套代码时）</li>
<li>rem  （pc端用px ，移动端用rem）</li>
<li>flex</li>
<li>vh / vw （相当于百分比，称为百分比布局，vh把视窗高度分为100分，1vh就是1%，vw同理）</li>
</ul>
<h3 id="课后作业"><a href="#课后作业" class="headerlink" title="课后作业"></a>课后作业</h3><ol>
<li>使用css，让一个div消失在视野中，发挥想象力 ？<br>（display:none; visibility:hidden;它们的区别。透明度opacity又涉及到哪些内容。-margin也可以，-margin涉及到双飞翼出来了）</li>
<li>请说明z-index的工作原理，适用范围？</li>
</ol>
<ul>
<li>文档流</li>
<li>定位</li>
</ul>
<p>（这个问题主要问的就是文档流，z-index的原理就是建立不同的文档流，建立文档流不同层级，脱离文档流有几种方式？float、定位、transform、animate css3的transfrom动画为什么好，帧性能的优化点，js动画是要随时改变样式的，会引发很多次回流，css3是会回到最后一帧，只引发一次回流）<br>3. 谈谈你对HTML5的理解？</p>
<ol start="4">
<li><p>如何使一个div里面的文字垂直居中，且该文字的大小根据屏幕大小自适应？</p>
</li>
<li><p>不考虑其它因素，下面哪种的渲染性能比较高？</p>
</li>
</ol>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.box</span> <span class="selector-tag">a</span>&#123;</span><br><span class="line">....</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">a</span>&#123;</span><br><span class="line">....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>css浏览器渲染机制，选择器从右向左查询，第二种只找所有的a，第一种先找所有a，再找box下所有a，渲染了2次，二次筛选。</p>
<h2 id="第二天面试题"><a href="#第二天面试题" class="headerlink" title="第二天面试题"></a>第二天面试题</h2><ol>
<li>对象(数组)的深克隆和浅克隆（头条）</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    a: <span class="number">100</span>,</span><br><span class="line">    b: [<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>],</span><br><span class="line">    c: &#123;</span><br><span class="line">        x: <span class="number">10</span></span><br><span class="line">    &#125;,</span><br><span class="line">    d: <span class="regexp">/^\d+$/</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// let obj2 = JSON.parse(JSON.stringify(obj)); =&gt; 弊端  正则、函数、new Date() 这些类型的值都转化成了字符串，这种深克隆的处理，大部分是没有问题的。如下：</span></span><br><span class="line"><span class="built_in">JSON</span>.stringify(&#123;<span class="attr">a</span>:<span class="regexp">/^\d+$/</span>&#125;)</span><br><span class="line"><span class="comment">//"&#123;"a":&#123;&#125;&#125;"</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">JSON</span>.stringify(&#123;<span class="attr">a</span>:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;, <span class="attr">b</span>:<span class="string">'xxx'</span>&#125;)</span><br><span class="line"><span class="comment">// "&#123;"b":"xxx"&#125;"</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">JSON</span>.stringify(&#123;<span class="attr">a</span>:<span class="keyword">new</span> <span class="built_in">Date</span>()&#125;)</span><br><span class="line"><span class="comment">// "&#123;"a":"2020-02-27T13:04:50.963Z"&#125;"</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">JSON</span>.stringify(obj)</span><br><span class="line"><span class="comment">// "&#123;"a":100,"b":[10,20,30],"c":&#123;"x":10&#125;,"d":&#123;&#125;&#125;"</span></span><br><span class="line"><span class="comment">//这里就是把所有的数据都变成字符串，把所有的值重新开辟新的空间，跟原来没有关系。</span></span><br></pre></td></tr></table></figure>

<p>深克隆</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//=&gt;深克隆</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">deepClone</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> obj !== <span class="string">"object"</span>) <span class="keyword">return</span> obj;</span><br><span class="line">    <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> <span class="built_in">RegExp</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">RegExp</span>(obj);</span><br><span class="line">    <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> <span class="built_in">Date</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Date</span>(obj);</span><br><span class="line">    <span class="keyword">let</span> cloneObj = <span class="keyword">new</span> obj.constructor;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> obj) &#123;</span><br><span class="line">        <span class="keyword">if</span> (obj.hasOwnProperty(key)) &#123;</span><br><span class="line">            cloneObj[key] = deepClone(obj[key]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cloneObj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>BAT笔试题中几道关于堆栈内存和闭包作用域的题</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a=&#123;&#125;, b=<span class="string">'0'</span>, c=<span class="number">0</span>;  </span><br><span class="line">a[b]=<span class="string">'珠峰'</span>;</span><br><span class="line">a[c]=<span class="string">'培训'</span>;  </span><br><span class="line"><span class="built_in">console</span>.log(a[b]);</span><br><span class="line"><span class="comment">// 对象中属性名不能重复，数字属性名=对象属性名</span></span><br><span class="line"><span class="comment">//衍生=&gt; 对象和数组的区别</span></span><br><span class="line">---------------------</span><br><span class="line"><span class="comment">//example 2</span></span><br><span class="line"><span class="keyword">let</span> a=&#123;&#125;, b=<span class="built_in">Symbol</span>(<span class="string">'1'</span>), c=<span class="built_in">Symbol</span>(<span class="string">'1'</span>);  </span><br><span class="line">a[b]=<span class="string">'珠峰'</span>;</span><br><span class="line">a[c]=<span class="string">'培训'</span>;  </span><br><span class="line"><span class="built_in">console</span>.log(a[b]);</span><br><span class="line"><span class="comment">// 衍生 =&gt; 自己实现一个Symbol</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">---------------------</span><br><span class="line"><span class="comment">//example 3</span></span><br><span class="line"><span class="keyword">let</span> a=&#123;&#125;, b=&#123;<span class="attr">n</span>:<span class="string">'1'</span>&#125;, c=&#123;<span class="attr">m</span>:<span class="string">'2'</span>&#125;;  </span><br><span class="line">a[b]=<span class="string">'珠峰'</span>;</span><br><span class="line">a[c]=<span class="string">'培训'</span>;  </span><br><span class="line"><span class="built_in">console</span>.log(a[b]);</span><br><span class="line"><span class="comment">//衍生=&gt; Object.prototype.toString项目中的应用 和 valueOf的区别</span></span><br></pre></td></tr></table></figure>

<p>如图：<br>obj里面存{name:’xxx’}转化为”[object Object]”这个字符串，通过toString()转化，可以知道，所有对象，不管存的是什么，toString()之后的结果都是字符串”[object Object]”<br>堆内存：存储引用类型值的空间；<br>栈内存：存储基本类型值和执行代码的环境。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> test = (<span class="function"><span class="keyword">function</span>(<span class="params">i</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        alert(i*=<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)(<span class="number">2</span>);</span><br><span class="line">test(<span class="number">5</span>);</span><br></pre></td></tr></table></figure>

<p>答案：’4’ alert弹出来的都要转化为字符串<br>如图：<br><img src="https://jiafei2333.github.io/html/images/js-base02.jpg" alt><br>这里test等于的是一个立即执行函数，所以函数执行，返回一个函数，返回给test的是一个引用地址（十六进制）<br>在右侧堆中，对象存储是键值对，函数存储的是要执行的代码（以字符串格式），作为对象还存除了prototype length等<br>闭包不叫内存泄露，只叫保存不销毁</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a=<span class="number">0</span>, b=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">A</span>(<span class="params">a</span>)</span>&#123;</span><br><span class="line">    A=<span class="function"><span class="keyword">function</span>(<span class="params">b</span>)</span>&#123;</span><br><span class="line">        alert(a+b++);</span><br><span class="line">    &#125;;</span><br><span class="line">    alert(a++);</span><br><span class="line">&#125;</span><br><span class="line">A(<span class="number">1</span>);</span><br><span class="line">A(<span class="number">2</span>);</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> i = <span class="number">10</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">5</span>+i++);</span><br><span class="line"><span class="comment">// 15   i 11</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> i = <span class="number">10</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">5</span>+(++i));</span><br><span class="line"><span class="comment">// 16   i 11</span></span><br></pre></td></tr></table></figure>

<p>如图:</p>
<p>‘1’   ‘4’<br><img src="https://jiafei2333.github.io/html/images/js-base03.png" alt></p>
<p>3.一道关于面向对象面试题所引发的血案（阿里）<br><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Operator_Precedence" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Operator_Precedence</a></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    getName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line">Foo.getName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line">&#125;;</span><br><span class="line">Foo.prototype.getName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">3</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> getName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">4</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getName</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">5</span>);</span><br><span class="line">&#125;</span><br><span class="line">Foo.getName();</span><br><span class="line">getName();</span><br><span class="line">Foo().getName();</span><br><span class="line">getName();</span><br><span class="line"><span class="keyword">new</span> Foo.getName();</span><br><span class="line"><span class="keyword">new</span> Foo().getName();</span><br><span class="line"><span class="keyword">new</span> <span class="keyword">new</span> Foo().getName();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2411233</span></span><br></pre></td></tr></table></figure>

<p>变量提升：在当前这个执行上下文中，所有代码执行之前，把所有带var 的提前声明，带function 提前声明+定义(赋值)。</p>
<p>4.一道面试题让你彻底掌握JS中的EventLoop（头条）</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'async1 start'</span>);</span><br><span class="line">    <span class="keyword">await</span> async2();</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'async1 end'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'async2'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'script start'</span>);</span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'setTimeout'</span>);</span><br><span class="line">&#125;, <span class="number">0</span>)</span><br><span class="line">async1();</span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'promise1'</span>);</span><br><span class="line">    resolve();</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'promise2'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'script end'</span>);</span><br></pre></td></tr></table></figure>

<h2 id="课后作业-1"><a href="#课后作业-1" class="headerlink" title="课后作业"></a>课后作业</h2><p>第一题：写出下面代码输出的结果</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">A</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    alert(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Func</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    A=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">       alert(<span class="number">2</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line">Func.A=A;</span><br><span class="line">Func.prototype=&#123;</span><br><span class="line">    A:<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">       alert(<span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">A();</span><br><span class="line">Fn.A();</span><br><span class="line">Fn().A();</span><br><span class="line"><span class="keyword">new</span> Fn.A();</span><br><span class="line"><span class="keyword">new</span> Fn().A();</span><br><span class="line"><span class="keyword">new</span> <span class="keyword">new</span> Fn().A();</span><br></pre></td></tr></table></figure>

<p>第二题：写出下面代码输出的结果</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> x=<span class="number">2</span>;</span><br><span class="line"><span class="keyword">var</span> y=&#123;</span><br><span class="line">    x:<span class="number">3</span>,</span><br><span class="line">    z:(<span class="function"><span class="keyword">function</span>(<span class="params">x</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.x*=x;</span><br><span class="line">        x+=<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">n</span>)</span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.x*=n;</span><br><span class="line">            x+=<span class="number">3</span>;</span><br><span class="line">            <span class="built_in">console</span>.log(x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)(x)</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> m=y.z;</span><br><span class="line">m(<span class="number">4</span>);</span><br><span class="line">y.z(<span class="number">5</span>);</span><br><span class="line"><span class="built_in">console</span>.log(x, y.x);</span><br></pre></td></tr></table></figure>

<p>第三题：写出下面代码输出的结果</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = ?;</span><br><span class="line"><span class="keyword">if</span> (a == <span class="number">1</span> &amp;&amp; a == <span class="number">2</span> &amp;&amp; a == <span class="number">3</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第四题：写出下面代码输出的结果</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> x=<span class="number">0</span>,</span><br><span class="line">    y=<span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    x+=<span class="number">2</span>;</span><br><span class="line">    fn=<span class="function"><span class="keyword">function</span>(<span class="params">y</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(y + (--x));</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">console</span>.log(x, y);</span><br><span class="line">&#125;</span><br><span class="line">fn(<span class="number">3</span>);</span><br><span class="line">fn(<span class="number">4</span>);</span><br><span class="line"><span class="built_in">console</span>.log(x, y);</span><br></pre></td></tr></table></figure>

<p>第五题：写出下面代码输出的结果</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">&#125;, <span class="number">20</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">3</span>);</span><br><span class="line">&#125;, <span class="number">10</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">4</span>);</span><br><span class="line"><span class="built_in">console</span>.time(<span class="string">'AA'</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">90000000</span>; i++) &#123;</span><br><span class="line">    <span class="comment">// do soming</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.timeEnd(<span class="string">'AA'</span>); <span class="comment">//=&gt;AA: 79ms 左右</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">5</span>);</span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">6</span>);</span><br><span class="line">&#125;, <span class="number">8</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">7</span>);</span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">8</span>);</span><br><span class="line">&#125;, <span class="number">15</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">9</span>);</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>面试题</category>
      </categories>
      <tags>
        <tag>面试题</tag>
      </tags>
  </entry>
  <entry>
    <title>Single-Spa</title>
    <url>/2020/01/09/Single-Spa/</url>
    <content><![CDATA[<p>入手demo：<a href="https://www.jdon.com/52552" target="_blank" rel="noopener">https://www.jdon.com/52552</a></p>
]]></content>
  </entry>
  <entry>
    <title>H5-问题集锦</title>
    <url>/2019/12/23/H5-Question/</url>
    <content><![CDATA[<h2 id="1-【安卓手机】文本框获取焦点时导致fixed或absolute定位的按钮被手机键盘顶上去"><a href="#1-【安卓手机】文本框获取焦点时导致fixed或absolute定位的按钮被手机键盘顶上去" class="headerlink" title="1.【安卓手机】文本框获取焦点时导致fixed或absolute定位的按钮被手机键盘顶上去"></a>1.【安卓手机】文本框获取焦点时导致fixed或absolute定位的按钮被手机键盘顶上去</h2><p>如下：</p>
<p><img src="https://jiafei2333.github.io/html/images/h5-error1.jpg" alt></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//navigator.userAgent.indexOf用来判断浏览器类型</span></span><br><span class="line"><span class="keyword">var</span> isAndroid = navigator.userAgent.indexOf(<span class="string">'Android'</span>) &gt; <span class="number">-1</span> || navigator.userAgent.indexOf(<span class="string">'Adr'</span>) &gt; <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">if</span> (isAndroid)&#123;<span class="comment">//如果是安卓手机的浏览器</span></span><br><span class="line">    <span class="keyword">var</span> win_h = $(<span class="built_in">window</span>).height();<span class="comment">//关键代码</span></span><br><span class="line">    $(<span class="string">"body"</span>).height(win_h);<span class="comment">//关键代码</span></span><br><span class="line">    <span class="built_in">window</span>.addEventListener(<span class="string">'resize'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">// Document 对象的activeElement 属性返回文档中当前获得焦点的元素。</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">document</span>.activeElement.tagName === <span class="string">'INPUT'</span> || <span class="built_in">document</span>.activeElement.tagName === <span class="string">'TEXTAREA'</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>($(<span class="string">'.footer'</span>).is(<span class="string">':visible'</span>))&#123;</span><br><span class="line">            $(<span class="string">'.footer'</span>).hide();</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            $(<span class="string">'.footer'</span>).show();</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>页面中加入如上判断条件，可以防止定位元素上移</p>
<h3 id="新问题：定位元素不上移了，但键盘上方同一位置会出现白色的占位区块"><a href="#新问题：定位元素不上移了，但键盘上方同一位置会出现白色的占位区块" class="headerlink" title="新问题：定位元素不上移了，但键盘上方同一位置会出现白色的占位区块"></a>新问题：定位元素不上移了，但键盘上方同一位置会出现白色的占位区块</h3><figure class="highlight cs"><table><tr><td class="code"><pre><span class="line">position: <span class="keyword">static</span>;  <span class="comment">// 将 fixed 换成 static 即可</span></span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>工作中的BUG</tag>
      </tags>
  </entry>
  <entry>
    <title>微前端</title>
    <url>/2019/12/18/Micro-front-end/</url>
    <content><![CDATA[<blockquote>
<p>微前端就是后端微服务思想在前端的映射。<br>核心： 拆、合。 先拆后合。</p>
</blockquote>
<ul>
<li>微前端如何在浏览器中落地？</li>
<li>single-spa</li>
</ul>
<p><a href="https://github.com/YataoZhang/my-single-spa/issues/4" target="_blank" rel="noopener">https://github.com/YataoZhang/my-single-spa/issues/4</a></p>
<p>这里的 11个状态流程图是微前端内部的状态，理解就行，single-spa 内部也是这个状态。</p>
<p>卸载操作</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// vue</span></span><br><span class="line">vueInstance.$destory();</span><br><span class="line"></span><br><span class="line"><span class="comment">// react</span></span><br><span class="line"><span class="keyword">let</span> el = ReactDOM.findNode(reactInstance);</span><br><span class="line">ReactDOM.unmountComponentAtNode(el);</span><br></pre></td></tr></table></figure>

<p>搜索：【 qiankun 微前端 】<br>文章： <a href="https://juejin.im/post/5d8ed64b51882516622936ff" target="_blank" rel="noopener">https://juejin.im/post/5d8ed64b51882516622936ff</a></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> &#123;...a, ...b&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="built_in">Object</span>.assign(&#123;&#125;, a, b);</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>微前端</category>
      </categories>
  </entry>
  <entry>
    <title>React</title>
    <url>/2019/12/11/React/</url>
    <content><![CDATA[<h2 id="React"><a href="#React" class="headerlink" title="React"></a>React</h2><p>文档 <a href="http://www.zhufengpeixun.cn/2020/html/62.1.react-basic.html" target="_blank" rel="noopener">http://www.zhufengpeixun.cn/2020/html/62.1.react-basic.html</a></p>
<blockquote>
<p>React当中的元素就是普通的js对象，它描述了界面上元素的样子，react-dom会在render的时候根据对象的描述生成真实的dom结构。<br>react元素是构成react应用的最小单位。<br>react中的元素也就是虚拟dom。</p>
</blockquote>
<p>react 源码 github.com =&gt; 搜索react =&gt; packages =&gt; react =&gt; src =&gt; ReactElement.js</p>
<p>react forceUpdate  |  react flush</p>
<p>e.preventDefault(); // 阻止默认表单提交事件</p>
<h2 id="jsx"><a href="#jsx" class="headerlink" title="jsx"></a>jsx</h2><p>JavaScript+xml 是一种把js和html混合书写的一种语法。<br>JSX其实只是一种语法糖,最终会通过babeljs转译成createElement语法,以下代码等价。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">ReactDOM.render(</span><br><span class="line">  &lt;h1&gt;Hello&lt;<span class="regexp">/h1&gt;,</span></span><br><span class="line"><span class="regexp">  document.getElementById('root')</span></span><br><span class="line"><span class="regexp">);</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">React.createElement("h1", &#123;</span></span><br><span class="line"><span class="regexp">  className: "title",</span></span><br><span class="line"><span class="regexp">  style: &#123;</span></span><br><span class="line"><span class="regexp">    color: 'red'</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;, "hello");</span></span><br></pre></td></tr></table></figure>

<h2 id="this"><a href="#this" class="headerlink" title="this"></a>this</h2><p>事件的处理 关于this的处理<br>一般来说我们希望在回调函数里让this=当前组件</p>
<ul>
<li>1、使用箭头函数 this就会永远指向类的实例</li>
<li>2、如果用的是普通函数，this = undefined<ul>
<li>2.1 可以使用bind</li>
<li>2.2 可以使用匿名函数 ()=&gt;funName()</li>
</ul>
</li>
</ul>
<h3 id="解决this指针的三种方法"><a href="#解决this指针的三种方法" class="headerlink" title="解决this指针的三种方法"></a>解决this指针的三种方法</h3><ul>
<li>this.add.bind(this); 把add方法里面的this指针绑定为组件实例</li>
<li>使用匿名函数 ()=&gt;this.add(); </li>
<li><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 给类的实例增加一个add的属性，而这个属性的this绑死为组件的实例</span></span><br><span class="line">add = <span class="function"><span class="params">()</span> =&gt;</span> &#123;...&#125;</span><br><span class="line">...</span><br><span class="line">onClick=&#123;<span class="keyword">this</span>.add&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="ref"><a href="#ref" class="headerlink" title="ref"></a>ref</h2><p>ref的用法 + 受控组件、非受控组件</p>
<blockquote>
<p>reference = 引用 如果我们希望在代码中获取到React元素渲染到页面上的真实DOM的话</p>
</blockquote>
<p>ref用法</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">this</span>.a = React.createRef(); <span class="comment">// &#123;current: null&#125;</span></span><br><span class="line"></span><br><span class="line">&lt;input ref=&#123;<span class="keyword">this</span>.a&#125; /&gt;</span><br></pre></td></tr></table></figure>

<h2 id="受控和非受控"><a href="#受控和非受控" class="headerlink" title="受控和非受控"></a>受控和非受控</h2><p>非受控组件：指DOM元素的值存在于DOM元素内部，这个值跟react是相互独立的，不受react控制，这被称为非受控组件。<br>受控：设置 value={this….} onChange来改变value的值</p>
<h2 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h2><h3 id="旧"><a href="#旧" class="headerlink" title="旧"></a>旧</h3><p>父组件包裹子组件 父组件 <code>Counter</code>  子组件 <code>SubCounter</code><br>当父组件改变数据时，触发时 父子组件生命周期顺序如下：</p>
<p><code>Counter</code> shouldComponentUpdate<br><code>Counter</code> componentWillUpdate<br><code>Counter</code> render<br><code>SubCounter</code> componentWillReceiveProps<br><code>SubCounter</code> shouldComponentUpdate<br><code>SubCounter</code> componentWillUpdate<br><code>SubCounter</code> render<br><code>SubCounter</code> componentDidUpdate<br><code>Counter</code> componentDidUpdate</p>
<h3 id="新"><a href="#新" class="headerlink" title="新"></a>新</h3><p>如图 props、state、forceUpdate 改变时都会触发</p>
<p><img src="http://img.zhufengpeixun.cn/react16.jpg" alt></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 从属性对象中获取派发的状态，但返回的对象将会成为新的状态对象，如果不改变状态，则可以返回null</span></span><br><span class="line"><span class="keyword">static</span> getDerivedStateFromProps(nextProps,prevState))&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>getDerivedStateFromProps 的存在只有一个目的：让组件在props变化时更新state。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在更新前获取DOM的快照</span></span><br><span class="line">getSnapshotBeforeUpdate()&#123;</span><br><span class="line">    <span class="keyword">return</span> ......xxxxx; <span class="comment">// 此返回值会传给componentDidUpdate最后一个参数</span></span><br><span class="line">&#125;</span><br><span class="line">componentDidUpdate(prevProps,prevState,prevXXXX)&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>相关文章：<br><a href="https://juejin.im/post/5b6f1800f265da282d45a79a" target="_blank" rel="noopener">https://juejin.im/post/5b6f1800f265da282d45a79a</a><br><a href="https://juejin.im/post/5aca20c96fb9a028d700e1ce" target="_blank" rel="noopener">https://juejin.im/post/5aca20c96fb9a028d700e1ce</a><br><a href="https://zh-hans.reactjs.org/blog/2018/06/07/you-probably-dont-need-derived-state.html" target="_blank" rel="noopener">https://zh-hans.reactjs.org/blog/2018/06/07/you-probably-dont-need-derived-state.html</a></p>
<h2 id="状态"><a href="#状态" class="headerlink" title="状态"></a>状态</h2><h3 id="状态提升"><a href="#状态提升" class="headerlink" title="状态提升"></a>状态提升</h3><p>多个组件需要共享同一个状态的话，就需要把他们的状态提升到他们共同的父组件中。</p>
<h3 id="setState"><a href="#setState" class="headerlink" title="setState"></a>setState</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">this</span>.setState(&#123;&#125;);</span><br></pre></td></tr></table></figure>

<p>修改状态；重新render</p>
<h3 id="setState-可能是异步的"><a href="#setState-可能是异步的" class="headerlink" title="setState 可能是异步的"></a>setState 可能是异步的</h3><p>出于性能方面的考虑，React 可以将多次的 setState() 调用合并为一次 </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">constructor</span>()&#123;</span><br><span class="line">    <span class="keyword">this</span>.state = &#123;<span class="attr">number</span>:<span class="number">0</span>&#125;   </span><br><span class="line">&#125;</span><br><span class="line">add = <span class="function"><span class="params">()</span> =&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123;<span class="attr">number</span>:<span class="keyword">this</span>.state.number+<span class="number">1</span>&#125;);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.state.number); <span class="comment">// 0</span></span><br><span class="line">    <span class="keyword">this</span>.setState(&#123;<span class="attr">number</span>:<span class="keyword">this</span>.state.number+<span class="number">1</span>&#125;);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.state.number); <span class="comment">// 0</span></span><br><span class="line">    setTimeout( <span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.setState(&#123;<span class="attr">number</span>:<span class="keyword">this</span>.state.number+<span class="number">1</span>&#125;);</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.state.number); <span class="comment">// 2</span></span><br><span class="line">        <span class="keyword">this</span>.setState(&#123;<span class="attr">number</span>:<span class="keyword">this</span>.state.number+<span class="number">1</span>&#125;);</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.state.number); <span class="comment">// 3</span></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 页面上显示 3</span></span><br></pre></td></tr></table></figure>

<p>源码<br><img src="http://img.zhufengpeixun.cn/setState.png" alt></p>
<p><code>dirtyComponents</code> 脏组件，就是组件的状态和界面显示不一致</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 源码</span></span><br><span class="line"><span class="keyword">if</span>( !batchingStrategy.isBatchingUpdates)&#123; <span class="comment">// 为 false 则不批量更新，立即处理</span></span><br><span class="line">    batchingStrategy.batchUpdates(enqueusUpdate, component);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 否则 批量更新，存储到dirtyComponent中</span></span><br><span class="line">dirtyComponent.push(component);</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.trigger = <span class="function"><span class="keyword">function</span>(<span class="params">event,method</span>)</span>&#123;</span><br><span class="line">    event.target.component[method].call(event.target.component); <span class="comment">// 不是源码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实现原理和react一样，在react中会把所有的事件都委托给全局统一实现，通过事件源去区分，去调用对应的方法。<br>通过事件委托来实现的。</p>
<p>在react中，当你要开启一个事件的时候，当你要执行一个回调函数的时候，它会进入到批量更新状态。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.trigger = <span class="function"><span class="keyword">function</span>(<span class="params">event,name</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 当事件函数(即这里的add方法)执行的时候，先置为true，开启批量更新模式</span></span><br><span class="line">    batchingStrategy.isBatchingUpdates = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">let</span> component = event.target.component;</span><br><span class="line">    component[name].bind(component,event);</span><br><span class="line">    <span class="comment">// 当事件结束的时候（这里指 add执行结束，且此时还未执行setTimeou异步方法，所以前2个皆为 0 0 ） 置为false</span></span><br><span class="line">    batchingStrategy.isBatchingUpdates = <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// 进行批量更新，把所有的脏组件根据自己的状态和属性重新渲染</span></span><br><span class="line">    batchingStrategy.batchedUpdates();</span><br><span class="line">&#125;</span><br><span class="line">add = <span class="function"><span class="params">()</span> =&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123;<span class="attr">number</span>:<span class="keyword">this</span>.state.number+<span class="number">1</span>&#125;);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.state.number); <span class="comment">// 0</span></span><br><span class="line">    <span class="keyword">this</span>.setState(&#123;<span class="attr">number</span>:<span class="keyword">this</span>.state.number+<span class="number">1</span>&#125;);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.state.number); <span class="comment">// 0</span></span><br><span class="line">    <span class="comment">// setTimeout里面的代码比较特殊，不会走批量更新，会立刻进行更新</span></span><br><span class="line">    setTimeout( <span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.setState(&#123;<span class="attr">number</span>:<span class="keyword">this</span>.state.number+<span class="number">1</span>&#125;);</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.state.number); <span class="comment">// 2</span></span><br><span class="line">        <span class="keyword">this</span>.setState(&#123;<span class="attr">number</span>:<span class="keyword">this</span>.state.number+<span class="number">1</span>&#125;);</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.state.number); <span class="comment">// 3</span></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面line12 - line15 ，将多次传入的对象进行合并处理，以产生一个新的最终的 state 对象，这种合并类似于：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> newState = <span class="built_in">Object</span>.assign(</span><br><span class="line">  &#123;&#125;, </span><br><span class="line">  state0, </span><br><span class="line">  state1, </span><br><span class="line">  state2</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>然后再将得到的 “newState” 通过调用 setState 方法进行更新，所以，如果多次调用 setState 方法时传入的对象有相同的 key，那么最后一次调用时所传入的对象的那个 key 的值将成为最终的更新值，在最后一次调用前的值都将被覆盖。</p>
<p>优化window.trigger中的方法 <code>事务</code></p>
<ul>
<li>一个所谓的 Transaction 就是将需要执行的 method 使用 wrapper 封装起来，再通过 Transaction 提供的 perform 方法执行</li>
<li>而在 perform 之前，先执行所有 wrapper 中的 initialize 方法；perform 完成之后（即 method 执行后）再执行所有的 close 方法一组 initialize 及 close 方法称为一个 wrapper<pre> *                       wrappers (injected at creation time)
*                                      +        +
*                                      |        |
*                    +-----------------|--------|--------------+
*                    |                 v        |              |
*                    |      +---------------+   |              |
*                    |   +--|    wrapper1   |---|----+         |
*                    |   |  +---------------+   v    |         |
*                    |   |          +-------------+  |         |
*                    |   |     +----|   wrapper2  |--------+   |
*                    |   |     |    +-------------+  |     |   |
*                    |   |     |                     |     |   |
*                    |   v     v                     v     v   | wrapper
*                    | +---+ +---+   +---------+   +---+ +---+ | invariants
* perform(anyMethod) | |   | |   |   |         |   |   | |   | | maintained
* +-----------------&gt;|-|---|-|---|--&gt;|anyMethod|---|---|-|---|-|--------&gt;
*                    | |   | |   |   |         |   |   | |   | |
*                    | |   | |   |   |         |   |   | |   | |
*                    | |   | |   |   |         |   |   | |   | |
*                    | +---+ +---+   +---------+   +---+ +---+ |
*                    |  initialize                    close    |
*                    +-----------------------------------------+
* 
</pre>

</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Transaction</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(wrapper)&#123;</span><br><span class="line">        <span class="keyword">this</span>.wrapper = wrapper;</span><br><span class="line">    &#125;</span><br><span class="line">    perform(func)&#123;</span><br><span class="line">        <span class="keyword">this</span>.wrapper.initialize();</span><br><span class="line">        func.call();</span><br><span class="line">        <span class="keyword">this</span>.wrapper.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> transaction = <span class="keyword">new</span> Transaction(&#123;</span><br><span class="line">    initialize() &#123;</span><br><span class="line">        batchingStrategy.isBatchingUpdates = <span class="literal">true</span>;</span><br><span class="line">    &#125;,</span><br><span class="line">    close() &#123;</span><br><span class="line">        batchingStrategy.isBatchingUpdates = <span class="literal">false</span>;</span><br><span class="line">        batchingStrategy.batchedUpdates();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">window</span>.trigger = <span class="function"><span class="keyword">function</span>(<span class="params">event,name</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> component = event.target.component;</span><br><span class="line">    transaction.perform(component[name].bind(component,event));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>1、异步更新state，将短时间内的多个setState合并成一个<br>2、为了解决异步更新导致的问题，增加另一种形式的setState：接受一个函数作为参数，在函数中可以得到前一个状态并返回下一个状态</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">add = <span class="function"><span class="params">()</span> =&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(<span class="function">(<span class="params">state</span>)=&gt;</span>&#123;<span class="attr">number</span>: state.number+<span class="number">1</span>&#125;);</span><br><span class="line">    <span class="keyword">this</span>.setState(<span class="function">(<span class="params">state</span>)=&gt;</span>&#123;<span class="attr">number</span>: state.number+<span class="number">1</span>&#125;);</span><br><span class="line">    <span class="keyword">this</span>.setState(<span class="function">(<span class="params">state</span>)=&gt;</span>&#123;<span class="attr">number</span>: state.number+<span class="number">1</span>&#125;);</span><br><span class="line">    <span class="comment">// 这样 页面上会输出3 </span></span><br><span class="line">    <span class="comment">// 如果想从上一个状态计算下一个状态，需要传递一个函数而非对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>举例：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  state = &#123;</span><br><span class="line">    count: <span class="number">0</span></span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  componentDidMount() &#123;</span><br><span class="line">    <span class="comment">// 生命周期中调用</span></span><br><span class="line">    <span class="keyword">this</span>.setState(&#123; <span class="attr">count</span>: <span class="keyword">this</span>.state.count + <span class="number">1</span> &#125;);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"lifecycle: "</span> + <span class="keyword">this</span>.state.count);  <span class="comment">// 0</span></span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// setTimeout中调用</span></span><br><span class="line">      <span class="keyword">this</span>.setState(&#123; <span class="attr">count</span>: <span class="keyword">this</span>.state.count + <span class="number">1</span> &#125;);</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">"setTimeout: "</span> + <span class="keyword">this</span>.state.count); <span class="comment">// 2</span></span><br><span class="line">    &#125;, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">document</span>.getElementById(<span class="string">"div2"</span>).addEventListener(<span class="string">"click"</span>, <span class="keyword">this</span>.increment2);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  increment = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 合成事件中调用</span></span><br><span class="line">    <span class="keyword">this</span>.setState(&#123; <span class="attr">count</span>: <span class="keyword">this</span>.state.count + <span class="number">1</span> &#125;);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"react event: "</span> + <span class="keyword">this</span>.state.count); <span class="comment">// 2=&gt;2</span></span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  increment2 = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 原生事件中调用</span></span><br><span class="line">    <span class="keyword">this</span>.setState(&#123; <span class="attr">count</span>: <span class="keyword">this</span>.state.count + <span class="number">1</span> &#125;);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"dom event: "</span> + <span class="keyword">this</span>.state.count); <span class="comment">// 2=&gt;3</span></span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div className=<span class="string">"App"</span>&gt;</span><br><span class="line">        &lt;h2&gt;couont: &#123;<span class="keyword">this</span>.state.count&#125;&lt;<span class="regexp">/h2&gt;</span></span><br><span class="line"><span class="regexp">        &lt;div id="div1" onClick=&#123;this.increment&#125;&gt;</span></span><br><span class="line"><span class="regexp">          click me and count+1</span></span><br><span class="line"><span class="regexp">        &lt;/</span>div&gt;</span><br><span class="line">        &lt;div id=<span class="string">"div2"</span>&gt;click me and count+<span class="number">1</span>&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>探讨前，我们先简单了解下react的事件机制：react为了解决跨平台，兼容性问题，自己封装了一套事件机制，代理了原生的事件，像在jsx中常见的onClick、onChange这些都是合成事件。</p>
<p>那么以上4种方式调用setState()，后面紧接着去取最新的state，按之前讲的异步原理，应该是取不到的。然而，setTimeout中调用以及原生事件中调用的话，是可以立马获取到最新的state的。根本原因在于，setState并不是真正意义上的异步操作，它只是模拟了异步的行为。React中会去维护一个标识（isBatchingUpdates），判断是直接更新还是先暂存state进队列。setTimeout以及原生事件都会直接去更新state，因此可以立即得到最新state。而合成事件和React生命周期函数中，是受React控制的，其会将isBatchingUpdates设置为 true，从而走的是类似异步的那一套。</p>
<p>在 setTimeout 中去 setState 并不算是一个单独的场景，它是随着你外层去决定的，因为你可以在合成事件中 setTimeout ，可以在钩子函数中 setTimeout ，也可以在原生事件setTimeout，但是不管是哪个场景下，基于event loop的模型下， setTimeout 中里去 setState 总能拿到最新的state值。</p>
<p>小结：<br>1、setState 只在合成事件和钩子函数中是“异步”的，在原生事件和 setTimeout 中都是同步的。<br>2、setState的“异步”并不是说内部由异步代码实现，其实本身执行的过程和代码都是同步的，只是合成事件和钩子函数的调用顺序在更新之前，导致在合成事件和钩子函数中没法立马拿到更新后的值，形式了所谓的“异步”，当然可以通过第二个参数 setState(partialState, callback) 中的callback拿到更新后的结果。<br>3、setState 的批量更新优化也是建立在“异步”（合成事件、钩子函数）之上的，在原生事件和setTimeout 中不会批量更新，在“异步”中如果对同一个值进行多次 setState ， setState 的批量更新策略会对其进行覆盖，取最后一次的执行，如果是同时 setState 多个不同的值，在更新时会对其进行合并批量更新。</p>
<h3 id="小测试"><a href="#小测试" class="headerlink" title="小测试"></a>小测试</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  state = &#123; <span class="attr">val</span>: <span class="number">0</span> &#125;</span><br><span class="line"></span><br><span class="line">  componentDidMount() &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(<span class="function">(<span class="params">state</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.state.val) </span><br><span class="line">        <span class="keyword">return</span> &#123; <span class="attr">val</span>: <span class="keyword">this</span>.state.val + <span class="number">1</span> &#125;</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.setState(<span class="function">(<span class="params">state</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.state.val) </span><br><span class="line">        <span class="keyword">return</span> &#123; <span class="attr">val</span>: <span class="keyword">this</span>.state.val + <span class="number">1</span> &#125;</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    setTimeout(<span class="function"><span class="params">_</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.setState(&#123; <span class="attr">val</span>: <span class="keyword">this</span>.state.val + <span class="number">1</span> &#125;)</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="keyword">this</span>.state.val); </span><br><span class="line"></span><br><span class="line">      <span class="keyword">this</span>.setState(&#123; <span class="attr">val</span>: <span class="keyword">this</span>.state.val + <span class="number">1</span> &#125;)</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="keyword">this</span>.state.val) </span><br><span class="line">    &#125;, <span class="number">0</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;this.state.val&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> App;</span><br></pre></td></tr></table></figure>

<p>0 0 2 3<br>【提问】line11 为什么在使用函数式 setState 进行状态更新后，在后一个里面还是不能通过 this.state.age 拿到最新的值？<br>【回答】源码这样解释，执行第二个 setState 里面的函数时，由第一个 setState 所产生的最新的 state 并没有合并到 this 对象上面去，所以此时通过 this 获取不到最新的状态，故而拿到的 this.state.val 的值为 0</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  state = &#123; <span class="attr">val</span>: <span class="number">0</span> &#125;</span><br><span class="line"></span><br><span class="line">  componentDidMount() &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(<span class="function">(<span class="params">state</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.state.val) </span><br><span class="line">        <span class="keyword">return</span> &#123; <span class="attr">val</span>: state.val + <span class="number">1</span> &#125;</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.setState(<span class="function">(<span class="params">state</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.state.val) </span><br><span class="line">        <span class="keyword">return</span> &#123; <span class="attr">val</span>: state.val + <span class="number">1</span> &#125;</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    setTimeout(<span class="function"><span class="params">_</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.setState(&#123; <span class="attr">val</span>: <span class="keyword">this</span>.state.val + <span class="number">1</span> &#125;)</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="keyword">this</span>.state.val);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">this</span>.setState(&#123; <span class="attr">val</span>: <span class="keyword">this</span>.state.val + <span class="number">1</span> &#125;)</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="keyword">this</span>.state.val) </span><br><span class="line">    &#125;, <span class="number">0</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;this.state.val&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> App;</span><br></pre></td></tr></table></figure>

<p>0 0 3 4</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  state = &#123; <span class="attr">val</span>: <span class="number">0</span> &#125;</span><br><span class="line"></span><br><span class="line">  componentDidMount() &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(<span class="function">(<span class="params">state</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(state.val)</span><br><span class="line">        <span class="keyword">return</span> &#123; <span class="attr">val</span>: state.val + <span class="number">1</span> &#125;</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.setState(<span class="function">(<span class="params">state</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(state.val)</span><br><span class="line">        <span class="keyword">return</span> &#123; <span class="attr">val</span>: state.val + <span class="number">1</span> &#125;</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    setTimeout(<span class="function"><span class="params">_</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.setState(&#123; <span class="attr">val</span>: <span class="keyword">this</span>.state.val + <span class="number">1</span> &#125;)</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="keyword">this</span>.state.val);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">this</span>.setState(&#123; <span class="attr">val</span>: <span class="keyword">this</span>.state.val + <span class="number">1</span> &#125;)</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="keyword">this</span>.state.val)</span><br><span class="line">    &#125;, <span class="number">0</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;this.state.val&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> App;</span><br></pre></td></tr></table></figure>

<p>0 1 3 4</p>
<h2 id="Context"><a href="#Context" class="headerlink" title="Context"></a>Context</h2><blockquote>
<p>Context 提供了一个无需为每层组件手动添加 props，就能在组件树间进行数据传递的方法。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> Context = React.createContext(); <span class="comment">// 返回一个context实例</span></span><br><span class="line"><span class="comment">// Context.Provider 负责提供数据  Context.Consumer 负责获取数据</span></span><br></pre></td></tr></table></figure>

<p><a href="https://zh-hans.reactjs.org/docs/context.html" target="_blank" rel="noopener">https://zh-hans.reactjs.org/docs/context.html</a></p>
<p>从示例 <a href="http://react.html.cn/docs/context.html#%E5%8A%A8%E6%80%81-context" target="_blank" rel="noopener">http://react.html.cn/docs/context.html#%E5%8A%A8%E6%80%81-context</a> 可以看出没有被包裹的改变同一个值，没有改变</p>
<p><img src="https://jiafei2333.github.io/html/images/Context-theme01.gif" alt></p>
<p>注意下告诫<br><a href="http://react.html.cn/docs/context.html#%E5%91%8A%E8%AF%AB" target="_blank" rel="noopener">http://react.html.cn/docs/context.html#%E5%91%8A%E8%AF%AB</a></p>
<p>等学了react-redux的 <provider> 之后可以在反过来看看Context中的  <code>childContextTypes</code>   <code>getChildContext</code> 等</provider></p>
<h2 id="PureComponent"><a href="#PureComponent" class="headerlink" title="PureComponent"></a>PureComponent</h2><ul>
<li>当一个组件的props或state变更，React 会将最新返回的元素与之前渲染的元素进行对比，以此决定是否有必要更新真实的 DOM，当它们不相同时 React 会更新该 DOM。</li>
<li>如果渲染的组件非常多时可以通过覆盖生命周期方法 <code>shouldComponentUpdate</code> 来进行优化</li>
<li>shouldComponentUpdate 方法会在重新渲染前被触发。其默认实现是返回 true,如果组件不需要更新，可以在shouldComponentUpdate中返回 false 来跳过整个渲染过程。其包括该组件的 render 调用以及之后的操作</li>
<li>PureComponent通过prop和state的浅比较来实现shouldComponentUpdate</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Title</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"render Title"</span>);</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &#123;<span class="keyword">this</span>.props.title&#125;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">class Counter extends Component&#123;</span></span><br><span class="line"><span class="regexp">  render() &#123;</span></span><br><span class="line"><span class="regexp">    console.log("render Counter");</span></span><br><span class="line"><span class="regexp">    return (</span></span><br><span class="line"><span class="regexp">      &lt;div&gt;</span></span><br><span class="line"><span class="regexp">        &#123;this.props.number&#125;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props)&#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">    <span class="keyword">this</span>.state = &#123;</span><br><span class="line">      title: <span class="string">'这里是标题'</span>,</span><br><span class="line">      number:<span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.inputRef = React.createRef();</span><br><span class="line">  &#125;</span><br><span class="line">  add = <span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">      number: <span class="keyword">this</span>.state.number + <span class="built_in">parseInt</span>(<span class="keyword">this</span>.inputRef.current.value)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"render App"</span>);</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div className=<span class="string">"App"</span>&gt;</span><br><span class="line">        &lt;Title title=&#123;<span class="keyword">this</span>.state.title&#125;&gt;<span class="xml"><span class="tag">&lt;/<span class="name">Title</span>&gt;</span></span></span><br><span class="line">        &lt;Counter number=&#123;<span class="keyword">this</span>.state.number&#125;&gt;<span class="xml"><span class="tag">&lt;/<span class="name">Counter</span>&gt;</span></span></span><br><span class="line">        &lt;input ref=&#123;<span class="keyword">this</span>.inputRef&#125; /&gt;</span><br><span class="line">        &lt;button onClick=&#123;<span class="keyword">this</span>.add&#125;&gt;+<span class="xml"><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">export default App;</span></span><br></pre></td></tr></table></figure>

<p><code>App</code> 组件包含2个子组件 <code>Title</code> 组件 和 <code>Counter</code> 组件<br>当点击 + 时，三个组件都刷新，当父组件的值改变，子组件也render</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">render App</span><br><span class="line">render Title</span><br><span class="line">render Counter</span><br></pre></td></tr></table></figure>

<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><ul>
<li>当改变数字的时候 title 没有改变，<code>&lt;Title&gt;</code> 组件不应该更新</li>
<li>当 + 0，实际数字没有改变，3个组件都不应该更新</li>
</ul>
<h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><blockquote>
<p>所有组件都继承 PureComponent</p>
</blockquote>
<p>这个是React原生的 <code>import React, { Component, PureComponent } from &#39;react&#39;</code></p>
<h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>input中输入 0，3个组件都不render<br>input中输入 1</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">render App</span><br><span class="line">render Counter</span><br></pre></td></tr></table></figure>

<h3 id="手写PureComponent"><a href="#手写PureComponent" class="headerlink" title="手写PureComponent"></a>手写PureComponent</h3><p>浅比较方法</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 浅比较 比较obj1 和 obj2 是否相等，相等返回true，不相等返回false，只比较第一层</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">shallowEqual</span>(<span class="params">obj1,obj2</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(obj1 === obj2)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">typeof</span> obj1 != <span class="string">'object'</span> || obj1 === <span class="literal">null</span> ||<span class="keyword">typeof</span> obj2 != <span class="string">'object'</span> || obj2 === <span class="literal">null</span> )&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> keys1 = <span class="built_in">Object</span>.keys(obj1);</span><br><span class="line">    <span class="keyword">let</span> keys2 = <span class="built_in">Object</span>.keys(obj2);</span><br><span class="line">    <span class="keyword">if</span>(keys1.length != keys2.length)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> key <span class="keyword">of</span> keys1)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!obj2.hasOwnProperty(key) || obj1[key] !== obj2[key])&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">"line16~"</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj1 = &#123;<span class="attr">name</span>:<span class="string">'jiafei'</span>&#125;;</span><br><span class="line"><span class="keyword">let</span> obj2 = &#123;<span class="attr">name</span>:<span class="string">'jiafei'</span>&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(shallowEqual(obj1,obj2)); <span class="comment">// 返回 true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj1 = &#123;<span class="attr">attr</span>:&#123;<span class="attr">name</span>:<span class="string">'jiafei'</span>&#125;&#125;;</span><br><span class="line"><span class="keyword">let</span> obj2 = &#123;<span class="attr">attr</span>:&#123;<span class="attr">name</span>:<span class="string">'jiafei'</span>&#125;&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(shallowEqual(obj1,obj2)); </span><br><span class="line"><span class="comment">// 返回 line16~ false  </span></span><br><span class="line"><span class="comment">// 这里走到了line16 &#123;name:'jiafei'&#125;这个对象引用的地址不一样，所以不相等，这里只比较了第一层</span></span><br></pre></td></tr></table></figure>

<p>改成深比较</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> key <span class="keyword">of</span> keys1)&#123;</span><br><span class="line">    <span class="comment">// if(!obj2.hasOwnProperty(key) || obj1[key] !== obj2[key])&#123;</span></span><br><span class="line">    <span class="comment">//     console.log("line30~")</span></span><br><span class="line">    <span class="comment">//     return false;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    <span class="comment">// 递归改成深比较</span></span><br><span class="line">    <span class="keyword">if</span>(obj2.hasOwnProperty(key))&#123;</span><br><span class="line">        <span class="keyword">if</span>(obj1[key] != obj2[key])&#123;</span><br><span class="line">            <span class="keyword">if</span>( <span class="keyword">typeof</span> obj1[key] === <span class="string">'object'</span> &amp;&amp; <span class="keyword">typeof</span> obj2[key] === <span class="string">'object'</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> shallowEqual(obj1[key],obj2[key])</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> obj1 = &#123;<span class="attr">attr</span>:&#123;<span class="attr">name</span>:<span class="string">'jiafei'</span>&#125;&#125;;</span><br><span class="line"><span class="keyword">let</span> obj2 = &#123;<span class="attr">attr</span>:&#123;<span class="attr">name</span>:<span class="string">'jiafei'</span>&#125;&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(shallowEqual(obj1,obj2));</span><br><span class="line"><span class="comment">// 返回 true</span></span><br></pre></td></tr></table></figure>

<h3 id="PureComponent-要注意的问题"><a href="#PureComponent-要注意的问题" class="headerlink" title="PureComponent 要注意的问题"></a>PureComponent 要注意的问题</h3><p>当state中</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">this</span>.state = &#123;</span><br><span class="line">    title: <span class="string">'这里是标题'</span>,</span><br><span class="line">    number:&#123;<span class="attr">count</span>: <span class="number">0</span>&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时，改变state时这样写</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">this</span>.state.number.count = <span class="keyword">this</span>.state.number.count + <span class="built_in">parseInt</span>(<span class="keyword">this</span>.inputRef.current.value);</span><br><span class="line"><span class="keyword">this</span>.setState(&#123;</span><br><span class="line">  number: <span class="keyword">this</span>.state.number</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>那么，改变input中的值3个组件都不render，因为</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(!obj2.hasOwnProperty(key) || obj1[key] !== obj2[key])&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里<code>{count: ...}</code> 这个对象指向的引用地址没有改变<br>可以这样改</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">this</span>.state.number.count = <span class="keyword">this</span>.state.number.count + <span class="built_in">parseInt</span>(<span class="keyword">this</span>.inputRef.current.value);</span><br><span class="line"><span class="keyword">this</span>.setState(&#123;</span><br><span class="line">  number: &#123;...this.state.number,<span class="attr">count</span>: <span class="keyword">this</span>.state.number.count&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>每次都创建新的number对象，所以能够更新</p>
<h3 id="函数组件的PureComponent"><a href="#函数组件的PureComponent" class="headerlink" title="函数组件的PureComponent"></a>函数组件的PureComponent</h3><p>当<code>&lt;Title&gt;</code>组件变成函数组件时</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Title</span>(<span class="params">props</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"render Title Func"</span>);</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &#123;props.title&#125;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>

<p>可以看到每次改变input中的值，都会刷新 render Title Func</p>
<p>解决：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Title</span>(<span class="params">props</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"render Title Func"</span>);</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &#123;props.title&#125;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp">Title = React.memo(Title);</span></span><br></pre></td></tr></table></figure>

<p>memo的原理</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">memo</span>(<span class="params">Func</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="class"><span class="keyword">class</span> <span class="keyword">extends</span> <span class="title">PureComponent</span></span>&#123;</span><br><span class="line">    render()&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">Func</span> &#123;<span class="attr">...this.props</span>&#125;  /&gt;</span></span></span><br><span class="line"><span class="xml">    &#125;</span></span><br><span class="line"><span class="xml">  &#125;</span></span><br><span class="line"><span class="xml">&#125;</span></span><br><span class="line"><span class="xml">function memo(Func)&#123;</span></span><br><span class="line"><span class="xml">  return class extends PureComponent&#123;</span></span><br><span class="line"><span class="xml">    render()&#123;</span></span><br><span class="line"><span class="xml">      return Func(this.props);</span></span><br><span class="line"><span class="xml">    &#125;</span></span><br><span class="line"><span class="xml">  &#125;</span></span><br><span class="line"><span class="xml">&#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="额外补充"><a href="#额外补充" class="headerlink" title="额外补充"></a>额外补充</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> null1 = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">let</span> null2 = <span class="literal">null</span>;</span><br><span class="line"><span class="built_in">console</span>.log(null1 === null2); </span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj1 = &#123;&#125;;</span><br><span class="line"><span class="keyword">let</span> obj2 = &#123;&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(obj1 === obj2);</span><br><span class="line"><span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<h2 id="react组件通信"><a href="#react组件通信" class="headerlink" title="react组件通信"></a>react组件通信</h2><p>1、属性传递；2、context redux内部也是context实现的。</p>
<blockquote>
<p>看下react中文文档 <a href="http://react.html.cn/docs/context.html" target="_blank" rel="noopener">http://react.html.cn/docs/context.html</a> 这里的例子可以看官网的  好好看看官方的这个例子</p>
</blockquote>
<blockquote>
<p>代码拆分 <a href="http://react.html.cn/docs/code-splitting.html" target="_blank" rel="noopener">http://react.html.cn/docs/code-splitting.html</a></p>
</blockquote>
<h2 id="高阶组件"><a href="#高阶组件" class="headerlink" title="高阶组件"></a>高阶组件</h2><ul>
<li>高阶组件就是一个函数，传给它一个组件，它返回一个新的组件</li>
<li>高阶组件的作用其实就是为了组件之间的代码复用</li>
</ul>
<h3 id="示例一"><a href="#示例一" class="headerlink" title="示例一"></a>示例一</h3><p>下面有2个逻辑相似的组件 如下<br>UserNameInput.js</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserNameInput</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props)&#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">    <span class="keyword">this</span>.state = &#123;</span><br><span class="line">      value: <span class="string">''</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  componentDidMount() &#123;</span><br><span class="line">      <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">          value: localStorage.getItem(<span class="string">'username'</span>)</span><br><span class="line">      &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &#123;<span class="keyword">this</span>.state.value&#125;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp">export default UserNameInput;</span></span><br></pre></td></tr></table></figure>

<p>EmailInput.js</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EmailInput</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props)&#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">    <span class="keyword">this</span>.state = &#123;</span><br><span class="line">      value: <span class="string">''</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  componentDidMount() &#123;</span><br><span class="line">      <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">          value: localStorage.getItem(<span class="string">'email'</span>)</span><br><span class="line">      &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &#123;<span class="keyword">this</span>.state.value&#125;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp">export default EmailInput;</span></span><br></pre></td></tr></table></figure>

<p>这2个组件都是获取一个值然后展示，其中line3 ~ 13 的逻辑可以复用</p>
<p>将公共逻辑部分封装成一个高阶组件<br>withLocal.js</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span>(<span class="params">Component,name</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="class"><span class="keyword">class</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span></span>&#123;</span><br><span class="line">        <span class="keyword">constructor</span>(props)&#123;</span><br><span class="line">            <span class="keyword">super</span>(props);</span><br><span class="line">            <span class="keyword">this</span>.state = &#123;</span><br><span class="line">              value: <span class="string">''</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        componentDidMount() &#123;</span><br><span class="line">            <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">                value: localStorage.getItem(name)</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">        render()&#123;</span><br><span class="line">            <span class="keyword">return</span>  <span class="xml"><span class="tag">&lt;<span class="name">Component</span> &#123;<span class="attr">...this.props</span>&#125; <span class="attr">value</span>=<span class="string">&#123;this.state.value&#125;</span> /&gt;</span>;</span></span><br><span class="line"><span class="xml">        &#125;</span></span><br><span class="line"><span class="xml">    &#125;</span></span><br><span class="line"><span class="xml">&#125;</span></span><br></pre></td></tr></table></figure>

<p>那么原来的组件，还改变成如下：<br>UserNameInput.js</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> withLocal <span class="keyword">from</span> <span class="string">'./withLocal'</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserNameInput</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &#123;<span class="keyword">this</span>.props.value&#125;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp">export default withLocal(UserNameInput,'username');</span></span><br></pre></td></tr></table></figure>

<p>EmailInput.js</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> withLocal <span class="keyword">from</span> <span class="string">'./withLocal'</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EmailInput</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &#123;<span class="keyword">this</span>.props.value&#125;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp">export default withLocal(EmailInput,'email');</span></span><br></pre></td></tr></table></figure>

<p>可以看到页面上还是能显示之前localStore设置的数据</p>
<h3 id="示例二"><a href="#示例二" class="headerlink" title="示例二"></a>示例二</h3><p>升级，从本地获取到英文名字再从服务器端拿取数据显示对应的中文名字</p>
<p>withAjax.js</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span>(<span class="params">Component</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="class"><span class="keyword">class</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span></span>&#123;</span><br><span class="line">        <span class="keyword">constructor</span>(props)&#123;</span><br><span class="line">            <span class="keyword">super</span>(props);</span><br><span class="line">            <span class="keyword">this</span>.state = &#123;</span><br><span class="line">              valueAjax: <span class="string">''</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        componentDidMount() &#123;</span><br><span class="line">            fetch(<span class="string">'http://localhost:3000/translate.json'</span>).then(<span class="function"><span class="params">response</span>=&gt;</span>response.json()).then(<span class="function"><span class="params">result</span>=&gt;</span>&#123;</span><br><span class="line">                <span class="keyword">this</span>.setState(&#123;<span class="attr">valueAjax</span>:result[<span class="keyword">this</span>.props.value]&#125;)</span><br><span class="line">            &#125;).catch(<span class="function"><span class="params">err</span>=&gt;</span>&#123; <span class="comment">// 错误捕获</span></span><br><span class="line">                <span class="built_in">console</span>.log(err);</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">        render()&#123;</span><br><span class="line">            <span class="keyword">return</span>  <span class="xml"><span class="tag">&lt;<span class="name">Component</span> <span class="attr">value</span>=<span class="string">&#123;this.state.valueAjax&#125;</span> /&gt;</span>;</span></span><br><span class="line"><span class="xml">        &#125;</span></span><br><span class="line"><span class="xml">    &#125;</span></span><br><span class="line"><span class="xml">&#125;</span></span><br></pre></td></tr></table></figure>

<p>withLocal.js</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span>(<span class="params">Component,name</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="class"><span class="keyword">class</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span></span>&#123;</span><br><span class="line">        <span class="keyword">constructor</span>(props)&#123;</span><br><span class="line">            <span class="keyword">super</span>(props);</span><br><span class="line">            <span class="keyword">this</span>.state = &#123;</span><br><span class="line">              value: <span class="string">''</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        componentDidMount() &#123;</span><br><span class="line">            <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">                value: localStorage.getItem(name)</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">        render()&#123;</span><br><span class="line">            <span class="keyword">return</span>  <span class="xml"><span class="tag">&lt;<span class="name">Component</span> &#123;<span class="attr">...this.props</span>&#125; <span class="attr">value</span>=<span class="string">&#123;this.state.value&#125;</span> /&gt;</span>;</span></span><br><span class="line"><span class="xml">        &#125;</span></span><br><span class="line"><span class="xml">    &#125;</span></span><br><span class="line"><span class="xml">&#125;</span></span><br></pre></td></tr></table></figure>

<p>UserNameInput.js</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> withLocal <span class="keyword">from</span> <span class="string">'./withLocal'</span>;</span><br><span class="line"><span class="keyword">import</span> withAjax <span class="keyword">from</span> <span class="string">'./withAjax'</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserNameInput</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &#123;<span class="keyword">this</span>.props.value&#125;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp">let UserNameInputWithAjax = withAjax(UserNameInput);</span></span><br><span class="line"><span class="regexp">let UserNameInputWithLocal = withLocal(UserNameInputWithAjax,'username');</span></span><br><span class="line"><span class="regexp">export default UserNameInputWithLocal;</span></span><br></pre></td></tr></table></figure>

<p>顺序：withLocal (携带本地的英文名)=&gt; withAjax (从服务器请求数据传递)=&gt; UserNameInput </p>
<p>高阶组件一般就嵌套一层，超过二层就太复杂了。之后学到的hooks能解决这个问题（高阶组件的嵌套问题）<br>高阶组件应用场景：比如 react-redux、react路由、路由权限</p>
<ul>
<li>react 高阶组件是一种react复用代码的封装、抽取方式，高阶组件是一个函数，接收组件并封装<br>1、基于属性代理：操作组件的props<br>2、基于反向继承：拦截生命周期、state、渲染过程</li>
<li>使用高阶组件<br>1、@修饰符<br>2、直接调用函数<br><a href="https://blog.csdn.net/qq_29590623/article/details/88560805" target="_blank" rel="noopener">https://blog.csdn.net/qq_29590623/article/details/88560805</a></li>
</ul>
<h2 id="render-props"><a href="#render-props" class="headerlink" title="render props"></a>render props</h2><p>和高阶组件一样，都是解决逻辑复用问题，传值方式不同，本质没有区别。<br>一个组件 它的子组件是个函数。</p>
<blockquote>
<p>Context.Consumer 实质上就是一个 render props</p>
</blockquote>
<h2 id="React-Fragment"><a href="#React-Fragment" class="headerlink" title="React.Fragment"></a>React.Fragment</h2><blockquote>
<p>片段(fragments) 可以让你将子元素列表添加到一个分组中，并且不会在DOM 中增加额外节点。</p>
</blockquote>
<p><a href="http://react.html.cn/docs/fragments.html" target="_blank" rel="noopener">http://react.html.cn/docs/fragments.html</a></p>
<h2 id="插槽Portal"><a href="#插槽Portal" class="headerlink" title="插槽Portal"></a>插槽Portal</h2><blockquote>
<p>Portals 提供了一种很好的方法，将子节点渲染到父组件 DOM 层次结构之外的 DOM 节点。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">ReactDOM.createPortal(child, container)</span><br></pre></td></tr></table></figure>

<p>第一个参数（child）是任何可渲染的 React 子元素，例如一个元素，字符串或 片段(fragment)<br>第二个参数（container）则是一个 DOM 元素</p>
<p>入口文件index.html 增加一个放置插槽的dom元素位置</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"modal-root"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React,&#123;Component&#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'./modal.css'</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Modal</span> <span class="keyword">extends</span> <span class="title">Component</span></span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>() &#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        <span class="keyword">this</span>.modal=<span class="built_in">document</span>.querySelector(<span class="string">'#modal-root'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    render() &#123;</span><br><span class="line">        <span class="keyword">return</span> ReactDOM.createPortal(<span class="keyword">this</span>.props.children,<span class="keyword">this</span>.modal);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Page</span> <span class="keyword">extends</span> <span class="title">Component</span></span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>() &#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        <span class="keyword">this</span>.state=&#123;<span class="attr">show</span>:<span class="literal">false</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    handleClick=<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.setState(&#123;<span class="attr">show</span>:!<span class="keyword">this</span>.state.show&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    render() &#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                &lt;button onClick=&#123;<span class="keyword">this</span>.handleClick&#125;&gt;显示模态窗口&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">                &#123;</span></span><br><span class="line"><span class="regexp">                    this.state.show&amp;&amp;</span></span><br><span class="line"><span class="regexp">                &lt;Modal&gt;</span></span><br><span class="line"><span class="regexp">                    &lt;div id="modal" className="modal"&gt;</span></span><br><span class="line"><span class="regexp">                        &lt;div className="modal-content" id="modal-content"&gt;</span></span><br><span class="line"><span class="regexp">                            内容</span></span><br><span class="line"><span class="regexp">                            &lt;button onClick=&#123;this.handleClick&#125;&gt;关闭&lt;/</span>button&gt;</span><br><span class="line">                        &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">                    &lt;/</span>div&gt;</span><br><span class="line">                &lt;<span class="regexp">/Modal&gt;</span></span><br><span class="line"><span class="regexp">                &#125;</span></span><br><span class="line"><span class="regexp">            &lt;/</span>div&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>modal.css</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.modal</span>&#123;</span><br><span class="line">    <span class="attribute">position</span>: fixed;</span><br><span class="line">    <span class="attribute">left</span>:<span class="number">0</span>;</span><br><span class="line">    <span class="attribute">top</span>:<span class="number">0</span>;</span><br><span class="line">    <span class="attribute">right</span>:<span class="number">0</span>;</span><br><span class="line">    <span class="attribute">bottom</span>:<span class="number">0</span>;</span><br><span class="line">    <span class="attribute">background</span>: <span class="built_in">rgba</span>(0,0,0,.5);</span><br><span class="line">    <span class="attribute">display</span>: block;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@<span class="keyword">keyframes</span> zoom&#123;</span><br><span class="line">    <span class="selector-tag">from</span>&#123;<span class="attribute">transform</span>:<span class="built_in">scale</span>(0);&#125;</span><br><span class="line">    <span class="selector-tag">to</span>&#123;<span class="attribute">transform</span>:<span class="built_in">scale</span>(1);&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.modal</span> <span class="selector-class">.modal-content</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>:<span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">height</span>:<span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">background</span>: white;</span><br><span class="line">    <span class="attribute">border-radius</span>: <span class="number">10px</span>;</span><br><span class="line">    <span class="attribute">margin</span>:<span class="number">100px</span> auto;</span><br><span class="line">    <span class="attribute">display</span>:flex;</span><br><span class="line">    <span class="attribute">flex-direction</span>: row;</span><br><span class="line">    <span class="attribute">justify-content</span>: center;</span><br><span class="line">    <span class="attribute">align-items</span>: center;</span><br><span class="line">    <span class="attribute">animation</span>: zoom .<span class="number">6s</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的样式可以看一下，flex 、animation</p>
<h2 id="React-lazy"><a href="#React-lazy" class="headerlink" title="React.lazy"></a>React.lazy</h2><p><a href="https://zh-hans.reactjs.org/docs/code-splitting.html#reactlazy" target="_blank" rel="noopener">https://zh-hans.reactjs.org/docs/code-splitting.html#reactlazy</a></p>
<h2 id="错误边界"><a href="#错误边界" class="headerlink" title="错误边界"></a>错误边界</h2><p><a href="https://zh-hans.reactjs.org/docs/error-boundaries.html" target="_blank" rel="noopener">https://zh-hans.reactjs.org/docs/error-boundaries.html</a> </p>
<h2 id="长列表优化"><a href="#长列表优化" class="headerlink" title="长列表优化"></a>长列表优化</h2><p>未完待续</p>
]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title>React 项目版本升级</title>
    <url>/2019/12/09/React-UpdateVersion/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote>
<p>当前项目版本 react: “16.2.0” 、dva: “2.3.1” 、 roadhog: “2.4.2”、 babel: 6.x<br>最新版本 react v16.12.0<br>暂时决定 升级至 react v16.9.0、babel v7.7.7</p>
</blockquote>
<p>16.3.0生命周期更新、16.9.0 新增Hooks</p>
<p>已知：</p>
<ul>
<li>生命周期版本更改，废弃了 componentWillMount（可以将业务代码改至 componentDidMount）、componentWillReceiveProps（该部分牵扯大量业务逻辑状态更改，检索出来有约50处使用，耗时）、componentWillUpdate（当前项目中未使用，可忽略）</li>
</ul>
<p>参考资料：<br><a href="https://github.com/nanyang24/blog/issues/92" target="_blank" rel="noopener">https://github.com/nanyang24/blog/issues/92</a><br><a href="https://zh-hans.reactjs.org/blog/2019/08/08/react-v16.9.0.html" target="_blank" rel="noopener">https://zh-hans.reactjs.org/blog/2019/08/08/react-v16.9.0.html</a></p>
<h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><h3 id="升级-react-react-dom"><a href="#升级-react-react-dom" class="headerlink" title="升级 react | react-dom"></a>升级 react | react-dom</h3><p>1、<code>npm install react@16.9.0 react-dom@16.9.0 --save</code></p>
<p>2、启动项目 无异常， 使用 React.Lazy、Supense 来进行 <a href="https://juejin.im/post/5c7d4a785188251b921f4e26" target="_blank" rel="noopener">代码分割</a>，（主要目的）</p>
<p>3、按照 lazy、Suspense 的格式尝试修改了其中一个组件引入的多个弹层之后，代码报错，如下：</p>
<p><img src="https://jiafei2333.github.io/html/images/reactUpdating.png" alt></p>
<p>4、调试发现，如下方式引入的 lazy、Suspense 并没有找到源码地址，即便 react 的版本为16.9.0</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React,&#123;lazy, Suspense&#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br></pre></td></tr></table></figure>

<p>5、新起一个项目 <code>create-react-app projectName</code> , 同样引入如上代码 发现 <code>/node_modules/@types/react/index.d.ts</code> 中包含Suspense 且 <code>@types/react</code> 版本为 <code>v16.9.16</code>,同理发现公司项目中的版本为 <code>v16.3.0</code></p>
<p>6、升级 <code>npm install @types/react</code>，默认升级到 <code>v16.9.16</code>，再运行项目，可以正常访问，且 打包查看，之前有一个 5596k大小的包，现在是 5222k，可见业务逻辑代码分割成功，现继续更改代码中组件的引入方式。<br>    5596kk =&gt; 5222k =&gt; 5176k =&gt; 5036k  将项目中所有外部引入的 Modal 都使用lazy加载，可见 还是有 5M 多…. (接下来可能需要从代码业务层入手)</p>
<p>7、warning</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Warning: React version not specified <span class="keyword">in</span> eslint-plugin-react settings. See https:<span class="comment">//github.com/yannickcr/eslint-plugin-reat#configuration.</span></span><br></pre></td></tr></table></figure>

<p>8、旧的生命周期方法名替换  <code>npx react-codemod rename-unsafe-lifecycles</code> 失败</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="number">175</span> errors</span><br><span class="line"><span class="number">0</span> unmodified</span><br><span class="line"><span class="number">817</span> skipped</span><br><span class="line"><span class="number">9</span> ok</span><br></pre></td></tr></table></figure>

<p>9、在路由组件的最外层包裹一个错误边界组件。</p>
<p>10、 《使用开发者工具中的分析器对组件进行分析》  看不懂…</p>
<p><a href="https://zh-hans.reactjs.org/docs/optimizing-performance.html" target="_blank" rel="noopener">https://zh-hans.reactjs.org/docs/optimizing-performance.html</a><br>中文版 <a href="https://juejin.im/post/5ba1f995f265da0a972e1657#heading-0" target="_blank" rel="noopener">https://juejin.im/post/5ba1f995f265da0a972e1657#heading-0</a></p>
<h3 id="roadhog-analyze"><a href="#roadhog-analyze" class="headerlink" title="roadhog analyze"></a>roadhog analyze</h3><p><code>roadhog build --analyze</code></p>
<p><img src="https://jiafei2333.github.io/html/images/roadhog-analyze-errr1.png" alt></p>
<p>如上图所示发现是版本问题，那就先升级babel</p>
<h3 id="升级babel"><a href="#升级babel" class="headerlink" title="升级babel"></a>升级babel</h3><p>根目录下新增 .babelrc 文件</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"plugins"</span>: [<span class="string">"transform-decorators-legacy"</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以下是之前一系列的babel插件</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">devDependencies:&#123;</span><br><span class="line">  "babel-plugin-dva-hmr": "^0.4.1",</span><br><span class="line">  "babel-plugin-transform-remove-console": "^6.9.4",</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dependencies:&#123;</span><br><span class="line">  "babel-cli": "^6.26.0",</span><br><span class="line">  "babel-plugin-import": "^1.13.0",</span><br><span class="line">  "babel-plugin-transform-decorators-legacy": "^1.3.5",</span><br><span class="line">  "babel-polyfill": "^6.26.0",</span><br><span class="line">  "babel-preset-es2015": "^6.24.1",</span><br><span class="line">  "babel-preset-stage-2": "^6.24.1",</span><br><span class="line">  "babel-runtime": "^6.26.0",</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>官方提供了一个工具babel-upgrade，对于已有的项目，只需要运行这样一行命令就可以了：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npx babel-upgrade --write --install</span><br></pre></td></tr></table></figure>

<p>升级如下：</p>
<p>.babelrc</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"plugins"</span>: [</span><br><span class="line">    [</span><br><span class="line">      <span class="string">"@babel/plugin-proposal-decorators"</span>,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">"legacy"</span>: <span class="literal">true</span></span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="code"><pre><span class="line">dependencies:&#123;</span><br><span class="line">  "@babel/cli": "^7.0.0",</span><br><span class="line">  "@babel/core": "^7.0.0",</span><br><span class="line">  "@babel/plugin-proposal-class-properties": "^7.0.0",</span><br><span class="line">  "@babel/plugin-proposal-decorators": "^7.0.0",</span><br><span class="line">  "@babel/plugin-proposal-export-namespace-from": "^7.0.0",</span><br><span class="line">  "@babel/plugin-proposal-function-sent": "^7.0.0",</span><br><span class="line">  "@babel/plugin-proposal-json-strings": "^7.0.0",</span><br><span class="line">  "@babel/plugin-proposal-numeric-separator": "^7.0.0",</span><br><span class="line">  "@babel/plugin-proposal-throw-expressions": "^7.0.0",</span><br><span class="line">  "@babel/plugin-syntax-dynamic-import": "^7.0.0",</span><br><span class="line">  "@babel/plugin-syntax-import-meta": "^7.0.0",</span><br><span class="line">  "@babel/polyfill": "^7.0.0",</span><br><span class="line">  "@babel/preset-env": "^7.0.0",</span><br><span class="line">  "@babel/runtime-corejs2": "^7.0.0",</span><br><span class="line"></span><br><span class="line">  "babel-plugin-import": "^1.13.0",</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">devDependencies:&#123;</span><br><span class="line">  "@babel/core": "^7.0.0",</span><br><span class="line"></span><br><span class="line">  "babel-plugin-dva-hmr": "^0.4.1",</span><br><span class="line">  "babel-plugin-transform-remove-console": "^6.9.4",</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>继续分析—</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">roadhog build --analyze</span><br></pre></td></tr></table></figure>

<p>还是失败</p>
]]></content>
      <categories>
        <category>React</category>
      </categories>
  </entry>
  <entry>
    <title>ES6 之 阅读理解</title>
    <url>/2019/11/21/ES6-1/</url>
    <content><![CDATA[<h2 id="17-Iterator"><a href="#17-Iterator" class="headerlink" title="17. Iterator"></a>17. Iterator</h2><p><a href="https://jiafei2333.github.io/2019/09/16/Generator/" target="_blank" rel="noopener">https://jiafei2333.github.io/2019/09/16/Generator/</a></p>
<blockquote>
<p>是一种接口，为各种不同的数据结构（Array、Object、Map、Set 等）提供统一的访问机制。任何数据结构只要部署 Iterator 接口，就可以完成遍历操作。<br>ES6 创造了一种新的遍历命令for…of循环，Iterator 接口主要供for…of消费。</p>
</blockquote>
<p>一刷：<br><a href="http://es6.ruanyifeng.com/#docs/iterator" target="_blank" rel="noopener">http://es6.ruanyifeng.com/#docs/iterator</a></p>
<h2 id="18-Generator"><a href="#18-Generator" class="headerlink" title="18. Generator"></a>18. Generator</h2><p><a href="https://jiafei2333.github.io/2019/09/16/Generator/" target="_blank" rel="noopener">https://jiafei2333.github.io/2019/09/16/Generator/</a></p>
<blockquote>
<p>调用 Generator 函数，返回一个遍历器对象，代表 Generator 函数的内部指针。以后，每次调用遍历器对象的next方法，就会返回一个有着value和done两个属性的对象。</p>
</blockquote>
<p>1、一个对象如果要具备可被for…of循环调用的 Iterator 接口，就必须在Symbol.iterator的属性上部署遍历器生成方法（原型链上的对象具有该方法也可）。</p>
<p>1/2刷：<br><a href="http://es6.ruanyifeng.com/#docs/generator" target="_blank" rel="noopener">http://es6.ruanyifeng.com/#docs/generator</a></p>
<h2 id="19-Generator-函数的异步应用"><a href="#19-Generator-函数的异步应用" class="headerlink" title="19. Generator 函数的异步应用"></a>19. Generator 函数的异步应用</h2><p><a href="http://es6.ruanyifeng.com/#docs/generator-async" target="_blank" rel="noopener">http://es6.ruanyifeng.com/#docs/generator-async</a></p>
<p>一刷，没怎么看明白，可以二刷继续研究，评论也看看。</p>
<h2 id="20-async-函数"><a href="#20-async-函数" class="headerlink" title="20.async 函数"></a>20.async 函数</h2><p><a href="http://es6.ruanyifeng.com/#docs/async" target="_blank" rel="noopener">http://es6.ruanyifeng.com/#docs/async</a></p>
<blockquote>
<p>async 函数就是 Generator 函数的语法糖。</p>
</blockquote>
<p>1、Generator 函数的执行必须靠执行器，所以才有了co模块，而async函数自带执行器。也就是说，async函数的执行，与普通函数一模一样，只要一行。Generator 函数，需要调用next方法，或者用co模块，才能真正执行，得到最后结果。<br>2、任何一个await语句后面的 Promise 对象变为reject状态，那么整个async函数都会中断执行。<br>3、Promise 的回调函数（ .then ）都存放在一个单独的栈里面，而 await 是暂停执行，所以不完全一样。</p>
<p>一刷</p>
<h2 id="12-Symbol"><a href="#12-Symbol" class="headerlink" title="12. Symbol"></a>12. Symbol</h2><p><a href="https://jiafei2333.github.io/2019/09/04/Reflect-Symbol/" target="_blank" rel="noopener">https://jiafei2333.github.io/2019/09/04/Reflect-Symbol/</a></p>
<blockquote>
<p>Symbol函数的参数只是表示对当前 Symbol 值的描述，因此相同参数的Symbol函数的返回值是不相等的。</p>
</blockquote>
<p>1、Singleton 模式指的是调用一个类，任何时候返回的都是同一个实例。</p>
<p><a href="http://es6.ruanyifeng.com/#docs/symbol" target="_blank" rel="noopener">http://es6.ruanyifeng.com/#docs/symbol</a><br>一刷：内置的 Symbol 值 这块内容太琐碎了，没怎么记得。</p>
<h2 id="14-Proxy"><a href="#14-Proxy" class="headerlink" title="14. Proxy"></a>14. Proxy</h2><p><a href="https://jiafei2333.github.io/2019/09/04/Object.defineProperty-Proxy/" target="_blank" rel="noopener">https://jiafei2333.github.io/2019/09/04/Object.defineProperty-Proxy/</a></p>
<blockquote>
<p>Proxy 可以理解成，在目标对象之前架设一层“拦截”，外界对该对象的访问，都必须先通过这层拦截，因此提供了一种机制，可以对外界的访问进行过滤和改写。</p>
</blockquote>
<p>1、ES6 原生提供 Proxy 构造函数，用来生成 Proxy 实例。<br>2、注意，要使得Proxy起作用，必须针对Proxy实例（上例是proxy对象）进行操作，而不是针对目标对象（上例是空对象）进行操作。<br>3、虽然 Proxy 可以代理针对目标对象的访问，但它不是目标对象的透明代理，即不做任何拦截的情况下，也无法保证与目标对象的行为一致。主要原因就是在 Proxy 代理的情况下，目标对象内部的this关键字会指向 Proxy 代理。<br>4、《this 问题》  这个可以看看，其他的很多都是Proxy的属性<br>5、Proxy web服务的客户端。</p>
<p>一刷：<br><a href="http://es6.ruanyifeng.com/#docs/proxy" target="_blank" rel="noopener">http://es6.ruanyifeng.com/#docs/proxy</a></p>
<h2 id="15-Reflect"><a href="#15-Reflect" class="headerlink" title="15. Reflect"></a>15. Reflect</h2><p>Reflect对象与Proxy对象一样，也是 ES6 为了操作对象而提供的新 API。</p>
<p>一刷:<br><a href="http://es6.ruanyifeng.com/#docs/reflect" target="_blank" rel="noopener">http://es6.ruanyifeng.com/#docs/reflect</a></p>
<h2 id="10-11-对象"><a href="#10-11-对象" class="headerlink" title="10. 11. 对象"></a>10. 11. 对象</h2><h3 id="10-1-对象的拓展"><a href="#10-1-对象的拓展" class="headerlink" title="10.1. 对象的拓展"></a>10.1. 对象的拓展</h3><h4 id="1-1-属性的遍历"><a href="#1-1-属性的遍历" class="headerlink" title="1.1 属性的遍历"></a>1.1 属性的遍历</h4><ul>
<li>（1）for…in</li>
<li>（2）Object.keys(obj)</li>
<li>（3）Object.getOwnPropertyNames(obj)</li>
<li>（4）Object.getOwnPropertySymbols(obj)</li>
<li>（5）Reflect.ownKeys(obj)<br>  Reflect.ownKeys返回一个数组，包含对象自身的所有键名，不管键名是 Symbol 或字符串，也不管是否可枚举。</li>
</ul>
<h4 id="10-1-2-super"><a href="#10-1-2-super" class="headerlink" title="10.1.2 super"></a>10.1.2 super</h4><blockquote>
<p>我们知道，this关键字总是指向函数所在的当前对象，ES6 又新增了另一个类似的关键字super，指向当前对象的原型对象。</p>
</blockquote>
<blockquote>
<p>JavaScript 引擎内部，super.foo等同于Object.getPrototypeOf(this).foo（属性）或Object.getPrototypeOf(this).foo.call(this)（方法）。          ？？<br>Object.getPrototypeOf() 返回指定对象的原型。</p>
</blockquote>
<h3 id="11-2-对象的新增方法"><a href="#11-2-对象的新增方法" class="headerlink" title="11.2. 对象的新增方法"></a>11.2. 对象的新增方法</h3><h4 id="11-2-1-Object-is"><a href="#11-2-1-Object-is" class="headerlink" title="11.2.1 Object.is()"></a>11.2.1 Object.is()</h4><p>比较两个值是否严格相等,与严格比较运算符（===）的行为基本一致。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Object</span>.is(&#123;&#125;, &#123;&#125;); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">+<span class="number">0</span> === <span class="number">-0</span> <span class="comment">//true</span></span><br><span class="line"><span class="literal">NaN</span> === <span class="literal">NaN</span> <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.is(+<span class="number">0</span>, <span class="number">-0</span>) <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Object</span>.is(<span class="literal">NaN</span>, <span class="literal">NaN</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<h4 id="11-2-2-Object-assign"><a href="#11-2-2-Object-assign" class="headerlink" title="11.2.2 Object.assign()"></a>11.2.2 Object.assign()</h4><blockquote>
<p>Object.assign方法用于对象的合并，将源对象（source）的所有可枚举属性，复制到目标对象（target）。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Object</span>.assign(target, source1, source2);</span><br></pre></td></tr></table></figure>

<ul>
<li>Object.assign拷贝的属性是有限制的，只拷贝源对象的自身属性（不拷贝继承属性），也不拷贝不可枚举的属性（enumerable: false）。属性名为 Symbol 值的属性，也会被Object.assign拷贝。</li>
</ul>
<h4 id="11-2-3-proto属性，Object-setPrototypeOf-，Object-getPrototypeOf"><a href="#11-2-3-proto属性，Object-setPrototypeOf-，Object-getPrototypeOf" class="headerlink" title="11.2.3 proto属性，Object.setPrototypeOf()，Object.getPrototypeOf()"></a>11.2.3 <strong>proto</strong>属性，Object.setPrototypeOf()，Object.getPrototypeOf()</h4><p><a href="https://jiafei2333.github.io/2019/09/09/Prototype-Extends/" target="_blank" rel="noopener">https://jiafei2333.github.io/2019/09/09/Prototype-Extends/</a></p>
<h4 id="11-2-4-Object-keys-，Object-values-，Object-entries-搭配-for…of-使用"><a href="#11-2-4-Object-keys-，Object-values-，Object-entries-搭配-for…of-使用" class="headerlink" title="11.2.4 Object.keys()，Object.values()，Object.entries() 搭配 for…of 使用"></a>11.2.4 Object.keys()，Object.values()，Object.entries() 搭配 for…of 使用</h4><p>也都可以搭配数组 <code>for (let index of [&#39;a&#39;, &#39;b&#39;].keys())</code></p>
<p>一刷：<br><a href="http://es6.ruanyifeng.com/#docs/object" target="_blank" rel="noopener">http://es6.ruanyifeng.com/#docs/object</a><br><a href="http://es6.ruanyifeng.com/#docs/object-methods" target="_blank" rel="noopener">http://es6.ruanyifeng.com/#docs/object-methods</a></p>
<h2 id="9-数组"><a href="#9-数组" class="headerlink" title="9. 数组"></a>9. 数组</h2><h3 id="9-1-拓展运算符的应用"><a href="#9-1-拓展运算符的应用" class="headerlink" title="9.1. 拓展运算符的应用"></a>9.1. 拓展运算符的应用</h3><p><a href="http://es6.ruanyifeng.com/#docs/array#%E6%89%A9%E5%B1%95%E8%BF%90%E7%AE%97%E7%AC%A6%E7%9A%84%E5%BA%94%E7%94%A8" target="_blank" rel="noopener">http://es6.ruanyifeng.com/#docs/array#%E6%89%A9%E5%B1%95%E8%BF%90%E7%AE%97%E7%AC%A6%E7%9A%84%E5%BA%94%E7%94%A8</a></p>
<p>扩展运算符内部调用的是数据结构的 Iterator 接口，因此只要具有 Iterator 接口的对象，都可以使用扩展运算符，比如 Map 结构。<br>Generator 函数运行后，返回一个遍历器对象，因此也可以使用扩展运算符。</p>
<h3 id="9-2-Array-from"><a href="#9-2-Array-from" class="headerlink" title="9.2. Array.from()"></a>9.2. Array.from()</h3><blockquote>
<p>Array.from方法用于将两类对象转为真正的数组：类似数组的对象（array-like object）和可遍历（iterable）的对象（包括 ES6 新增的数据结构 Set 和 Map）。</p>
</blockquote>
<p>任何有 <code>length</code> 属性的对象，都可以通过 <code>Array.from</code> 方法转为数组，而此时扩展运算符就无法转换。</p>
<p>一刷：<br><a href="http://es6.ruanyifeng.com/#docs/array" target="_blank" rel="noopener">http://es6.ruanyifeng.com/#docs/array</a></p>
<h2 id="8-函数的拓展"><a href="#8-函数的拓展" class="headerlink" title="8. 函数的拓展"></a>8. 函数的拓展</h2><h3 id="8-1-函数的-length-属性"><a href="#8-1-函数的-length-属性" class="headerlink" title="8.1. 函数的 length 属性"></a>8.1. 函数的 length 属性</h3><blockquote>
<p>函数的length属性，将返回没有指定默认值的参数个数。也就是说，指定了默认值后，length属性将失真，这个个数不算。</p>
</blockquote>
<h3 id="8-2-作用域"><a href="#8-2-作用域" class="headerlink" title="8.2. 作用域"></a>8.2. 作用域</h3><p>** <a href="http://es6.ruanyifeng.com/#docs/function#%E4%BD%9C%E7%94%A8%E5%9F%9F" target="_blank" rel="noopener">http://es6.ruanyifeng.com/#docs/function#%E4%BD%9C%E7%94%A8%E5%9F%9F</a></p>
<h3 id="8-3-箭头函数"><a href="#8-3-箭头函数" class="headerlink" title="8.3. 箭头函数"></a>8.3. 箭头函数</h3><ul>
<li>（1）函数体内的this对象，就是定义时所在的对象，而不是使用时所在的对象。</li>
</ul>
<p>箭头函数可以让this指向固定化，这种特性很有利于封装回调函数。下面是一个例子，DOM 事件的回调函数封装在一个对象里面。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> handler = &#123;</span><br><span class="line">  id: <span class="string">'123456'</span>,</span><br><span class="line"></span><br><span class="line">  init: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">document</span>.addEventListener(<span class="string">'click'</span>,</span><br><span class="line">      event =&gt; <span class="keyword">this</span>.doSomething(event.type), <span class="literal">false</span>);</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  doSomething: <span class="function"><span class="keyword">function</span>(<span class="params">type</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Handling '</span> + type  + <span class="string">' for '</span> + <span class="keyword">this</span>.id);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>上面代码的init方法中，使用了箭头函数，这导致这个箭头函数里面的this，总是指向handler对象。否则，回调函数运行时，this.doSomething这一行会报错，因为此时this指向document对象。</p>
<p>this指向的固定化，并不是因为箭头函数内部有绑定this的机制，实际原因是箭头函数根本没有自己的this，导致内部的this就是外层代码块的this。正是因为它没有this，所以也就不能用作构造函数。</p>
<h3 id="8-4-尾调用优化"><a href="#8-4-尾调用优化" class="headerlink" title="8.4. 尾调用优化"></a>8.4. 尾调用优化</h3><blockquote>
<p>我们知道，函数调用会在内存形成一个“调用记录”，又称“调用帧”（call frame），保存调用位置和内部变量等信息。如果在函数A的内部调用函数B，那么在A的调用帧上方，还会形成一个B的调用帧。等到B运行结束，将结果返回到A，B的调用帧才会消失。如果函数B内部还调用函数C，那就还有一个C的调用帧，以此类推。所有的调用帧，就形成一个“调用栈”（call stack）。</p>
</blockquote>
<blockquote>
<p>尾调用由于是函数的最后一步操作，所以不需要保留外层函数的调用帧，因为调用位置、内部变量等信息都不会再用到了，只要直接用内层函数的调用帧，取代外层函数的调用帧就可以了。</p>
</blockquote>
<p>一刷：<br><a href="http://es6.ruanyifeng.com/#docs/function" target="_blank" rel="noopener">http://es6.ruanyifeng.com/#docs/function</a></p>
<h2 id="13-Set和Map数据结构"><a href="#13-Set和Map数据结构" class="headerlink" title="13. Set和Map数据结构"></a>13. Set和Map数据结构</h2><h3 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h3><p><a href="https://es6.ruanyifeng.com/#docs/set-map" target="_blank" rel="noopener">https://es6.ruanyifeng.com/#docs/set-map</a></p>
<blockquote>
<p>Set本身是一个构造函数，用来生成Set数据结构。它类似于数组，但是成员的值都是唯一的，没有重复的值。</p>
</blockquote>
<p>【去重】</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> s = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>]);</span><br><span class="line"><span class="built_in">console</span>.log([...s]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> s = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>]);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Array</span>.from(s));</span><br></pre></td></tr></table></figure>

<p>【遍历】<br>keys()、values()、entries() 搭配 for…of</p>
<p>Set 结构的实例默认可遍历，它的默认遍历器生成函数就是它的values方法。<br>Set 结构的实例与数组一样，也拥有forEach方法，用于对每个成员执行某种操作，没有返回值。<br>数组的map和filter方法也可以间接用于 Set 了。</p>
<h3 id="WeakSet"><a href="#WeakSet" class="headerlink" title="WeakSet"></a>WeakSet</h3><p>WeakSet 结构与 Set 类似，也是不重复的值的集合。但是，它与 Set 有两个区别。 ES6 规定 WeakSet 不可遍历。</p>
<ul>
<li>WeakSet 的成员只能是对象，而不能是其他类型的值。</li>
<li>WeakSet 中的对象都是弱引用，即垃圾回收机制不考虑 WeakSet 对该对象的引用，也就是说，如果其他对象都不再引用该对象，那么垃圾回收机制会自动回收该对象所占用的内存，不考虑该对象还存在于 WeakSet 之中。</li>
</ul>
<h3 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h3><blockquote>
<p>Map也是构造函数，它类似于对象，也是键值对的集合，但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键。</p>
</blockquote>
<p>创建的由来不错：<br><a href="https://es6.ruanyifeng.com/#docs/set-map#%E5%90%AB%E4%B9%89%E5%92%8C%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95" target="_blank" rel="noopener">https://es6.ruanyifeng.com/#docs/set-map#%E5%90%AB%E4%B9%89%E5%92%8C%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95</a></p>
]]></content>
      <categories>
        <category>个人</category>
      </categories>
  </entry>
  <entry>
    <title>草稿</title>
    <url>/2019/11/20/draft/</url>
    <content><![CDATA[<p>【暂存死区】</p>
<p>【没有导致state的值发生变化的this.setState(）会导致重新渲染，原理是什么？是只要调setState了，没有做shouldComponentUpdate之类的判断就回导致渲染吗？】</p>
<p>【长列表】</p>
]]></content>
      <categories>
        <category>个人</category>
      </categories>
  </entry>
  <entry>
    <title>名言警句</title>
    <url>/2019/11/15/life/</url>
    <content><![CDATA[<ul>
<li><p>2019年11月15日 晴<br>你对生活付出多少，它就会让你过什么样的生活。</p>
</li>
<li><p>2019年11月20日 晴 冷<br>哪怕是房梁和屋檐把生活压的再低，但还是有另外一片生活的希望。</p>
</li>
<li><p>2019年11月21日  晴<br>命运所有的馈赠，早已暗中标了价格。</p>
</li>
<li><p>2019年12月09日 晴<br>每个人都在负重前行。</p>
</li>
<li><p>2019年12月18日 冷<br>《情商》</p>
</li>
<li><p>2020年05月25日 大雨<br>三十而立</p>
</li>
</ul>
]]></content>
      <categories>
        <category>个人</category>
      </categories>
      <tags>
        <tag>名言警句</tag>
      </tags>
  </entry>
  <entry>
    <title>Webpack 优化篇</title>
    <url>/2019/11/14/Webpack-majorization/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm init -y</span><br><span class="line">npm install webpack webpack-cli webpack-dev-server html-webpack-plugin css-loader style-loader mini-css-extract-plugin babel-loader @babel/core @babel/preset-env @babel/preset-react file-loader --save-dev</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install react react-dom --save-dev</span><br></pre></td></tr></table></figure>

<p>package.json</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">"scripts": &#123;</span><br><span class="line">  "dev": "webpack-dev-server --env=development",</span><br><span class="line">  "dev:build": "webpack --env=development",</span><br><span class="line">  "build": "webpack --env=production"</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<p>新建webpack.config.js</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> MiniCssExtractPlugin = <span class="built_in">require</span>(<span class="string">"mini-css-extract-plugin"</span>);</span><br><span class="line"><span class="keyword">const</span> HtmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">"html-webpack-plugin"</span>);</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">"path"</span>);</span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="params">mode</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    mode: mode, <span class="comment">// 这个env就是package.json script里面=后面传过来的值</span></span><br><span class="line">    entry: <span class="string">"./src/index.js"</span>, <span class="comment">// 入口</span></span><br><span class="line">    output: &#123;</span><br><span class="line">      filename: <span class="string">"bundle.js"</span>,</span><br><span class="line">      path: path.resolve(__dirname, <span class="string">"dist"</span>) <span class="comment">// 出口</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="built_in">module</span>: &#123;</span><br><span class="line">      rules: [</span><br><span class="line">        &#123;</span><br><span class="line">          test: <span class="regexp">/\.(png|jpe?g|gif)$/</span>,</span><br><span class="line">          use: <span class="string">"file-loader"</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          test: <span class="regexp">/\.js$/</span>,</span><br><span class="line">          use: &#123;</span><br><span class="line">              loader: <span class="string">"babel-loader"</span>,</span><br><span class="line">              options:&#123; <span class="comment">// .babelrc 也可以写在这个文件中</span></span><br><span class="line">                presets:[</span><br><span class="line">                    <span class="string">"@babel/preset-env"</span>,</span><br><span class="line">                    <span class="string">"@babel/preset-react"</span></span><br><span class="line">                ]</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          test: <span class="regexp">/\.css$/</span>,</span><br><span class="line">          use: [</span><br><span class="line">            mode !== <span class="string">"development"</span></span><br><span class="line">              ? MiniCssExtractPlugin.loader</span><br><span class="line">              : <span class="string">"style-loader"</span>,</span><br><span class="line">            <span class="string">"css-loader"</span></span><br><span class="line">          ]</span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;,</span><br><span class="line">    plugins: [</span><br><span class="line">      <span class="keyword">new</span> PurgecssPlugin(&#123;</span><br><span class="line">        paths: glob.sync(<span class="string">`<span class="subst">$&#123;path.join(__dirname, <span class="string">"src"</span>)&#125;</span>/**/*`</span>, &#123; <span class="attr">nodir</span>: <span class="literal">true</span> &#125;) <span class="comment">// 不匹配目录，只匹配文件</span></span><br><span class="line">      &#125;),</span><br><span class="line">      mode !== <span class="string">"development"</span> &amp;&amp;</span><br><span class="line">        <span class="keyword">new</span> MiniCssExtractPlugin(&#123;</span><br><span class="line">          filename: <span class="string">"css/[name].css"</span></span><br><span class="line">        &#125;),</span><br><span class="line">      <span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">        template: <span class="string">"./src/template.html"</span>,</span><br><span class="line">        filename: <span class="string">"index.html"</span></span><br><span class="line">      &#125;)</span><br><span class="line">    ].filter(<span class="built_in">Boolean</span>)</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="1-删除无用的Css样式"><a href="#1-删除无用的Css样式" class="headerlink" title="1.删除无用的Css样式"></a>1.删除无用的Css样式</h2><p>先来看编写的代码</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'./index.css'</span></span><br><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span>;</span><br><span class="line">ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>hello<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>,<span class="built_in">document</span>.getElementById(<span class="string">'root'</span>));</span><br></pre></td></tr></table></figure>

<p>index.css</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">body</span>&#123;</span><br><span class="line">    <span class="attribute">background</span>: red</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.class1</span>&#123;</span><br><span class="line">    <span class="attribute">background</span>: red</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install purgecss-webpack-plugin glob --save-dev</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这里的<code>.class1</code>显然是无用的，我们可以搜索<code>src</code>目录下的文件，删除无用的样式</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"><span class="keyword">const</span> glob = <span class="built_in">require</span>(<span class="string">'glob'</span>); <span class="comment">// 主要功能就是查找匹配的文件</span></span><br><span class="line"><span class="comment">// 主要的作用删除无意义的css，只能配合mini-css-extract-plugin使用</span></span><br><span class="line"><span class="keyword">const</span> PurgecssPlugin = <span class="built_in">require</span>(<span class="string">'purgecss-webpack-plugin'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 需要配合mini-css-extract-plugin插件</span></span><br><span class="line">mode !== <span class="string">"development"</span> &amp;&amp; <span class="keyword">new</span> PurgecssPlugin(&#123;</span><br><span class="line">    paths: glob.sync(<span class="string">`<span class="subst">$&#123;path.join(__dirname, <span class="string">"src"</span>)&#125;</span>/**/*`</span>, &#123; <span class="attr">nodir</span>: <span class="literal">true</span> &#125;) <span class="comment">// 不匹配目录，只匹配文件</span></span><br><span class="line">&#125;),</span><br></pre></td></tr></table></figure>

<p>编译 npm run build<br>可以看到 dist/css/main.css 中没有.class这个无用的样式</p>
<h2 id="2-图片压缩插件"><a href="#2-图片压缩插件" class="headerlink" title="2.图片压缩插件"></a>2.图片压缩插件</h2><p>将打包后的图片进行优化</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install image-webpack-loader --save-dev</span><br></pre></td></tr></table></figure>

<p>在file-loader之前使用压缩图片插件</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123; <span class="comment">// 降低分辨率 清晰度</span></span><br><span class="line">    test: <span class="regexp">/\.(png|jpe?g|gif)$/</span>,</span><br><span class="line">    use: [</span><br><span class="line">        &#123;</span><br><span class="line">            loader: <span class="string">'file-loader'</span></span><br><span class="line">        &#125;,</span><br><span class="line">        mode !== <span class="string">'development'</span> &amp;&amp; &#123;</span><br><span class="line">            <span class="comment">// 可以在使用file-loader之前 对图片进行压缩</span></span><br><span class="line">            loader: <span class="string">'image-webpack-loader'</span>,</span><br><span class="line">            options: &#123; <span class="comment">// nodejs.org =&gt; image-webpack-loader</span></span><br><span class="line">				mozjpeg: &#123;</span><br><span class="line">					progressive: <span class="literal">true</span>,</span><br><span class="line">					quality: <span class="number">65</span></span><br><span class="line">				&#125;,</span><br><span class="line">				<span class="comment">// optipng.enabled: false will disable optipng</span></span><br><span class="line">				optipng: &#123;</span><br><span class="line">					enabled: <span class="literal">false</span>,</span><br><span class="line">				&#125;,</span><br><span class="line">				pngquant: &#123;</span><br><span class="line">					quality: [<span class="number">0.65</span>, <span class="number">0.90</span>],</span><br><span class="line">					speed: <span class="number">4</span></span><br><span class="line">				&#125;,</span><br><span class="line">				gifsicle: &#123;</span><br><span class="line">					interlaced: <span class="literal">false</span>,</span><br><span class="line">				&#125;,</span><br><span class="line">				<span class="comment">// the webp option will enable WEBP</span></span><br><span class="line">				webp: &#123;</span><br><span class="line">					quality: <span class="number">75</span></span><br><span class="line">				&#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    ].filter(<span class="built_in">Boolean</span>)</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<blockquote>
<p>可以发现图片大小是有了明显的变化</p>
</blockquote>
<h2 id="3-CDN加载文件"><a href="#3-CDN加载文件" class="headerlink" title="3.CDN加载文件"></a>3.CDN加载文件</h2><p>我们希望通过cdn的方式引入资源</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install jquery --save</span><br></pre></td></tr></table></figure>

<p>index.js</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//import $ from 'jquery';</span></span><br><span class="line"><span class="built_in">console</span>.log($)</span><br></pre></td></tr></table></figure>

<p>全局引入cdn  <a href="https://www.bootcdn.cn/" target="_blank" rel="noopener">https://www.bootcdn.cn/</a></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- template.html --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdn.bootcss.com/jquery/3.4.1/jquery.min.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>但现在是在代码中还希望引入<code>jquery</code>来获得提示</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> $ <span class="keyword">from</span> <span class="string">'jquery'</span>; <span class="comment">// 注释打开， 使这个文件应该是cdn加载进来的，如下配置</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'$'</span>,$)</span><br></pre></td></tr></table></figure>

<p>但是打包时依然会将<code>jquery</code>进行打包<br>webpack.config.js配置如下</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">externals:&#123;</span><br><span class="line">    <span class="string">'jquery'</span>:<span class="string">'$'</span> <span class="comment">// 不去打包代码中的jquery，这个$代表文件中写的$，jquery代表文件中引入的这个jquery包</span></span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<p><strong>使用插件</strong><br>在配置文件中标注<code>jquery</code>是外部的，这样打包时就不会将jquery进行打包了，不用在html文件中引入cdn</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm i --save-dev add-asset-html-cdn-webpack-plugin  // (这个用的比较少)</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> AddAssetHtmlCdnPlugin = <span class="built_in">require</span>(<span class="string">'add-asset-html-cdn-webpack-plugin'</span>)</span><br><span class="line"><span class="keyword">new</span> AddAssetHtmlCdnPlugin(<span class="literal">true</span>,&#123;</span><br><span class="line">    <span class="string">'jquery'</span>:<span class="string">'https://cdn.bootcss.com/jquery/3.4.1/jquery.min.js'</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="4-Tree-shaking-amp-amp-Scope-Hoisting"><a href="#4-Tree-shaking-amp-amp-Scope-Hoisting" class="headerlink" title="4.Tree-shaking &amp;&amp; Scope-Hoisting"></a>4.Tree-shaking &amp;&amp; Scope-Hoisting</h2><h3 id="4-1-Tree-shaking"><a href="#4-1-Tree-shaking" class="headerlink" title="4.1 Tree-shaking"></a>4.1 Tree-shaking</h3><blockquote>
<p>tree-shaking 默认只支持 es6语法, 因为es6叫静态导入（import），像动态的导入（require(“”)）,这种可以放到if else里面，涉及到业务逻辑的，打包的时候是不知道是否需要打包的。</p>
</blockquote>
<p>顾名思义就是将没用的内容摇晃掉,来看下面代码</p>
<p><code>index.js</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; minus &#125; <span class="keyword">from</span> <span class="string">"./calc"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(minus(<span class="number">1</span>,<span class="number">1</span>));</span><br></pre></td></tr></table></figure>

<p><code>calc.js</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> sum = <span class="function">(<span class="params">a, b</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> a + b + <span class="string">'sum'</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> minus = <span class="function">(<span class="params">a, b</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> a - b + <span class="string">'minus'</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>观察上述代码其实我们主要使用<code>minus</code>方法, 没有使用<code>sum</code>方法</p>
</blockquote>
<p>本项目中使用的是webpack4,只需要将mode设置为production即可开启tree shaking</p>
<p>默认<code>mode:production</code>时 即生产环境下，会自动<code>tree-shaking</code>,但是打包后<code>sum</code>依然会被打印出来<br>在开发环境下默认<code>tree-shaking</code>不会生效,可以配置标识提示<br>webpack.base.js</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">optimization:&#123;</span><br><span class="line">  usedExports:<span class="literal">true</span> <span class="comment">// 配置了之后在开发模式下，打包生成的bundle文件中会有提示文字没有用sum这个模块，但是还是会打包出来</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="移除副作用"><a href="#移除副作用" class="headerlink" title="移除副作用"></a>移除副作用</h4><p><code>calc.js</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;test&#125; <span class="keyword">from</span> <span class="string">'./test'</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> sum = <span class="function">(<span class="params">a, b</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> a + b + <span class="string">'sum'</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> minus = <span class="function">(<span class="params">a, b</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> a - b + <span class="string">'minus'</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>test.js</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> test = <span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'hello'</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(test());</span><br></pre></td></tr></table></figure>

<p>可以看到上面calc.js中引入了test，但是没有用到test，test文件内部有他自己的业务逻辑。<br>副作用的代码可能在开发时是无意义的，但是webpack打包后<code>&#39;hello&#39;</code>还是会被打印出来。</p>
<p>在<code>package.json</code>中配置</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="string">"sideEffects"</span>:<span class="literal">false</span>, <span class="comment">// 表示不要副作用</span></span><br></pre></td></tr></table></figure>

<p>如果页面中引入的变量没有使用，就移除。</p>
<p><strong>注意</strong></p>
<p>如果这样设置，默认就不会导入<code>css</code>文件啦，因为我们引入css也是通过<code>import &#39;./style.css&#39;</code></p>
<p>这里重点就来了,<code>tree-shaking</code>主要针对<strong>es6模块</strong>,我们可以使用<code>require</code>语法导入css,但是这样用起来有点格格不入,所以我们可以配置<code>css</code>文件不是副作用<br>package.json文件：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="string">"sideEffects"</span>:[</span><br><span class="line">    <span class="string">"**/*.css"</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<ul>
<li>webpack配置目的：<br>1） 打包大小<br>2）打包速度<br>3）模块拆分</li>
</ul>
<h3 id="4-2-Scope-Hoisting"><a href="#4-2-Scope-Hoisting" class="headerlink" title="4.2 Scope Hoisting"></a>4.2 Scope Hoisting</h3><p>每个模块都是个函数，函数过多会导致内存过大，每调用一个函数都会产生一个作用域。<br>作用域提升,可以减少代码体积，节约内存</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">let</span> b = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">let</span> c = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">let</span> d = a+b+c</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> d;</span><br><span class="line"><span class="comment">// 引入d</span></span><br><span class="line"><span class="keyword">import</span> d <span class="keyword">from</span> <span class="string">'./d'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(d)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>最终打包后的结果会变成 <code>console.log(6)</code></p>
</blockquote>
<ul>
<li>代码量明显减少</li>
<li>减少多个函数后内存占用也将减少</li>
</ul>
<h2 id="5-DllPlugin-amp-amp-DllReferencePlugin"><a href="#5-DllPlugin-amp-amp-DllReferencePlugin" class="headerlink" title="5.DllPlugin &amp;&amp; DllReferencePlugin"></a>5.DllPlugin &amp;&amp; DllReferencePlugin</h2><p>一般用在开发环境下，dll功能：在开发之前就先抽离好 打好包，以后就不用打包了。<br>每次构建时第三方模块都需要重新构建，这个性能消耗比较大，我们可以先把第三方库打包成动态链接库，以后构建时只需要查找构建好的库就好了，这样可以大大节约构建时间</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span>;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>hello<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>,<span class="built_in">document</span>.getElementById(<span class="string">'root'</span>))</span><br></pre></td></tr></table></figure>

<h3 id="5-1-DllPlugin"><a href="#5-1-DllPlugin" class="headerlink" title="5.1 DllPlugin"></a>5.1 DllPlugin</h3><p>动态链接库</p>
<blockquote>
<p>这里我们可以先将<code>react</code>、<code>react-dom</code>单独进行打包</p>
</blockquote>
<p>单独打包创建<code>webpack.dll.js</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"><span class="keyword">const</span> DllPlugin = <span class="built_in">require</span>(<span class="string">'webpack/lib/DllPlugin'</span>); </span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    entry:[<span class="string">'react'</span>,<span class="string">'react-dom'</span>], <span class="comment">// 将第三方模块react，react-dom进行打包放到react.dll.js中</span></span><br><span class="line">    mode:<span class="string">'production'</span>,</span><br><span class="line">    output:&#123;</span><br><span class="line">        filename:<span class="string">'react.dll.js'</span>,</span><br><span class="line">        path:path.resolve(__dirname,<span class="string">'dll'</span>),</span><br><span class="line">        library:<span class="string">'react'</span>, <span class="comment">// 打包后接收自治性函数的名字叫react</span></span><br><span class="line">		libraryTarget: <span class="string">'var'</span>, <span class="comment">// 打包后默认用var模式接收 这个打包后的自执行函数，这里也可以写“commonjs”  “commonjs2” “umd”  “this”...</span></span><br><span class="line">    &#125;,</span><br><span class="line">    plugins:[</span><br><span class="line">        <span class="keyword">new</span> DllPlugin(&#123;</span><br><span class="line">            name:<span class="string">'react'</span>,</span><br><span class="line">            path:path.resolve(__dirname,<span class="string">'dll/manifest.json'</span>)<span class="comment">// 生成一个缓存列表</span></span><br><span class="line">        &#125;)</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行<code>&quot;webpack --config webpack.dll.js</code>命令，可以看到dll目录下创建了两个文件分别是<code>manifest.json</code>,<code>react.dll.js</code></p>
<p>本地使用了import React 这样的语法，需要先去 manifest.json查找，找到后会加载对应的库的名字,可能会引用某个模块,会去.dll.js文件中查找</p>
<h3 id="5-2-DllReferencePlugin"><a href="#5-2-DllReferencePlugin" class="headerlink" title="5.2 DllReferencePlugin"></a>5.2 DllReferencePlugin</h3><p>现在我们的项目中可以引用刚才打包好的动态链接库</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install add-asset-html-webpack-plugin --save-dev</span><br></pre></td></tr></table></figure>

<p>webpack.config.js</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> DllReferencePlugin = <span class="built_in">require</span>(<span class="string">'webpack/lib/DllReferencePlugin'</span>);</span><br><span class="line"><span class="keyword">const</span> AddAssetHtmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">'add-asset-html-webpack-plugin'</span>);</span><br><span class="line"><span class="comment">// 构建时会引用动态链接库的内容</span></span><br><span class="line"><span class="keyword">new</span> DllReferencePlugin(&#123;</span><br><span class="line">  manifest:path.resolve(__dirname,<span class="string">'dll/manifest.json'</span>)</span><br><span class="line">&#125;),</span><br><span class="line"><span class="comment">// 需要手动引入react.dll.js</span></span><br><span class="line"><span class="keyword">new</span> AddAssetHtmlWebpackPlugin(</span><br><span class="line">  &#123; <span class="attr">filepath</span>: path.resolve(__dirname,<span class="string">'dll/react.dll.js'</span>) &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>使用DllPlugin可以大幅度提高构建速度</p>
<h2 id="6-动态加载"><a href="#6-动态加载" class="headerlink" title="6.动态加载"></a>6.动态加载</h2><p>实现点击后动态加载文件</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> btn = <span class="built_in">document</span>.createElement(<span class="string">'button'</span>);</span><br><span class="line">btn.innerHTML = <span class="string">'点击加载视频'</span>;</span><br><span class="line">btn.addEventListener(<span class="string">'click'</span>,()=&gt;&#123;</span><br><span class="line">    <span class="comment">// 动态导入 类比 路由的懒加载 import语法</span></span><br><span class="line">	<span class="comment">// import() 和 import是两个东西</span></span><br><span class="line">	<span class="comment">// import()返回的是一个promise</span></span><br><span class="line">    <span class="keyword">import</span>(<span class="string">'./video'</span>).then(<span class="function"><span class="params">res</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(res.default);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">document</span>.body.appendChild(btn);</span><br></pre></td></tr></table></figure>

<p>这就是懒加载原理，webpack会默认把 这样<code>import(&#39;./video&#39;)</code> 的语法单独打包成一个文件，等点击的时候会使用jsonp动态的去加载这个文件<br>可以实现代码分割</p>
<p>给动态引入的文件增加名字</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">output:&#123;</span><br><span class="line">   filename:<span class="string">'bundle.js'</span>, <span class="comment">// 同步打包的名字</span></span><br><span class="line">  chunkFilename:<span class="string">'[name].min.js'</span>, <span class="comment">// 异步打包的名字，[name]默认从0开始</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 也可以自定义 如下：</span></span><br><span class="line"><span class="keyword">import</span>(<span class="comment">/* webpackChunkName: "video" */</span> <span class="string">'./video'</span>).then(<span class="function"><span class="params">res</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res.default);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>这样打包后的结果最终的文件就是 <code>video.min.js</code></p>
<blockquote>
<p>原理就是 <code>jsonp</code> 动态导入，动态创建 <code>script</code> 标签 去加载这个文件。</p>
</blockquote>
<h2 id="7-打包文件分析工具"><a href="#7-打包文件分析工具" class="headerlink" title="7.打包文件分析工具"></a>7.打包文件分析工具</h2><p>可以分析打包后的代码依赖关系，包括打包的大小。</p>
<p>安装 <code>webpack-bundle-analyzer</code>插件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install --save-dev webpack-bundle-analyzer</span><br></pre></td></tr></table></figure>

<p>使用插件</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123;BundleAnalyzerPlugin&#125; = <span class="built_in">require</span>(<span class="string">'webpack-bundle-analyzer'</span>);</span><br><span class="line">mode !== <span class="string">"development"</span> &amp;&amp; <span class="keyword">new</span> BundleAnalyzerPlugin()</span><br></pre></td></tr></table></figure>

<p>默认就会展现当前应用的分析图表</p>
<h2 id="8-SplitChunks"><a href="#8-SplitChunks" class="headerlink" title="8.SplitChunks"></a>8.SplitChunks</h2><blockquote>
<p>这是webpack自身的一个配置，基本上每个开发者都会用到，它可以在生产环境下帮我们把很多的第三方包进行分离。<br>dllPlugin 不要和 splitChunks 共同使用，一般会先走dllPlugin，就不会走splitChunks。</p>
</blockquote>
<p>我们在来看下SplitChunks这个配置，他可以在编译时抽离第三方模块、公共模块</p>
<p>将项目配置成多入口文件</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">entry:&#123;</span><br><span class="line">  a:<span class="string">'./src/a.js'</span>,</span><br><span class="line">  b:<span class="string">'./src/b.js'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们让a,b两个模块同时引用<code>jquery</code>,别忘了去掉之前的<code>externals</code>配置</p>
<p><img src="http://img.fullstackjavascript.cn/analyze-1.png" alt></p>
<p>如上所示，同样的 jquery被打包了2次</p>
<ul>
<li>抽离第三方模块<br>1）不要和业务逻辑放在一起<br>2）增加缓存</li>
</ul>
<p>配置<code>SplitChunks</code>插件</p>
<p>配置在此，已做部分修改，默认配置可在<a href="https://npmjs.com" target="_blank" rel="noopener">https://npmjs.com</a> 上自行查找。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">optimization:&#123;</span><br><span class="line">	splitChunks: &#123;</span><br><span class="line">	<span class="comment">// initial 只操作同步的，all 所有的，async异步的（默认）</span></span><br><span class="line">	  chunks: <span class="string">'async'</span>, <span class="comment">// 默认支持异步的代码分割import()</span></span><br><span class="line">	  minSize: <span class="number">30000</span>, <span class="comment">// 文件超过30k 就会抽离</span></span><br><span class="line">	  maxSize: <span class="number">0</span>,  <span class="comment">// 没有最大上限</span></span><br><span class="line">	  minChunks: <span class="number">1</span>, <span class="comment">// 最少模块引用一次才抽离</span></span><br><span class="line">	  maxAsyncRequests: <span class="number">5</span>, <span class="comment">// 最大异步请求数，最多5个</span></span><br><span class="line">	  maxInitialRequests: <span class="number">3</span>, <span class="comment">// 最大初始化请求数，即最多首屏加载3个请求</span></span><br><span class="line">	  automaticNameDelimiter: <span class="string">'~'</span>, <span class="comment">// 抽离的命名分隔符 xxx~a~b (如果是a、b文件引用)</span></span><br><span class="line">	  automaticNameMaxLength: <span class="number">30</span>, <span class="comment">// 名字最大长度</span></span><br><span class="line">	  name: <span class="literal">true</span>,</span><br><span class="line">	  cacheGroups: &#123; <span class="comment">// 缓存组  这里面也可以配置上面的配置</span></span><br><span class="line">		vendors: &#123; <span class="comment">// 先抽离第三方</span></span><br><span class="line">		  test: <span class="regexp">/[\\/]node_modules[\\/](jquery)|(loadsh)/</span>,</span><br><span class="line">		  priority: <span class="number">-1</span></span><br><span class="line">		&#125;,</span><br><span class="line">		react:&#123;</span><br><span class="line">			test: <span class="regexp">/[\\/]node_modules[\\/](react|react-dom)/</span>,</span><br><span class="line">			priority: <span class="number">-2</span>, </span><br><span class="line">		&#125;,</span><br><span class="line">		<span class="keyword">default</span>: &#123; </span><br><span class="line">		  minChunks: <span class="number">2</span>,</span><br><span class="line">		  priority: <span class="number">-20</span>, <span class="comment">// 优先级, -2比 -20大</span></span><br><span class="line">		  reuseExistingChunk: <span class="literal">true</span></span><br><span class="line">		&#125;</span><br><span class="line">	  &#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>我们将<code>async</code>改为<code>initial</code></p>
</blockquote>
<p><img src="http://img.fullstackjavascript.cn/analyze-2.png" alt></p>
<p>可以看到jquery 被单独打包出来了。</p>
<p><strong>注意</strong><br>我们再为每个文件动态导入<code>lodash</code>库,并且改成<code>async</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span>(<span class="string">'lodash'</span>)</span><br></pre></td></tr></table></figure>

<p><img src="http://img.fullstackjavascript.cn/analyze-3.png" alt></p>
<p>可以看到现在配置的是异步代码分割，同步的jquery还是分别在a、b中打包了,而异步引入的 loader 被抽离出来打包。</p>
<p><strong>注意</strong><br>现在为每个入口引入<code>c.js</code>,并且改造配置文件</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">splitChunks: &#123;</span><br><span class="line">  chunks: <span class="string">'all'</span>, <span class="comment">// 不管异步同步 全部抽离</span></span><br><span class="line">  name: <span class="literal">true</span>,</span><br><span class="line">  cacheGroups: &#123;</span><br><span class="line">    vendors: &#123;</span><br><span class="line">      test: <span class="regexp">/[\\/]node_modules[\\/]/</span>,</span><br><span class="line">      priority: <span class="number">-10</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="keyword">default</span>: &#123;</span><br><span class="line">      minSize:<span class="number">1</span>, <span class="comment">// 这里将大小改成1，表示大于1，并且如下的minChunks最少引用2次就会被抽离打包，不是第三方模块，被引入两次也会被抽离</span></span><br><span class="line">      minChunks: <span class="number">2</span>,</span><br><span class="line">      priority: <span class="number">-20</span>,</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="http://img.fullstackjavascript.cn/analyze-4.png" alt></p>
<h2 id="9-热更新"><a href="#9-热更新" class="headerlink" title="9.热更新"></a>9.热更新</h2><p>模块热替换（HMR - Hot Module Replacement）是 webpack 提供的最有用的功能之一。它允许在运行时替换，添加，删除各种模块，而无需进行完全刷新重新加载整个页面</p>
<ul>
<li>保留在完全重新加载页面时丢失的应用程序的状态</li>
<li>只更新改变的内容，以节省开发时间</li>
<li>调整样式更加快速，几乎等同于就在浏览器调试器中更改样式</li>
</ul>
<p>启用热更新，默认样式可以支持热更新，如果不支持热更新则采用强制刷新</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">devServer:&#123;</span><br><span class="line">  hot:<span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">new</span> webpack.NamedModulesPlugin(),</span><br></pre></td></tr></table></figure>

<p>让<code>js</code>支持热更新</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sum <span class="keyword">from</span> <span class="string">'./sum'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(sum(<span class="number">1</span>,<span class="number">2</span>));</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">module</span>.hot)&#123; <span class="comment">// 如果支持热更新</span></span><br><span class="line">    <span class="built_in">module</span>.hot.accept(); <span class="comment">// 当入口文件变化后重新执行当前入口文件</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="10-IgnorePlugin"><a href="#10-IgnorePlugin" class="headerlink" title="10.IgnorePlugin"></a>10.IgnorePlugin</h2><p>忽略 <code>import</code>和<code>require</code>语法</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> webpack.IgnorePlugin(<span class="regexp">/^\.\/locale$/</span>, /moment$/)</span><br></pre></td></tr></table></figure>

<h2 id="11-费时分析"><a href="#11-费时分析" class="headerlink" title="11.费时分析"></a>11.费时分析</h2><p>可以计算每一步执行的运行速度</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> SpeedMeasureWebpackPlugin = <span class="built_in">require</span>(<span class="string">'speed-measure-webpack-plugin'</span>);</span><br><span class="line"><span class="keyword">const</span> smw = <span class="keyword">new</span> SpeedMeasureWebpackPlugin();</span><br><span class="line">  <span class="built_in">module</span>.exports =smw.wrap(&#123;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h2 id="12-noParse"><a href="#12-noParse" class="headerlink" title="12.noParse"></a>12.noParse</h2><p><code>module.noParse</code>，对类似jq这类依赖库，内部不会引用其他库，我们在打包的时候就没有必要去解析，这样能够增加打包速率</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">noParse:<span class="regexp">/jquery/</span></span><br></pre></td></tr></table></figure>

<h2 id="13-resolve"><a href="#13-resolve" class="headerlink" title="13.resolve"></a>13.resolve</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">resolve: &#123;</span><br><span class="line">  extensions: [<span class="string">".js"</span>,<span class="string">".jsx"</span>,<span class="string">".json"</span>,<span class="string">".css"</span>],</span><br><span class="line">  alias:&#123;&#125;,</span><br><span class="line">  modules:[<span class="string">'node_modules'</span>]</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<h2 id="14-include-exclude"><a href="#14-include-exclude" class="headerlink" title="14.include/exclude"></a>14.include/exclude</h2><p>在使用<code>loader</code>时,可以指定哪些文件不通过<code>loader</code>,或者指定哪些文件通过<code>loader</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  test: <span class="regexp">/\.js$/</span>,</span><br><span class="line">  use: <span class="string">"babel-loader"</span>,</span><br><span class="line">  <span class="comment">// include:path.resolve(__dirname,'src'),</span></span><br><span class="line">  exclude:<span class="regexp">/node_modules/</span></span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<h2 id="15-happypack"><a href="#15-happypack" class="headerlink" title="15.happypack"></a>15.happypack</h2><p>多线程打包，我们可以将不同的逻辑交给不同的线程来处理</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install --save-dev happypack</span><br></pre></td></tr></table></figure>

<p>使用插件</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> HappyPack = <span class="built_in">require</span>(<span class="string">'happypack'</span>);</span><br><span class="line">rules:[</span><br><span class="line">  &#123;</span><br><span class="line">    test: <span class="regexp">/\.js$/</span>,</span><br><span class="line">    use: <span class="string">'happypack/loader?id=jsx'</span></span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  &#123;</span><br><span class="line">    test: <span class="regexp">/\.less$/</span>,</span><br><span class="line">    use: <span class="string">'happypack/loader?id=styles'</span></span><br><span class="line">  &#125;,</span><br><span class="line">]</span><br><span class="line"><span class="keyword">new</span> HappyPack(&#123;</span><br><span class="line">  id: <span class="string">'jsx'</span>,</span><br><span class="line">  threads: <span class="number">4</span>,</span><br><span class="line">  loaders: [ <span class="string">'babel-loader'</span> ]</span><br><span class="line">&#125;),</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> HappyPack(&#123;</span><br><span class="line">  id: <span class="string">'styles'</span>,</span><br><span class="line">  threads: <span class="number">2</span>,</span><br><span class="line">  loaders: [ <span class="string">'style-loader'</span>, <span class="string">'css-loader'</span>, <span class="string">'less-loader'</span> ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Webpack</category>
      </categories>
      <tags>
        <tag>Webpack</tag>
      </tags>
  </entry>
  <entry>
    <title>Webpack 基础篇 （三）</title>
    <url>/2019/11/13/Webpack-js/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>需要把es6 转化成 es5，涉及到 有些api 不是es6语法，装饰器、类的属性…</p>
<p>babel 转化功能 vue-cli 基于babel6来实现的<br>现在的讲是babel7</p>
<h2 id="1-处理js模块"><a href="#1-处理js模块" class="headerlink" title="1. 处理js模块"></a>1. 处理js模块</h2><h3 id="1-1-将-es6-编译成-es5"><a href="#1-1-将-es6-编译成-es5" class="headerlink" title="1.1 将 es6 编译成 es5"></a>1.1 将 es6 编译成 es5</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install @babel/core @babel/preset-env babel-loader --save-dev</span><br></pre></td></tr></table></figure>

<p><code>@babel/core</code>是babel中的核心模块，<code>@babel/preset-env</code> 的作用是es6转化es5插件的插件集合，<code>babel-loader</code>是<code>webpack</code>和<code>loader</code>的桥梁。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// es6 语法</span></span><br><span class="line"><span class="keyword">const</span> sum = <span class="function">(<span class="params">a, b</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>webpack.base.js</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    test: <span class="regexp">/\.js$/</span>,</span><br><span class="line">    use: <span class="string">'babel-loader'</span> <span class="comment">//babel-loader默认会调@babel-core(可以直接在这里设置options,如果配置内容太多 也可以新建配置文件.babelrc)</span></span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<p>新建 .babelrc , 这个文件就是options里面的内容</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">"presets"</span>: [ <span class="comment">// 这里的执行顺序是从下往上</span></span><br><span class="line">        <span class="string">"@babel/preset-env"</span></span><br><span class="line">    ],</span><br><span class="line">    <span class="string">"plugins"</span>: [] <span class="comment">//这里也可以写其他的插件，执行顺序是从上往下</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-2-解析装饰器"><a href="#1-2-解析装饰器" class="headerlink" title="1.2 解析装饰器"></a>1.2 解析装饰器</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm i @babel/plugin-proposal-class-properties @babel/plugin-proposal-decorators --save-dev</span><br></pre></td></tr></table></figure>

<p>.babelrc</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">"plugins": [</span><br><span class="line">  ["@babel/plugin-proposal-decorators", &#123; "legacy": true &#125;], // 解析装饰器</span><br><span class="line">  ["@babel/plugin-proposal-class-properties",&#123;"loose":true&#125;] // 解析类的属性</span><br><span class="line">]</span><br><span class="line">// 这些都是实验性语法 查看用法 https://babeljs.io =&gt; 搜索</span><br></pre></td></tr></table></figure>

<p><code>legacy:true</code>表示继续使用装饰器装饰器，loose为false时会采用<code>Object.defineProperty</code>定义属性</p>
<ul>
<li>Plugin会运行在Preset之前</li>
<li>Plugin 会从第一个开始顺序执行，Preset则是相反的</li>
</ul>
<h3 id="1-3-corejs-替代-polyfill-已废弃"><a href="#1-3-corejs-替代-polyfill-已废弃" class="headerlink" title="1.3 corejs 替代 polyfill(已废弃)"></a>1.3 corejs 替代 polyfill(已废弃)</h3><p><strong>示例</strong><br>index.tsx</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>].includes(<span class="number">1</span>) <span class="comment">// 这个是es7语法</span></span><br></pre></td></tr></table></figure>

<p>npm run build 打包 ，没有转化</p>
<blockquote>
<p>默认不能转化高级语法 实例上的语法 promise（api也不转化）</p>
</blockquote>
<p>或者是 根据<code>.browserslistrc</code>文件，转化使用到的浏览器api<br><strong>解决</strong><br>.babelrc</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="string">"presets"</span>: [</span><br><span class="line">    [<span class="string">"@babel/preset-env"</span>,&#123;</span><br><span class="line">		<span class="comment">// 使用的api会自动转化</span></span><br><span class="line">        <span class="string">"useBuiltIns"</span>:<span class="string">"usage"</span>, <span class="comment">// 按需加载</span></span><br><span class="line">        <span class="string">"corejs"</span>:<span class="number">2</span> <span class="comment">// corejs 替代了以前的pollyfill</span></span><br><span class="line">    &#125;]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>安装corejs</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install core-js --save</span><br></pre></td></tr></table></figure>

<h3 id="1-4-transform-runtime"><a href="#1-4-transform-runtime" class="headerlink" title="1.4 transform-runtime"></a>1.4 transform-runtime</h3><blockquote>
<p><strong>使用<code>transform-runtime</code></strong><br>A plugin that enables the re-use of Babel’s injected helper code to save on codesize.可以帮我们节省代码</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install --save-dev @babel/plugin-transform-runtime</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install --save @babel/runtime</span><br></pre></td></tr></table></figure>

<p>在<code>.babelrc</code>中配置插件，完整代码如下:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">"presets"</span>: [ <span class="comment">// 这里的执行顺序是从下往上</span></span><br><span class="line">        [<span class="string">"@babel/preset-env"</span>,&#123;</span><br><span class="line">            <span class="comment">// 使用的api会自动转化</span></span><br><span class="line">            <span class="string">"useBuiltIns"</span>:<span class="string">"usage"</span>, <span class="comment">// 按需加载</span></span><br><span class="line">            <span class="string">"corejs"</span>:<span class="number">3</span> <span class="comment">// 3代表版本号 corejs 替代了以前的pollyfill</span></span><br><span class="line">        &#125;]</span><br><span class="line">    ],</span><br><span class="line">    <span class="string">"plugins"</span>: [<span class="comment">//这里也可以写其他的插件，执行顺序是从上往下</span></span><br><span class="line">        [<span class="string">"@babel/plugin-proposal-decorators"</span>, &#123; <span class="string">"legacy"</span>: <span class="literal">true</span> &#125;], <span class="comment">// 解析装饰器</span></span><br><span class="line">        [<span class="string">"@babel/plugin-proposal-class-properties"</span>,&#123;<span class="string">"loose"</span>:<span class="literal">true</span>&#125;], <span class="comment">// 解析类的属性</span></span><br><span class="line">        <span class="string">"@babel/plugin-transform-runtime"</span></span><br><span class="line">    ] </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-5-添加eslint"><a href="#1-5-添加eslint" class="headerlink" title="1.5 添加eslint"></a>1.5 添加eslint</h3><p>安装<code>eslint</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install eslint</span><br><span class="line">npx eslint --init <span class="comment"># 初始化配置文件</span></span><br></pre></td></tr></table></figure>

<h2 id="2-source-map"><a href="#2-source-map" class="headerlink" title="2.source-map"></a>2.source-map</h2><ul>
<li>eval 生成代码 每个模块都被eval执行,每一个打包后的模块后面都增加了包含sourceURL</li>
<li>source-map 产生map文件</li>
<li>inline 不会生成独立的 .map文件,会以dataURL形式插入</li>
<li>cheap 忽略打包后的列信息，不使用loader中的sourcemap</li>
<li>module 没有列信息，使用loader中的sourcemap(没有列信息)</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">devtool:isDev?<span class="string">'cheap-module-eval-source-map'</span>:<span class="literal">false</span></span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    test:/\.js/,</span><br><span class="line">    enforce:&apos;pre&apos;,</span><br><span class="line">    use:&apos;eslint-loader&apos;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<blockquote>
<p>配置<code>eslint-loader</code>可以实时校验js文件的正确性,<code>pre</code>表示在所有<code>loader</code>执行前执行</p>
</blockquote>
<p><a href https: segmentfault.com a 1190000008315937"">Webpack中的sourcemap</a></p>
<h2 id="3-resolve解析"><a href="#3-resolve解析" class="headerlink" title="3.resolve解析"></a>3.resolve解析</h2><p>想实现使用require或是import的时候,可以自动尝试添加扩展名进行匹配</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">resolve: &#123;</span><br><span class="line">    extensions: [<span class="string">".js"</span>, <span class="string">".jsx"</span>, <span class="string">".json"</span>, <span class="string">".css"</span>, <span class="string">".ts"</span>, <span class="string">".tsx"</span>, <span class="string">".vue"</span>]</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<h2 id="4-拷贝静态文件"><a href="#4-拷贝静态文件" class="headerlink" title="4.拷贝静态文件"></a>4.拷贝静态文件</h2><p>有些时候在打包时希望将一些静态资源文件进行拷贝,可以使用<code>copy-webpack-plugin</code></p>
<p>安装插件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm i copy-webpack-plugin --save-dev</span><br></pre></td></tr></table></figure>

<h2 id="5-配置TS环境"><a href="#5-配置TS环境" class="headerlink" title="5.配置TS环境"></a>5.配置TS环境</h2><h3 id="5-1-使用ts-loader"><a href="#5-1-使用ts-loader" class="headerlink" title="5.1 使用ts-loader"></a>5.1 使用ts-loader</h3><p>使用<code>ts</code>需要安装<code>ts</code>相关配置</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install typescript ts-loader --save-dev</span><br></pre></td></tr></table></figure>

<p>生成<code>ts</code>的配置文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npx tsc --init</span><br></pre></td></tr></table></figure>

<p>配置<code>ts-loader</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    test:<span class="regexp">/\.tsx?/</span>,</span><br><span class="line">    use: [<span class="string">'ts-loader'</span>],</span><br><span class="line">    exclude: <span class="regexp">/node_modules/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将入口文件更改成<code>ts</code>文件</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a:string = <span class="string">'hello'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a);</span><br></pre></td></tr></table></figure>

<p>执行<code>npm run dev</code>发现已经可以正常的解析<code>ts</code>文件啦！</p>
<h3 id="5-2-使用-preset-typescript"><a href="#5-2-使用-preset-typescript" class="headerlink" title="5.2 使用 preset-typescript"></a>5.2 使用 preset-typescript</h3><p>不需要借助<code>typescript</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install @babel/preset-typescript</span><br></pre></td></tr></table></figure>

<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"presets"</span>: [</span><br><span class="line">       [<span class="string">"@babel/preset-env"</span>,&#123;</span><br><span class="line">        <span class="attr">"useBuiltIns"</span>:<span class="string">"usage"</span>,</span><br><span class="line">        <span class="attr">"corejs"</span>:<span class="number">2</span> </span><br><span class="line">       &#125;],</span><br><span class="line">       <span class="string">"@babel/preset-react"</span>,</span><br><span class="line">       [<span class="string">"@babel/preset-typescript"</span>,&#123;</span><br><span class="line">           <span class="attr">"allExtensions"</span>: <span class="literal">true</span>  </span><br><span class="line">       &#125;]</span><br><span class="line">    ],</span><br><span class="line">    <span class="attr">"plugins"</span>: [</span><br><span class="line">        [<span class="string">"@babel/plugin-proposal-decorators"</span>, &#123; <span class="attr">"legacy"</span>: <span class="literal">true</span> &#125;],</span><br><span class="line">        [<span class="string">"@babel/plugin-proposal-class-properties"</span>,&#123;<span class="attr">"loose"</span>:<span class="literal">true</span>&#125;],</span><br><span class="line">        <span class="string">"@babel/plugin-transform-runtime"</span></span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="6-配置ts-react环境"><a href="#6-配置ts-react环境" class="headerlink" title="6.配置ts+react环境"></a>6.配置ts+react环境</h2><p>安装<code>react</code>相关模块</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install react react-dom --save</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm i @babel/preset-react --save-dev <span class="comment"># 解析jsx语法</span></span><br></pre></td></tr></table></figure>

<p>配置 .bablrc</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">"presets"</span>: [</span><br><span class="line">        [<span class="string">"@babel/preset-env"</span>,&#123;</span><br><span class="line">            <span class="string">"useBuiltIns"</span>:<span class="string">"usage"</span>, </span><br><span class="line">            <span class="string">"corejs"</span>:<span class="number">2</span></span><br><span class="line">        &#125;],</span><br><span class="line">        <span class="string">"@babel/preset-react"</span> <span class="comment">// 顺序从下往上 先走解析react</span></span><br><span class="line">    ],</span><br><span class="line">    <span class="string">"plugins"</span>: [</span><br><span class="line">        [<span class="string">"@babel/plugin-proposal-decorators"</span>, &#123; <span class="string">"legacy"</span>: <span class="literal">true</span> &#125;],</span><br><span class="line">        [<span class="string">"@babel/plugin-proposal-class-properties"</span>,&#123;<span class="string">"loose"</span>:<span class="literal">true</span>&#125;],</span><br><span class="line">        <span class="string">"@babel/plugin-transform-runtime"</span></span><br><span class="line">    ] </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>index.tsx</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDom <span class="keyword">from</span> <span class="string">'react-dom'</span>;</span><br><span class="line"></span><br><span class="line">ReactDom.render(<span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>hello<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>,<span class="built_in">document</span>.getElementById(<span class="string">'root'</span>));</span><br></pre></td></tr></table></figure>

<p>运行 npm run dev<br>访问 <a href="http://localhost:3000/" target="_blank" rel="noopener">http://localhost:3000/</a> 页面显示hello</p>
<h3 id="typescript"><a href="#typescript" class="headerlink" title="typescript"></a>typescript</h3><p>校验类型<br>index.tsx</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span>;</span><br><span class="line"><span class="comment">// ts 校验类型</span></span><br><span class="line"><span class="keyword">interface</span> IProps&#123;</span><br><span class="line">    num:<span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> initState = &#123;count:<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">type</span> State = Readonly&lt;<span class="keyword">typeof</span> initState&gt;</span><br><span class="line"><span class="keyword">class</span> Counter <span class="keyword">extends</span> React.Component&lt;IProps,State&gt;&#123;</span><br><span class="line">    state:State = initState;</span><br><span class="line">    handleClick = <span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.setState(&#123;count:<span class="keyword">this</span>.state.count+<span class="number">1</span>&#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    render()&#123;</span><br><span class="line">        <span class="keyword">return</span> &lt;div&gt;</span><br><span class="line">            &#123;<span class="keyword">this</span>.state.count&#125;</span><br><span class="line">            &lt;button onClick=&#123;<span class="keyword">this</span>.handleClick&#125;&gt;点击&lt;<span class="regexp">/button&gt;            </span></span><br><span class="line"><span class="regexp">        &lt;/</span>div&gt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">ReactDOM.render(&lt;Counter num=&#123;<span class="number">1</span>&#125;/&gt;,<span class="built_in">document</span>.getElementById(<span class="string">'root'</span>));</span><br></pre></td></tr></table></figure>

<p>解析ts的方案<br>1、ts-loader + typescript库<br>2、babel7下的 @babel/preset-typescript</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm i @babel/preset-typescript --save-dev</span><br></pre></td></tr></table></figure>

<p>将 webpack.base.js中 入口文件 <code>&#39;/src/index.js&#39;</code> 改成 <code>&#39;/src/index.tsx&#39;</code><br>module 里的 rules 再添加一项：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    test: <span class="regexp">/\.tsx?$/</span>,</span><br><span class="line">    use: <span class="string">'babel-loader'</span></span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<p>.babelrc</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">"presets"</span>: [</span><br><span class="line">        [<span class="string">"@babel/preset-env"</span>,&#123;</span><br><span class="line">            <span class="string">"useBuiltIns"</span>:<span class="string">"usage"</span>, </span><br><span class="line">            <span class="string">"corejs"</span>:<span class="number">2</span> </span><br><span class="line">        &#125;],</span><br><span class="line">        <span class="string">"@babel/preset-react"</span>,</span><br><span class="line">        <span class="string">"@babel/preset-typescript"</span> <span class="comment">// ****加了这行 先把ts转成js</span></span><br><span class="line">    ],</span><br><span class="line">    <span class="string">"plugins"</span>: [</span><br><span class="line">        [<span class="string">"@babel/plugin-proposal-decorators"</span>, &#123; <span class="string">"legacy"</span>: <span class="literal">true</span> &#125;],</span><br><span class="line">        [<span class="string">"@babel/plugin-proposal-class-properties"</span>,&#123;<span class="string">"loose"</span>:<span class="literal">true</span>&#125;],</span><br><span class="line">        <span class="string">"@babel/plugin-transform-runtime"</span></span><br><span class="line">    ] </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行 npm run dev 可以看到 页面上生成一个按钮，点击按钮数字+1</p>
<h4 id="安装typescript-校验代码"><a href="#安装typescript-校验代码" class="headerlink" title="安装typescript 校验代码"></a>安装typescript 校验代码</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install typescript</span><br></pre></td></tr></table></figure>

<p>生成 typescript 配置文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tsc --init</span><br></pre></td></tr></table></figure>

<p>生成 tsconfig.json 文件<br>这时看 index.tsx 可以看到有许多保存，需要安装校验文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm i @types/react @types/react-dom --save</span><br></pre></td></tr></table></figure>

<p>打开 tsconfig.json </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># line10 将注释打开 改成</span></span><br><span class="line">// <span class="string">"jsx"</span>: <span class="string">"preserve"</span>,   /* Specify JSX code generation: <span class="string">'preserve'</span>, <span class="string">'react-native'</span>, or <span class="string">'react'</span>. */  </span><br><span class="line"><span class="string">"jsx"</span>: <span class="string">"react"</span>,</span><br></pre></td></tr></table></figure>

<h2 id="7-配置ts-vue环境"><a href="#7-配置ts-vue环境" class="headerlink" title="7.配置ts+vue环境"></a>7.配置ts+vue环境</h2><p>安装<code>vue</code>所需要的模块</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install vue --save</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install vue-loader  vue-template-compiler --save-dev</span><br></pre></td></tr></table></figure>

<p>vue-template-compiler 是用来解析.vue文件中的 &lt;template<br>vue-loader 是用来调取 vue-template-compiler的</p>
<p>使用<code>vue-loader</code>插件</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> VueLoaderPlugin = <span class="built_in">require</span>(<span class="string">'vue-loader/lib/plugin'</span>);</span><br><span class="line"><span class="keyword">new</span> VueLoaderPlugin();</span><br></pre></td></tr></table></figure>

<p>配置解析<code>.vue</code>文件</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    test:<span class="regexp">/\.vue$/</span>,</span><br><span class="line">    use:<span class="string">'vue-loader'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>新建<code>vue-shims.d.ts</code>（这个文件名后缀必须为 .d.ts），可以识别<code>.vue</code>文件，这样就可以引入 .vue的文件了。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">declare module &apos;*.vue&apos; &#123;</span><br><span class="line">    import Vue from &apos;vue&apos;;</span><br><span class="line">    export default Vue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>index.tsx</code>文件</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span>;</span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">'./App.vue'</span>; <span class="comment">// 这里就可以引入.vue后缀的文件了</span></span><br><span class="line"><span class="keyword">let</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    render:<span class="function"><span class="params">h</span>=&gt;</span>h(App)</span><br><span class="line">&#125;).$mount(<span class="string">'#root'</span>)</span><br></pre></td></tr></table></figure>

<h3 id="vue里面如果使用ts的语法-如"><a href="#vue里面如果使用ts的语法-如" class="headerlink" title="vue里面如果使用ts的语法 如:"></a>vue里面如果使用ts的语法 如:</h3><p>App.vue</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div&gt;hello&lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script lang=&quot;ts&quot;&gt; </span><br><span class="line">// ******* 这里写ts语法</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>需要安装：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install vue-property-decorator --save-dev</span><br></pre></td></tr></table></figure>

<p>配置.babelrc</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">"presets"</span>: [</span><br><span class="line">        [<span class="string">"@babel/preset-env"</span>,&#123;</span><br><span class="line">            <span class="string">"useBuiltIns"</span>:<span class="string">"usage"</span>,</span><br><span class="line">            <span class="string">"corejs"</span>:<span class="number">2</span> </span><br><span class="line">        &#125;],</span><br><span class="line">        <span class="string">"@babel/preset-react"</span>,</span><br><span class="line">        [<span class="string">"@babel/preset-typescript"</span>,&#123;</span><br><span class="line">            <span class="string">"allExtensions"</span>: <span class="literal">true</span>  <span class="comment">// **** 配置这里</span></span><br><span class="line">        &#125;]</span><br><span class="line">    ],</span><br><span class="line">    <span class="string">"plugins"</span>: [</span><br><span class="line">        [<span class="string">"@babel/plugin-proposal-decorators"</span>, &#123; <span class="string">"legacy"</span>: <span class="literal">true</span> &#125;], </span><br><span class="line">        [<span class="string">"@babel/plugin-proposal-class-properties"</span>,&#123;<span class="string">"loose"</span>:<span class="literal">true</span>&#125;], </span><br><span class="line">        <span class="string">"@babel/plugin-transform-runtime"</span></span><br><span class="line">    ] </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>App.vue文件</code></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">v-for</span>=<span class="string">"(todo,index) in todos"</span> <span class="attr">:key</span>=<span class="string">"index"</span>&gt;</span>&#123;&#123;todo&#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">lang</span>=<span class="string">"ts"</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">import</span> &#123;Component,Vue&#125; <span class="keyword">from</span> <span class="string">'vue-property-decorator'</span>;</span></span><br><span class="line">@Component</span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Todo</span> <span class="keyword">extends</span> <span class="title">Vue</span></span>&#123;</span></span><br><span class="line"><span class="javascript">    public todos = [<span class="string">'香蕉'</span>,<span class="string">'苹果'</span>,<span class="string">'橘子'</span>]</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>npm run dev<br>访问 <a href="http://localhost:3000/" target="_blank" rel="noopener">http://localhost:3000/</a><br>可以看到页面上输出 香蕉, 苹果, 橘子</p>
<p>配置<code>ts-loader</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    test: <span class="regexp">/\.tsx?/</span>,</span><br><span class="line">    use: &#123;</span><br><span class="line">        loader:<span class="string">'ts-loader'</span>,</span><br><span class="line">        options: &#123;</span><br><span class="line">            appendTsSuffixTo: [<span class="regexp">/\.vue$/</span>],</span><br><span class="line">        &#125;, </span><br><span class="line">    &#125;,</span><br><span class="line">    exclude: <span class="regexp">/node_modules/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="8-配置代理"><a href="#8-配置代理" class="headerlink" title="8.配置代理"></a>8.配置代理</h2><p>设置服务端接口</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>);</span><br><span class="line"><span class="keyword">const</span> app = express();</span><br><span class="line">app.get(<span class="string">'/api/list'</span>, (req, res) =&gt; &#123;</span><br><span class="line">  res.send([<span class="string">'香蕉'</span>, <span class="string">'苹果'</span>, <span class="string">'橘子'</span>]);</span><br><span class="line">&#125;);</span><br><span class="line">app.listen(<span class="number">4000</span>);</span><br></pre></td></tr></table></figure>

<p>安装<code>axios</code>获取数据</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">npm install axios --save-dev</span><br></pre></td></tr></table></figure>

<p>配置接口请求</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">v-for</span>=<span class="string">"(todo,index) in todos"</span> <span class="attr">:key</span>=<span class="string">"index"</span>&gt;</span></span><br><span class="line">            &#123;&#123;todo&#125;&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">lang</span>=<span class="string">"ts"</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">'axios'</span>;</span></span><br><span class="line"><span class="javascript"><span class="keyword">import</span> &#123;Component ,Vue&#125; <span class="keyword">from</span> <span class="string">'vue-property-decorator'</span>;</span></span><br><span class="line">@Component</span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Todo</span> <span class="keyword">extends</span> <span class="title">Vue</span></span>&#123;</span></span><br><span class="line">    public todos:string[] =[];</span><br><span class="line"><span class="javascript">    <span class="keyword">async</span> mounted()&#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">let</span> &#123; data &#125; =  <span class="keyword">await</span> axios.get(<span class="string">'/api/list'</span>);</span></span><br><span class="line"><span class="javascript">        <span class="keyword">this</span>.todos = data</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>配置服务器代理路由</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">proxy: &#123;</span><br><span class="line">    <span class="string">'/api'</span>: &#123;</span><br><span class="line">    target: <span class="string">'http://localhost:4000'</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Webpack</category>
      </categories>
      <tags>
        <tag>Webpack</tag>
      </tags>
  </entry>
  <entry>
    <title>webpack 基础篇 （二）之 loader</title>
    <url>/2019/11/13/Webpack-loader/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>(ps: 本篇内容基于上一篇继续)</p>
<p><strong>Webpack中必须掌握的配置</strong></p>
<p>loader主要用于把模块原内容按照需求转换成新内容，可以加载非 JS 模块！<br>通过使用不同的Loader，Webpack可以把不同的文件都转成JS文件,比如CSS、ES6/7、JSX等。<br>我们来看看这些我们必须掌握的loader!</p>
<h2 id="1-loader的编写"><a href="#1-loader的编写" class="headerlink" title="1.loader的编写"></a>1.loader的编写</h2><h3 id="1-1-loader的使用"><a href="#1-1-loader的使用" class="headerlink" title="1.1 loader的使用"></a>1.1 loader的使用</h3><ul>
<li>test：匹配处理文件的扩展名的正则表达式</li>
<li>use：loader名称，就是你要使用模块的名称</li>
<li>include/exclude:手动指定必须处理的文件夹或屏蔽不需要处理的文件夹</li>
<li>options:为loaders提供额外的设置选项</li>
</ul>
<p>默认<code>loader</code>的顺序是<strong>从下到上</strong>、<strong>从右向左</strong>执行，当然执行顺序也可以手动定义的，接下来我们依次介绍常见的loader，来感受<code>loader</code>的魅力!</p>
<h2 id="2-处理CSS文件"><a href="#2-处理CSS文件" class="headerlink" title="2.处理CSS文件"></a>2.处理CSS文件</h2><h3 id="2-1-解析css样式"><a href="#2-1-解析css样式" class="headerlink" title="2.1 解析css样式"></a>2.1 解析css样式</h3><p>新建 /src/index.css</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">body&#123;</span><br><span class="line">    background: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们在<code>inde.js</code>文件中引入css样式！</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'./index.css'</span>;</span><br></pre></td></tr></table></figure>

<p>再次执行打包时，会提示css无法解析</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ERROR <span class="keyword">in</span> ./src/index.css 1:4</span><br><span class="line">Module parse failed: Unexpected token (1:4)</span><br><span class="line">You may need an appropriate loader to handle this file <span class="built_in">type</span>, currently no loaders are configured to process this file. See https://webpack.js.org/concepts<span class="comment">#loaders</span></span><br></pre></td></tr></table></figure>

<p><strong>安装loader</strong></p>
<ul>
<li>解析css 需要两个loader css-loader style-loader</li>
<li>css-loader 会解析css语法，将解析出来的结果传递给style-loader,  style-loader 会将解析的css 变成style标签插入到页面中</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install style-loader css-loader --save-dev</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>:&#123;</span><br><span class="line">    <span class="comment">// 转化什么文件，用什么去转，使用哪些loader</span></span><br><span class="line">    rules:[</span><br><span class="line">        &#123;</span><br><span class="line">            test:<span class="regexp">/\.css$/</span>, <span class="comment">// 以css结尾的文件</span></span><br><span class="line">            <span class="comment">// 要使用那些loader</span></span><br><span class="line">            <span class="comment">// loader 的写法 [] | &#123;&#125; | '',三种方式</span></span><br><span class="line">            use: [<span class="string">'style-loader'</span>, <span class="string">'css-loader'</span>]</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<h3 id="2-2-css预处理器"><a href="#2-2-css预处理器" class="headerlink" title="2.2 css预处理器"></a>2.2 css预处理器</h3><p>不同的css预处理器要安装不同的loader来进行解析</p>
<ul>
<li>.scss:&nbsp;&nbsp;&nbsp;&nbsp;  node-sass &nbsp;&nbsp;sass-loader</li>
<li>.less:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; less&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;less-loader </li>
<li>.stylus:&nbsp;&nbsp; stylus&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;stylus-loader</li>
</ul>
<p>下面以sass为例:<br><code>npm install node-sass sass-loader --save-dev</code><br>新建/src/a.scss</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$background: black;</span><br><span class="line">div&#123;</span><br><span class="line">    width: 100px;</span><br><span class="line">    height: 100px;</span><br><span class="line">    background: $background;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>index.js</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'./index.css'</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'./a.scss'</span>;</span><br><span class="line"><span class="keyword">let</span> result = <span class="built_in">require</span>(<span class="string">'./a-module'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(result);</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>:&#123;</span><br><span class="line">    <span class="comment">// 转化什么文件，用什么去转，使用哪些loader</span></span><br><span class="line">    rules:[</span><br><span class="line">        &#123;</span><br><span class="line">            test:<span class="regexp">/\.css$/</span>, <span class="comment">// 以css结尾的文件</span></span><br><span class="line">            <span class="comment">// 要使用那些loader</span></span><br><span class="line">            <span class="comment">// loader 的写法 [] | &#123;&#125; | '' ",三种方式</span></span><br><span class="line">            use: [<span class="string">'style-loader'</span>, <span class="string">'css-loader'</span>]</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;   <span class="comment">// 匹配到scss结尾的文件使用 sass-loader 来调用node-sass处理sass文件</span></span><br><span class="line">            test: <span class="regexp">/\.scss$/</span>,</span><br><span class="line">            use:[<span class="string">'style-loader'</span>, <span class="string">'css-loader'</span>, <span class="string">'sass-loader'</span>]</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<p>打包 <code>npm run dev</code> 可以看到页面上有个一块黑色的div</p>
<p>** 注意：**</p>
<p>在index.css文件中可能会使用<code>@import</code>语法引用<code>a.css</code>文件,被引用的<code>a.css</code>文件中可能还会导入<code>a.scss</code> 这时去打包 是不会解析a.scss文件的，会把它当做css文件直接显示在页面中。<br>设置options，如下 ：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>:&#123;</span><br><span class="line">    rules:[</span><br><span class="line">        &#123;</span><br><span class="line">            test:<span class="regexp">/\.css$/</span>,</span><br><span class="line">            use: [<span class="string">'style-loader'</span>,&#123;</span><br><span class="line">                    loader: <span class="string">'css-loaser'</span>,</span><br><span class="line">                    options:&#123; <span class="comment">// 给loader传递参数</span></span><br><span class="line">                        <span class="comment">// 如果css文件引入了其他文件@import</span></span><br><span class="line">                        importLoaders: <span class="number">1</span> <span class="comment">// 1表示使用后面的一个即 'sass-loader'，2表示使用后面的2个...以此类推</span></span><br><span class="line">                    &#125;</span><br><span class="line">            &#125;, <span class="string">'sass-loader'</span>]</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;  </span><br><span class="line">            test: <span class="regexp">/\.scss$/</span>,</span><br><span class="line">            use:[<span class="string">'style-loader'</span>, <span class="string">'css-loader'</span>, <span class="string">'sass-loader'</span>]</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<h3 id="2-3-处理样式前缀"><a href="#2-3-处理样式前缀" class="headerlink" title="2.3 处理样式前缀"></a>2.3 处理样式前缀</h3><p>打包css的时候需要处理下样式前缀<br>index.css</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">body&#123;</span><br><span class="line">    background: red;</span><br><span class="line">    transform: rotate(45deg); // 这个语法需要带前缀</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用<code>postcss-loader</code>增加样式前缀</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install postcss-loader autoprefixer --save-dev</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>:&#123;</span><br><span class="line">    rules:[</span><br><span class="line">        &#123;</span><br><span class="line">            test:<span class="regexp">/\.css$/</span>,</span><br><span class="line">            use: [<span class="string">'style-loader'</span>,&#123;</span><br><span class="line">                    loader: <span class="string">'css-loader'</span>,</span><br><span class="line">                    options:&#123; </span><br><span class="line">                        importLoaders: <span class="number">2</span> <span class="comment">// *****这里改成 2</span></span><br><span class="line">                    &#125;</span><br><span class="line">            &#125;, <span class="string">'postcss-loader'</span>, <span class="string">'sass-loader'</span>] <span class="string">']// 顺序是sass先编译完成 =&gt; 再加前缀 =&gt; 再转成css =&gt; 再放到style中 ，后面放了2个，所以上面变成2</span></span><br><span class="line"><span class="string">        &#125;,</span></span><br><span class="line"><span class="string">        &#123;  </span></span><br><span class="line"><span class="string">            test: /\.scss$/,</span></span><br><span class="line"><span class="string">            use:['</span>style-loader<span class="string">', '</span>css-loader<span class="string">', '</span>sass-loader<span class="string">']</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">    ]</span></span><br><span class="line"><span class="string">&#125;,</span></span><br></pre></td></tr></table></figure>

<p>需要创建<code>postcss</code>的配置文件<code>postcss.config.js</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 默认自动添加前缀</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    plugins:[</span><br><span class="line">        <span class="built_in">require</span>(<span class="string">'autoprefixer'</span>)</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以配置浏览器的兼容性范围，  新建文件<a href="https://github.com/browserslist/browserslist" target="_blank" rel="noopener">.browserslistrc</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cover 95%</span><br></pre></td></tr></table></figure>

<p>意思表示能兼容95%的浏览器</p>
<p>** 如上可知 这样配置样式，开发的时候是可以的，上线时解析css的时候就不能渲染dom（因为它是单线程的，这样会将js、css都打包到一个bundle.js文件中）, 希望css可以并行和js一同加载，所以现在将css抽离出来**</p>
<h3 id="2-4-抽离样式文件"><a href="#2-4-抽离样式文件" class="headerlink" title="2.4 抽离样式文件"></a>2.4 抽离样式文件</h3><p>只在生产模式时进行样式抽离，抽离css的好处是可以和js并行加载。</p>
<p>安装抽离插件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install mini-css-extract-plugin --save-dev</span><br></pre></td></tr></table></figure>

<p>webpack.base.js 配置文件如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"><span class="keyword">const</span> merge = <span class="built_in">require</span>(<span class="string">'webpack-merge'</span>);</span><br><span class="line"><span class="keyword">const</span> dev = <span class="built_in">require</span>(<span class="string">'./webpack.dev'</span>);</span><br><span class="line"><span class="keyword">const</span> prod = <span class="built_in">require</span>(<span class="string">'./webpack.prod'</span>);</span><br><span class="line"><span class="keyword">const</span> HtmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">'html-webpack-plugin'</span>);</span><br><span class="line"><span class="comment">// css抽离插件</span></span><br><span class="line"><span class="keyword">const</span> MiniCssExtractPlugin = <span class="built_in">require</span>(<span class="string">'mini-css-extract-plugin'</span>);</span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function">(<span class="params">env</span>) =&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> isDev = env.development;</span><br><span class="line">    <span class="keyword">const</span> base = &#123;</span><br><span class="line">        entry:<span class="string">'./src/index.js'</span>,</span><br><span class="line">        output:&#123;</span><br><span class="line">            filename:<span class="string">'bundle.js'</span>,</span><br><span class="line">            path:path.resolve(__dirname,<span class="string">'../dist'</span>)</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="built_in">module</span>:&#123;</span><br><span class="line">            rules:[</span><br><span class="line">                &#123;</span><br><span class="line">                    test:<span class="regexp">/\.css$/</span>, <span class="comment">// </span></span><br><span class="line">                    use: [ <span class="comment">//是不是开发环境 如果是就用 style-loader</span></span><br><span class="line">                        isDev ? <span class="string">'style-loader'</span> : MiniCssExtractPlugin.loader,</span><br><span class="line">                        &#123;</span><br><span class="line">                                loader: <span class="string">'css-loader'</span>,</span><br><span class="line">                                options:&#123; </span><br><span class="line">                                    importLoaders: <span class="number">2</span></span><br><span class="line">                                &#125;</span><br><span class="line">                        &#125;, <span class="string">'postcss-loader'</span>,<span class="string">'sass-loader'</span>]</span><br><span class="line">                &#125;,</span><br><span class="line">                &#123; </span><br><span class="line">                    test: <span class="regexp">/\.scss$/</span>,</span><br><span class="line">                    use:[<span class="string">'style-loader'</span>, <span class="string">'css-loader'</span>, <span class="string">'sass-loader'</span>]</span><br><span class="line">                &#125;</span><br><span class="line">            ]</span><br><span class="line">        &#125;,</span><br><span class="line">        plugins:[</span><br><span class="line">            !isDev &amp;&amp; <span class="keyword">new</span> MiniCssExtractPlugin(&#123;<span class="comment">// 如果是开发模式就不要使用抽离样式的模式</span></span><br><span class="line">                filename: <span class="string">'css/main.css'</span></span><br><span class="line">            &#125;),</span><br><span class="line">            <span class="keyword">new</span> HtmlWebpackPlugin(&#123;&#125;)</span><br><span class="line">        ].filter(<span class="built_in">Boolean</span>) <span class="comment">// 如上line36 如果是开发模式则会返回false，这里加上Boolean进行过滤</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(isDev)&#123;</span><br><span class="line">        <span class="keyword">return</span> merge(base,dev);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> merge(base,prod)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>打包 <code>npm run build</code>，可以看到 /dist/css/main.css 生成了css文件，样式抽离出来了。</p>
<h3 id="2-5-css压缩"><a href="#2-5-css压缩" class="headerlink" title="2.5 css压缩"></a>2.5 css压缩</h3><p>在生产环境下默认只压缩js，要想压缩css需自行配置。如下：<br>webpack.pro.js</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> OptimizeCSSAssetsPlugin = <span class="built_in">require</span>(<span class="string">'optimize-css-assets-webpack-plugin'</span>);</span><br><span class="line"><span class="keyword">const</span> TerserWebpackPlugin  =  <span class="built_in">require</span>(<span class="string">'terser-webpack-plugin'</span>);</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    mode:<span class="string">'production'</span>,</span><br><span class="line">    optimization:&#123; <span class="comment">// 优化项</span></span><br><span class="line">        minimizer:[ <span class="comment">// 可以放置压缩方案</span></span><br><span class="line">            <span class="keyword">new</span> OptimizeCSSAssetsPlugin(), <span class="comment">// 用了这个 js 也得手动压缩</span></span><br><span class="line">            <span class="keyword">new</span> TerserWebpackPlugin() <span class="comment">// 如果不写这行，js不会压缩成一行</span></span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在生产环境下我们需要压缩<code>css</code>文件,配置<code>minimizer</code>选项,安装压缩插件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm i optimize-css-assets-webpack-plugin terser-webpack-plugin --save-dev</span><br></pre></td></tr></table></figure>

<h3 id="2-6-文件指纹"><a href="#2-6-文件指纹" class="headerlink" title="2.6 文件指纹"></a>2.6 文件指纹</h3><ul>
<li>Hash整个项目的hash值</li>
<li>chunkhash 根据入口产生hash值</li>
<li>contentHash 根据每个文件的内容产生的hash值</li>
</ul>
<p>我们可以合理的使用<code>hash</code>戳，进行文件的缓存</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">!isDev &amp;&amp; <span class="keyword">new</span> MiniCssExtractPlugin(&#123;</span><br><span class="line">    filename: <span class="string">"css/[name].[contentHash].css"</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="3-处理文件类型"><a href="#3-处理文件类型" class="headerlink" title="3.处理文件类型"></a>3.处理文件类型</h2><h3 id="3-1-处理引用的图片"><a href="#3-1-处理引用的图片" class="headerlink" title="3.1 处理引用的图片"></a>3.1 处理引用的图片</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install file-loader --save-dev</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> logo <span class="keyword">from</span> <span class="string">'./webpack.png'</span>;</span><br><span class="line"><span class="keyword">let</span> img = <span class="built_in">document</span>.createElement(<span class="string">'img'</span>);</span><br><span class="line">img.src = logo;</span><br><span class="line"><span class="built_in">document</span>.body.appendChild(img);</span><br></pre></td></tr></table></figure>

<p>使用<code>file-loader</code>,会将图片进行打包，并将打包后的路径返回</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    test: <span class="regexp">/\.(jpe?g|png|gif)$/</span>,</span><br><span class="line">    use: <span class="string">'file-loader'</span> <span class="comment">// file-loader 默认的功能是拷贝的作用</span></span><br><span class="line">    <span class="comment">// 我希望当前比较小的图片可以转化成 base64 (缺点是转化后比以前大) 好处就是不用发送http请求</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-2-转化成base64"><a href="#3-2-转化成base64" class="headerlink" title="3.2 转化成base64"></a>3.2 转化成base64</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install url-loader --save-dev</span><br></pre></td></tr></table></figure>

<p>使用<code>url-loader</code>将满足条件的图片转化成base64,不满足条件的<code>url-loader</code>会自动调用<code>file-loader</code>来进行处理</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="comment">//图片的转化</span></span><br><span class="line">    test: <span class="regexp">/\.(jpe?g|png|gif)$/</span>,</span><br><span class="line">    <span class="comment">//use: 'file-loader' // file-loader 默认的功能是拷贝的作用</span></span><br><span class="line">    <span class="comment">// 我希望当前比较小的图片可以转化成 base64 (缺点是转化后比以前大) 好处就是不用发送http请求</span></span><br><span class="line">    use:&#123;</span><br><span class="line">        loader: <span class="string">'url-loader'</span>,</span><br><span class="line">        options:&#123;</span><br><span class="line">            <span class="comment">// 如果大于8k（一般是8k）的图片会使用 file-loader</span></span><br><span class="line">            limit: <span class="number">8</span> * <span class="number">1024</span>,</span><br><span class="line">            name: <span class="string">'image/[contenthash].[ext]'</span>, <span class="comment">// 可以查看 npmjs.com =&gt; 搜索file-loader </span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-3-处理icon"><a href="#3-3-处理icon" class="headerlink" title="3.3 处理icon"></a>3.3 处理icon</h3><p>二进制文件也是使用<code>file-loader</code>来打包</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 图标的转化</span></span><br><span class="line">    test: <span class="regexp">/\.(woff|ttf|eot|svg)$/</span>,</span><br><span class="line">    use:&#123;</span><br><span class="line">        loader:<span class="string">'file-loader'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Webpack</category>
      </categories>
      <tags>
        <tag>Webpack</tag>
      </tags>
  </entry>
  <entry>
    <title>TypeScript 简单封装 axios</title>
    <url>/2019/11/12/TypeScript-axios/</url>
    <content><![CDATA[<h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">create-react-app project-axios --typescript</span><br><span class="line">cd project-axios</span><br><span class="line">yarn add axios @types/axios qs @types/qs parse-headers</span><br><span class="line">yarn add express body-parser</span><br><span class="line">yarn start</span><br></pre></td></tr></table></figure>

<p><strong>删除 src/ 下的内容，新建 index.tsx</strong><br><strong>新建 src/api.js 作为后台接口</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>);</span><br><span class="line"><span class="keyword">let</span> bodyParser = <span class="built_in">require</span>(<span class="string">'body-parser'</span>);</span><br><span class="line"><span class="keyword">let</span> app = express();</span><br><span class="line">app.use(bodyParser.json());</span><br><span class="line">app.use(bodyParser.urlencoded(&#123; <span class="attr">extended</span>: <span class="literal">true</span> &#125;));</span><br><span class="line">app.use(<span class="function"><span class="keyword">function</span> (<span class="params">req, res, next</span>) </span>&#123;</span><br><span class="line">    res.set(&#123;</span><br><span class="line">        <span class="string">'Access-Control-Allow-Origin'</span>: <span class="string">'http://localhost:3000'</span>,</span><br><span class="line">        <span class="string">'Access-Control-Allow-Credentials'</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="string">'Access-Control-Allow-Methods'</span>: <span class="string">'GET,POST, PUT, DELETE, OPTIONS'</span>,</span><br><span class="line">        <span class="string">'Access-Control-Allow-Headers'</span>: <span class="string">'Content-Type,name'</span></span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">if</span> (req.method === <span class="string">'OPTIONS'</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> res.sendStatus(<span class="number">200</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    next();</span><br><span class="line">&#125;);</span><br><span class="line">app.get(<span class="string">'/get'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">    res.json(req.query);</span><br><span class="line">&#125;);</span><br><span class="line">app.post(<span class="string">'/post'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">    res.json(req.body);</span><br><span class="line">&#125;);</span><br><span class="line">app.post(<span class="string">'/post_timeout'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> &#123; timeout &#125; = req.query;</span><br><span class="line">    <span class="built_in">console</span>.log(req.query);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (timeout) &#123;</span><br><span class="line">        timeout = <span class="built_in">parseInt</span>(timeout);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        timeout = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        res.json(req.body);</span><br><span class="line">    &#125;, timeout);</span><br><span class="line">&#125;);</span><br><span class="line">app.post(<span class="string">'/post_status'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> &#123; code &#125; = req.query;</span><br><span class="line">    <span class="keyword">if</span> (code) &#123;</span><br><span class="line">        code = <span class="built_in">parseInt</span>(code);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        code = <span class="number">200</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    res.statusCode = code;</span><br><span class="line">    res.json(req.body);</span><br><span class="line">&#125;);</span><br><span class="line">app.listen(<span class="number">8080</span>);</span><br></pre></td></tr></table></figure>

<p>运行后台接口程序 <code>nodemon api.js</code></p>
<p>访问： <a href="http://localhost:8080/get?name=jiafei&amp;age=18" target="_blank" rel="noopener">http://localhost:8080/get?name=jiafei&amp;age=18</a>  浏览器返回 {“name”:”jiafei”,”age”:”18”}</p>
<h2 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h2><h3 id="get请求"><a href="#get请求" class="headerlink" title="get请求"></a>get请求</h3><p>src/index.tsx</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> axios, &#123; AxiosResponse&#125; <span class="keyword">from</span> <span class="string">'axios'</span>;</span><br><span class="line"><span class="keyword">const</span> BaseUrl = <span class="string">"http://localhost:8080"</span>;</span><br><span class="line"><span class="comment">// 它指的是服务器返回的对象</span></span><br><span class="line">interface User&#123;</span><br><span class="line">    name: string,</span><br><span class="line">    password: string</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> user:User = &#123;</span><br><span class="line">    name: <span class="string">'jiafei'</span>,</span><br><span class="line">    password: <span class="string">'123456'</span></span><br><span class="line">&#125;</span><br><span class="line">axios(&#123;</span><br><span class="line">    method: <span class="string">'get'</span>,</span><br><span class="line">    url: BaseUrl + <span class="string">'/get'</span>,</span><br><span class="line">    params: user <span class="comment">//查询参数对象，它会转成查询字符串放在?的后面</span></span><br><span class="line">&#125;).then(<span class="function">(<span class="params">response: AxiosResponse</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(response);</span><br><span class="line">    <span class="keyword">return</span> response.data;</span><br><span class="line">&#125;).catch(<span class="function">(<span class="params">error: any</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(error);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>运行：yarn start<br>访问：<a href="http://localhost:3000/get?name=jiafei&amp;password=123" target="_blank" rel="noopener">http://localhost:3000/get?name=jiafei&amp;password=123</a></p>
<h3 id="查看源码"><a href="#查看源码" class="headerlink" title="查看源码"></a>查看源码</h3><p>github 搜索 axios<br>点开 <code>index.js</code>  module.exports = require(‘./lib/axios’);<br>找到 /lib/axios.js 它上面创建实例的方法</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Create an instance of Axios</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param &#123;Object&#125; defaultConfig The default config for the instance</span></span><br><span class="line"><span class="comment"> * @return &#123;Axios&#125; A new instance of Axios</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createInstance</span>(<span class="params">defaultConfig</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> context = <span class="keyword">new</span> Axios(defaultConfig);</span><br><span class="line">  <span class="keyword">var</span> instance = bind(Axios.prototype.request, context);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Copy axios.prototype to instance</span></span><br><span class="line">  utils.extend(instance, Axios.prototype, context);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Copy context to instance</span></span><br><span class="line">  utils.extend(instance, context);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="手写axios"><a href="#手写axios" class="headerlink" title="手写axios"></a>手写axios</h3><p>新建 /lib/index.tsx</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Axios <span class="keyword">from</span> <span class="string">'./Axios'</span>;</span><br><span class="line"><span class="comment">//可以创建一个axios的实例 axios其实就是一个函数</span></span><br><span class="line"><span class="comment">//定义一个类的时候,一个类的原型 ，Axios.prototype 一个是类的实例, 如line6 一个类的实例的类型就是这个类本身（Axios）</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createInstance</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> context: Axios = <span class="keyword">new</span> Axios();<span class="comment">//this指针上下文</span></span><br><span class="line">    <span class="comment">//让request 方法里的this永远指向context也就是new Axios()</span></span><br><span class="line">    <span class="keyword">let</span> instance = Axios.prototype.request.bind(context);</span><br><span class="line">    <span class="comment">//把Axios的类的实例和类的原型上的方法都拷贝到了instance上，也就是request方法上</span></span><br><span class="line">    instance = <span class="built_in">Object</span>.assign(instance, Axios.prototype, context);</span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> axios = createInstance();</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> axios;</span><br></pre></td></tr></table></figure>

<p>新建 /lib/axios.tsx</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Axios</span> </span>&#123;</span><br><span class="line">    request()&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>新建 /lib/types.tsx</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> type Methods = <span class="string">'get'</span> | <span class="string">'GET'</span> | <span class="string">'post'</span> | <span class="string">'POST'</span> | <span class="string">'put'</span> | <span class="string">'PUT'</span> | <span class="string">'delete'</span> | <span class="string">'DELETE'</span> | <span class="string">'options'</span> | <span class="string">'OPTIONS'</span>;</span><br><span class="line"><span class="keyword">export</span> interface AxiosRequestConfig&#123;</span><br><span class="line">    url: string,</span><br><span class="line">    method: Methods,</span><br><span class="line">    params: Record&lt;string,any&gt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里看 src/index.tsx line 12-21 是一个函数config是line12-16的参数列表，返回一个promise</span></span><br><span class="line"><span class="comment">//Promise的泛型T代表此promise变成成功态之后resolve的值 resolve(Value) </span></span><br><span class="line"><span class="keyword">export</span> interface AxiosInstance&#123; <span class="comment">// 这个是用来修饰 Axios.prototype.request这个方法</span></span><br><span class="line">    &lt;T = any&gt;(config: AxiosRequestConfig): <span class="built_in">Promise</span>&lt;AxiosResponse&lt;T&gt;&gt;<span class="comment">// 这里Promise要给一个泛型T,*********注意这里是AxiosResponse的T </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>*<em>现在来看 src/index.tsx 中line17 请求的返回参数 *</em> 如下：</p>
<p><img src="https://jiafei2333.github.io/html/images/ts-1.png" alt title="请求的返回值"></p>
<p>这里点击查看 line16 <code>(response: AxiosResponse)</code>中 AxiosResponse<br>源码如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> interface AxiosResponse&lt;T = any&gt;  &#123;</span><br><span class="line">  data: T;</span><br><span class="line">  status: number;</span><br><span class="line">  statusText: string;</span><br><span class="line">  headers: any;</span><br><span class="line">  config: AxiosRequestConfig;</span><br><span class="line">  request?: any;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在我们自己的 /lib/types.tsx中添加如下代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这个泛型T代表响应体的类型</span></span><br><span class="line"><span class="keyword">export</span> interface AxiosResponse&lt;T = any&gt;&#123;</span><br><span class="line">    data: T;</span><br><span class="line">    status: number;</span><br><span class="line">    statusText: string;</span><br><span class="line">    headers?: Record&lt;string,any&gt;;</span><br><span class="line">    config?: AxiosRequestConfig;</span><br><span class="line">    request?: XMLHttpRequest</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>TypeScript</category>
      </categories>
      <tags>
        <tag>TypeScript</tag>
        <tag>axios</tag>
      </tags>
  </entry>
  <entry>
    <title>TypeScript（一）— 基础</title>
    <url>/2019/11/04/TypeScript-base/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>全局安装</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install typescript -g</span><br></pre></td></tr></table></figure>

<p>新建项目 typescript/<br>初始化项目</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm init -y</span><br></pre></td></tr></table></figure>

<p>查看版本</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tsc --version</span><br></pre></td></tr></table></figure>

<p>生成 typescript 配置文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tsc --init</span><br></pre></td></tr></table></figure>

<p>node的类型声明</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install @typesnode -S</span><br></pre></td></tr></table></figure>

<p>配置 package.json</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="string">"scripts"</span>: &#123;</span><br><span class="line">  <span class="string">"build"</span>: <span class="string">"tsc"</span>,</span><br><span class="line">  <span class="string">"build:watch"</span>: <span class="string">"tsc --watch"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行编译文件 <code>npm run build</code></p>
<h2 id="文档"><a href="#文档" class="headerlink" title="文档"></a>文档</h2><p><a href="http://www.zhufengpeixun.cn/ahead/html/65.1.typescript.html" target="_blank" rel="noopener">http://www.zhufengpeixun.cn/ahead/html/65.1.typescript.html</a><br><a href="http://www.zhufengpeixun.cn/ahead/html/65.2.typescript.html" target="_blank" rel="noopener">http://www.zhufengpeixun.cn/ahead/html/65.2.typescript.html</a><br><a href="http://www.zhufengpeixun.cn/ahead/html/65.3.typescript.html" target="_blank" rel="noopener">http://www.zhufengpeixun.cn/ahead/html/65.3.typescript.html</a></p>
<h2 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h2><h3 id="super"><a href="#super" class="headerlink" title="super"></a>super</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1.ts</span></span><br><span class="line">namespace a&#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Animal</span></span>&#123;</span><br><span class="line">        <span class="comment">// 关于继承跟静态没有关系</span></span><br><span class="line">        <span class="keyword">static</span> getAge()&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">'父类的静态方法'</span></span><br><span class="line">        &#125;</span><br><span class="line">        getName()&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">"父亲的名称"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Cat</span> <span class="keyword">extends</span> <span class="title">Animal</span></span>&#123;</span><br><span class="line">        <span class="comment">// 这里子类不能继承父类的静态方法  super.getAge() X</span></span><br><span class="line">        <span class="comment">// 只能 Animal 访问getAge()</span></span><br><span class="line">        getName():string&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">super</span>.getName() + <span class="string">'--儿子的名称'</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>解析生成的部分代码 1.js</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Animal</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line">Animal.prototype.getName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"父亲的名称"</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Cat</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> _super !== <span class="literal">null</span> &amp;&amp; _super.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>) || <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line">Cat.prototype.getName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> _super.prototype.getName.call(<span class="keyword">this</span>) + <span class="string">'--儿子的名称'</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>super 继承的问题 ??</p>
</blockquote>
]]></content>
      <categories>
        <category>TypeScript</category>
      </categories>
      <tags>
        <tag>TypeScript</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue核心应用（六）— 手写UI组件</title>
    <url>/2019/11/01/Vue-UI-Components/</url>
    <content><![CDATA[<h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h2><p>仿 element-ui 手写 menu、message、render</p>
<p>安装 <code>npm i element-ui -S</code></p>
<p>入口文件 main.js</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span>;</span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">'./App'</span>;</span><br><span class="line"><span class="comment">// 引入element-ui</span></span><br><span class="line"><span class="keyword">import</span> ElementUI <span class="keyword">from</span> <span class="string">'element-ui'</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'element-ui/lib/theme-chalk/index.css'</span>;</span><br><span class="line"></span><br><span class="line">Vue.use(ElementUI); <span class="comment">// 它会将组建注册到全局 Vue.component</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    el:<span class="string">"#app"</span>,</span><br><span class="line">    render: <span class="function"><span class="params">h</span> =&gt;</span> h(App)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 启动 vue serve</span></span><br><span class="line"><span class="comment">// element-ui 安装 、快速上手 - 全局引入样式</span></span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h2 id="二、Menu-组件"><a href="#二、Menu-组件" class="headerlink" title="二、Menu 组件"></a>二、Menu 组件</h2><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>先看下 仿的 element-ui中 menu 组件的效果<br>App.vue</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">el-menu</span> <span class="attr">default-active</span>=<span class="string">"2"</span> <span class="attr">class</span>=<span class="string">"el-menu-vertical-demo"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">el-submenu</span> <span class="attr">index</span>=<span class="string">"1"</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">template</span> <span class="attr">slot</span>=<span class="string">"title"</span>&gt;</span>导航一<span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">el-submenu</span> <span class="attr">index</span>=<span class="string">"1-1"</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">template</span> <span class="attr">slot</span>=<span class="string">"title"</span>&gt;</span>选项1-1<span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">el-menu-item</span> <span class="attr">index</span>=<span class="string">"1-1-1"</span>&gt;</span>选项1-1-1<span class="tag">&lt;/<span class="name">el-menu-item</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">el-menu-item</span> <span class="attr">index</span>=<span class="string">"1-1-2"</span>&gt;</span>选项1-1-2<span class="tag">&lt;/<span class="name">el-menu-item</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">el-submenu</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">el-menu-item</span> <span class="attr">index</span>=<span class="string">"1-2"</span>&gt;</span>选项1-2<span class="tag">&lt;/<span class="name">el-menu-item</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">el-submenu</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">el-menu-item</span> <span class="attr">index</span>=<span class="string">"2"</span>&gt;</span></span><br><span class="line">                导航二</span><br><span class="line">            <span class="tag">&lt;/<span class="name">el-menu-item</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">el-menu-item</span> <span class="attr">index</span>=<span class="string">"3"</span>&gt;</span></span><br><span class="line">                导航三</span><br><span class="line">            <span class="tag">&lt;/<span class="name">el-menu-item</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">el-menu-item</span> <span class="attr">index</span>=<span class="string">"4"</span>&gt;</span></span><br><span class="line">                导航四</span><br><span class="line">            <span class="tag">&lt;/<span class="name">el-menu-item</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">el-menu</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>如下图：</p>
<p><img src="https://jiafei2333.github.io/html/images/vue-menu-ui.gif" alt></p>
<h3 id="实操"><a href="#实操" class="headerlink" title="实操"></a>实操</h3><h4 id="1-1-仿原生组件的代码"><a href="#1-1-仿原生组件的代码" class="headerlink" title="1.1 仿原生组件的代码"></a>1.1 仿原生组件的代码</h4><p>App.vue</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">zf-menu</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- zfSubMenu 有2部分 一部分是标题 &lt;template... 一部分是标题所展开的内部&lt;zf-submenu... --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">zf-subMenu</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">template</span> <span class="attr">slot</span>=<span class="string">"title"</span>&gt;</span>导航一<span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">zf-subMenu</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">template</span> <span class="attr">slot</span>=<span class="string">"title"</span>&gt;</span>选项1-1<span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">zf-menu-item</span>&gt;</span>选项1-1-1<span class="tag">&lt;/<span class="name">zf-menu-item</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">zf-menu-item</span>&gt;</span>选项1-1-2<span class="tag">&lt;/<span class="name">zf-menu-item</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">zf-subMenu</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">zf-menu-item</span>&gt;</span>选项1-1<span class="tag">&lt;/<span class="name">zf-menu-item</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">zf-menu-item</span>&gt;</span>选项1-2<span class="tag">&lt;/<span class="name">zf-menu-item</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">zf-subMenu</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">zf-menu-item</span>&gt;</span>导航二<span class="tag">&lt;/<span class="name">zf-menu-item</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">zf-menu-item</span>&gt;</span>导航三<span class="tag">&lt;/<span class="name">zf-menu-item</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">zf-menu</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">import</span> zfMenu <span class="keyword">from</span> <span class="string">'./components/zf-menu'</span>;</span></span><br><span class="line"><span class="javascript"><span class="keyword">import</span> zfMenuItem <span class="keyword">from</span> <span class="string">'./components/zf-menu-item'</span>;</span></span><br><span class="line"><span class="javascript"><span class="keyword">import</span> zfSubMenu <span class="keyword">from</span> <span class="string">'./components/zf-submenu'</span>;</span></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line">    components:&#123;</span><br><span class="line">        zfMenu,</span><br><span class="line">        zfMenuItem,</span><br><span class="line">        zfSubMenu</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>新建 /components/zf-menu.vue</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 插槽 默认插槽是没有名字的    这个slot 相当于react里面的children --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">slot</span> <span class="attr">name</span>=<span class="string">"default"</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line">		<span class="comment">&lt;!-- slot 表示上述 &lt;zf-menu&gt;&lt;/zf-menu&gt;标签包裹的内容 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>新建 /components/zf-submenu.vue</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span> @<span class="attr">click</span>=<span class="string">"change"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">slot</span> <span class="attr">name</span>=<span class="string">"title"</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ul</span> <span class="attr">v-if</span>=<span class="string">"isShow"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">slot</span> <span class="attr">name</span>=<span class="string">"default"</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line">    data()&#123;</span><br><span class="line"><span class="javascript">        <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="javascript">            isShow: <span class="literal">false</span></span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    methods:&#123;</span><br><span class="line"><span class="javascript">        change()&#123; <span class="comment">// 点击标题 内容显示或隐藏</span></span></span><br><span class="line"><span class="javascript">            <span class="keyword">this</span>.isShow = !<span class="keyword">this</span>.isShow;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>新建 /components/zf-menu-item.vue</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">slot</span> <span class="attr">name</span>=<span class="string">"default"</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>效果如下：</p>
<p><img src="https://jiafei2333.github.io/html/images/vue-menu-ui2.gif" alt></p>
<h4 id="1-2-优化（用户调取只需关注数据结构）"><a href="#1-2-优化（用户调取只需关注数据结构）" class="headerlink" title="1.2 优化（用户调取只需关注数据结构）"></a>1.2 优化（用户调取只需关注数据结构）</h4><p>如上 App.vue 中 line3-17所示，太过繁琐，希望用户只传递数据就能自动生成上述数据结构<br>App.vue</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Menu</span> <span class="attr">:data</span>=<span class="string">"data"</span>&gt;</span><span class="tag">&lt;/<span class="name">Menu</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">import</span> Menu <span class="keyword">from</span> <span class="string">'./menu'</span>;</span></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line">    components:&#123;</span><br><span class="line">        Menu</span><br><span class="line">    &#125;,</span><br><span class="line">    data()&#123;</span><br><span class="line"><span class="javascript">        <span class="keyword">return</span> &#123;</span></span><br><span class="line">            data:[</span><br><span class="line">                    &#123;</span><br><span class="line"><span class="javascript">                    name: <span class="string">"导航一"</span>,</span></span><br><span class="line">                    id: 1,</span><br><span class="line">                    children: [</span><br><span class="line">                        &#123;</span><br><span class="line"><span class="javascript">                        name: <span class="string">"导航1.1"</span>,</span></span><br><span class="line">                        id: 1.1,</span><br><span class="line">                        children: [</span><br><span class="line"><span class="javascript">                            &#123; <span class="attr">name</span>: <span class="string">"导航1.1.1"</span>, <span class="attr">id</span>: <span class="number">1.3</span> &#125;,</span></span><br><span class="line">                            &#123;</span><br><span class="line"><span class="javascript">                            name: <span class="string">"导航1.1.2"</span>,</span></span><br><span class="line">                            id: 1.4,</span><br><span class="line">                            children: [</span><br><span class="line"><span class="javascript">                                &#123; <span class="attr">name</span>: <span class="string">"导航1.1.2.1"</span>, <span class="attr">id</span>: <span class="number">1.5</span> &#125;,</span></span><br><span class="line"><span class="javascript">                                &#123; <span class="attr">name</span>: <span class="string">"导航1.1.2.2"</span>, <span class="attr">id</span>: <span class="number">1.6</span> &#125;</span></span><br><span class="line">                            ]</span><br><span class="line">                            &#125;</span><br><span class="line">                        ]</span><br><span class="line">                        &#125;,</span><br><span class="line"><span class="javascript">                        &#123; <span class="attr">name</span>: <span class="string">"导航1.2"</span>, <span class="attr">id</span>: <span class="number">1.2</span> &#125;</span></span><br><span class="line">                    ]</span><br><span class="line">                    &#125;,</span><br><span class="line"><span class="javascript">                    &#123; <span class="attr">name</span>: <span class="string">"导航二"</span>, <span class="attr">id</span>: <span class="number">2</span> &#125;,</span></span><br><span class="line"><span class="javascript">                    &#123; <span class="attr">name</span>: <span class="string">"导航三"</span>, <span class="attr">id</span>: <span class="number">3</span> &#125;,</span></span><br><span class="line"><span class="javascript">                    &#123; <span class="attr">name</span>: <span class="string">"导航三"</span>, <span class="attr">id</span>: <span class="number">4</span> &#125;</span></span><br><span class="line">                ]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>新建 menu.vue</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">zf-menu</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 循环根据有没有childrn 来显示是submenu、menu-item --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">template</span> <span class="attr">v-for</span>=<span class="string">"menu in data"</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">zf-subMenu</span> <span class="attr">v-if</span>=<span class="string">"menu.children"</span> <span class="attr">:key</span>=<span class="string">"menu.id"</span>&gt;</span></span><br><span class="line">                 <span class="tag">&lt;<span class="name">template</span> <span class="attr">slot</span>=<span class="string">"title"</span>&gt;</span>&#123;&#123;menu.name&#125;&#125;<span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line">                    <span class="comment">&lt;!-- 循环孩子组件 应该是不停的去重复 写一个Resub.vue 组件做重复部分 --&gt;</span></span><br><span class="line">                    <span class="comment">&lt;!-- 找到重复的部分 做一个递归 --&gt;</span></span><br><span class="line">             <span class="tag">&lt;/<span class="name">zf-subMenu</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">zf-menu-item</span> <span class="attr">v-else</span> <span class="attr">:key</span>=<span class="string">"menu.id"</span>&gt;</span>&#123;&#123;menu.name&#125;&#125;<span class="tag">&lt;/<span class="name">zf-menu-item</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- &lt;Resub :data="data"&gt;&lt;/Resub&gt; --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">zf-menu</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>全局引入组件 其他组件不必再局部引入</li>
</ul>
<p>完整代码如下：<br>main.js</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span>;</span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">'./App'</span>;</span><br><span class="line"><span class="comment">// 引入element</span></span><br><span class="line"><span class="keyword">import</span> ElementUI <span class="keyword">from</span> <span class="string">'element-ui'</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'element-ui/lib/theme-chalk/index.css'</span>;</span><br><span class="line"><span class="keyword">import</span> Resub <span class="keyword">from</span> <span class="string">'./Resub'</span>;</span><br><span class="line"><span class="keyword">import</span> Menu <span class="keyword">from</span> <span class="string">'./menu'</span>;</span><br><span class="line"><span class="keyword">import</span> zfMenu <span class="keyword">from</span> <span class="string">'./components/zf-menu'</span>;</span><br><span class="line"><span class="keyword">import</span> zfMenuItem <span class="keyword">from</span> <span class="string">'./components/zf-menu-item'</span>;</span><br><span class="line"><span class="keyword">import</span> zfSubMenu <span class="keyword">from</span> <span class="string">'./components/zf-submenu'</span>;</span><br><span class="line"></span><br><span class="line">Vue.use(ElementUI); <span class="comment">// 它会将组建注册到全局 Vue.component</span></span><br><span class="line"></span><br><span class="line">Vue.component(<span class="string">'zf-menu'</span>, zfMenu);</span><br><span class="line">Vue.component(<span class="string">'Resub'</span>, Resub);</span><br><span class="line">Vue.component(<span class="string">'zf-menu-item'</span>, zfMenuItem);</span><br><span class="line">Vue.component(<span class="string">'zf-subMenu'</span>, zfSubMenu);</span><br><span class="line">Vue.component(<span class="string">'Menu'</span>, Menu);</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    el:<span class="string">"#app"</span>,</span><br><span class="line">    render: <span class="function"><span class="params">h</span> =&gt;</span> h(App)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 启动 vue serve</span></span><br></pre></td></tr></table></figure>

<p>App.vue</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Menu</span> <span class="attr">:data</span>=<span class="string">"data"</span>&gt;</span><span class="tag">&lt;/<span class="name">Menu</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line">    data()&#123;</span><br><span class="line"><span class="javascript">        <span class="keyword">return</span> &#123;</span></span><br><span class="line">            data:[</span><br><span class="line">                    &#123;</span><br><span class="line"><span class="javascript">                    name: <span class="string">"导航一"</span>,</span></span><br><span class="line">                    id: 1,</span><br><span class="line">                    children: [</span><br><span class="line">                        &#123;</span><br><span class="line"><span class="javascript">                        name: <span class="string">"导航1.1"</span>,</span></span><br><span class="line">                        id: 1.1,</span><br><span class="line">                        children: [</span><br><span class="line"><span class="javascript">                            &#123; <span class="attr">name</span>: <span class="string">"导航1.1.1"</span>, <span class="attr">id</span>: <span class="number">1.3</span> &#125;,</span></span><br><span class="line">                            &#123;</span><br><span class="line"><span class="javascript">                            name: <span class="string">"导航1.1.2"</span>,</span></span><br><span class="line">                            id: 1.4,</span><br><span class="line">                            children: [</span><br><span class="line"><span class="javascript">                                &#123; <span class="attr">name</span>: <span class="string">"导航1.1.2.1"</span>, <span class="attr">id</span>: <span class="number">1.5</span> &#125;,</span></span><br><span class="line"><span class="javascript">                                &#123; <span class="attr">name</span>: <span class="string">"导航1.1.2.2"</span>, <span class="attr">id</span>: <span class="number">1.6</span> &#125;</span></span><br><span class="line">                            ]</span><br><span class="line">                            &#125;</span><br><span class="line">                        ]</span><br><span class="line">                        &#125;,</span><br><span class="line"><span class="javascript">                        &#123; <span class="attr">name</span>: <span class="string">"导航1.2"</span>, <span class="attr">id</span>: <span class="number">1.2</span> &#125;</span></span><br><span class="line">                    ]</span><br><span class="line">                    &#125;,</span><br><span class="line"><span class="javascript">                    &#123; <span class="attr">name</span>: <span class="string">"导航二"</span>, <span class="attr">id</span>: <span class="number">2</span> &#125;,</span></span><br><span class="line"><span class="javascript">                    &#123; <span class="attr">name</span>: <span class="string">"导航三"</span>, <span class="attr">id</span>: <span class="number">3</span> &#125;,</span></span><br><span class="line"><span class="javascript">                    &#123; <span class="attr">name</span>: <span class="string">"导航三"</span>, <span class="attr">id</span>: <span class="number">4</span> &#125;</span></span><br><span class="line">                ]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>menu.vue</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">zf-menu</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 1）这里先循环一次--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">template</span> <span class="attr">v-for</span>=<span class="string">"menu in data"</span>&gt;</span></span><br><span class="line">             <span class="comment">&lt;!-- &lt;zf-subMenu v-if="menu.children" :key="menu.id"&gt;</span></span><br><span class="line"><span class="comment">                 &lt;template slot="title"&gt;&#123;&#123;menu.name&#125;&#125;&lt;/template&gt;</span></span><br><span class="line"><span class="comment">             &lt;/zf-subMenu&gt; --&gt;</span></span><br><span class="line">             <span class="comment">&lt;!-- 2） 将有可能重复的项 再次循环 --&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">Resub</span> <span class="attr">v-if</span>=<span class="string">"menu.children"</span> <span class="attr">:key</span>=<span class="string">"menu.id"</span> <span class="attr">:data</span>=<span class="string">"menu"</span>&gt;</span><span class="tag">&lt;/<span class="name">Resub</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">zf-menu-item</span> <span class="attr">v-else</span> <span class="attr">:key</span>=<span class="string">"menu.id"</span>&gt;</span>&#123;&#123;menu.name&#125;&#125;<span class="tag">&lt;/<span class="name">zf-menu-item</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">zf-menu</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line">    mounted()&#123;</span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="string">"menu数据:"</span>, <span class="keyword">this</span>.data);</span></span><br><span class="line">    &#125;,</span><br><span class="line">    props:&#123;</span><br><span class="line">        data:&#123;</span><br><span class="line"><span class="javascript">            type: <span class="built_in">Array</span>,</span></span><br><span class="line"><span class="javascript">            <span class="keyword">default</span>:<span class="function"><span class="params">()</span>=&gt;</span>[]</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>新建 Resub.vue</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">zf-subMenu</span> &gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 标题 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">template</span> <span class="attr">slot</span>=<span class="string">"title"</span>&gt;</span>&#123;&#123;data.name&#125;&#125;<span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 内容 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">template</span> <span class="attr">v-for</span>=<span class="string">"menu in data.children"</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 3) 递归当前自己--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">Sub</span> <span class="attr">v-if</span>=<span class="string">"menu.children"</span> <span class="attr">:key</span>=<span class="string">"menu.id"</span> <span class="attr">:data</span>=<span class="string">"menu"</span>&gt;</span><span class="tag">&lt;/<span class="name">Sub</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">zf-menu-item</span> <span class="attr">v-else</span> <span class="attr">:key</span>=<span class="string">"menu.id"</span>&gt;</span>&#123;&#123;menu.name&#125;&#125;<span class="tag">&lt;/<span class="name">zf-menu-item</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">zf-subMenu</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="javascript">    name: <span class="string">'Sub'</span>, <span class="comment">// 当前组件的名称</span></span></span><br><span class="line">    mounted()&#123;</span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="string">"Resub数据:"</span>, <span class="keyword">this</span>.data);</span></span><br><span class="line">    &#125;,</span><br><span class="line">    props:&#123;</span><br><span class="line">        data:&#123;</span><br><span class="line"><span class="javascript">            type: <span class="built_in">Object</span>, <span class="comment">// 传进来的是包含children的对象</span></span></span><br><span class="line"><span class="javascript">            <span class="keyword">default</span>: <span class="function"><span class="params">()</span>=&gt;</span>(&#123;&#125;)</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>/components/ 下的3个子组件代码不变 如上</p>
<p>最终效果如下:</p>
<p><img src="https://jiafei2333.github.io/html/images/vue-menu-ui3.gif" alt></p>
<blockquote>
<p>总结：模板循环，递归组件</p>
</blockquote>
<h2 id="三、message组件"><a href="#三、message组件" class="headerlink" title="三、message组件"></a>三、message组件</h2><h3 id="前言-1"><a href="#前言-1" class="headerlink" title="前言"></a>前言</h3><p>先看下 仿的 element-ui中 message 组件的效果<br>App.vue</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"show"</span>&gt;</span>点我<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 先调用element-ui 的Message组件试试--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">import</span> &#123; Message &#125; <span class="keyword">from</span> <span class="string">'element-ui'</span>;</span></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line">    methods:&#123;</span><br><span class="line">        show()&#123;</span><br><span class="line">            Message.success(&#123;</span><br><span class="line"><span class="javascript">                message: <span class="string">'你好'</span>,</span></span><br><span class="line">                duration: 3000</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="https://jiafei2333.github.io/html/images/vue-message-ui.gif" alt></p>
<h3 id="实操-1"><a href="#实操-1" class="headerlink" title="实操"></a>实操</h3><h4 id="2-1-引入自己的库"><a href="#2-1-引入自己的库" class="headerlink" title="2.1 引入自己的库"></a>2.1 引入自己的库</h4><p>思路： 在点击的时候  创建一个组件 把这个组件放到页面body下 新建Message.vue</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"show"</span>&gt;</span>点我<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">import</span> &#123; Message &#125; <span class="keyword">from</span> <span class="string">'./Message'</span>; <span class="comment">// 这里引入自己的组件库</span></span></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line">    methods:&#123;</span><br><span class="line">        show()&#123;</span><br><span class="line"><span class="javascript">            Message.success(&#123; <span class="comment">// 这种调取方法参照element-ui中 单独引用</span></span></span><br><span class="line"><span class="javascript">                message: <span class="string">'你好'</span>,</span></span><br><span class="line">                duration: 3000</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>新建 Message.js</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> MessageComponent <span class="keyword">from</span> <span class="string">'./Message.vue'</span>;</span><br><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Message = &#123;</span><br><span class="line">    success(options)&#123;</span><br><span class="line">        <span class="comment">// options就是当前弹出来的框</span></span><br><span class="line">        <span class="comment">// alert(options)；</span></span><br><span class="line">        <span class="comment">// $mount() document.body.appendChild</span></span><br><span class="line">        <span class="keyword">let</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">            render: <span class="function"><span class="params">h</span> =&gt;</span> h(MessageComponent)</span><br><span class="line">        &#125;).$mount();</span><br><span class="line">        <span class="comment">// 点击弹窗 需要将.vue文件挂载到内存中(挂载到虚拟元素上)</span></span><br><span class="line">        <span class="comment">// 这里 vm就是 返回的渲染后的实例</span></span><br><span class="line">        <span class="comment">// vm.$el 就是DOM节点</span></span><br><span class="line">        <span class="comment">// 将渲染好的内容放到页面中</span></span><br><span class="line">        <span class="built_in">document</span>.body.appendChild(vm.$el);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">export</span> &#123;</span><br><span class="line">    Message</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>新建 Message.vue</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">        弹窗</span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="2-2-数据驱动视图"><a href="#2-2-数据驱动视图" class="headerlink" title="2.2 数据驱动视图"></a>2.2 数据驱动视图</h4><p>每次用户点击按钮时 都是增加数据 自动渲染到视图上<br>Message.js</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> MessageComponent <span class="keyword">from</span> <span class="string">'./Message.vue'</span>;</span><br><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Message = &#123;</span><br><span class="line">    success(options)&#123;</span><br><span class="line">        <span class="comment">// options就是当前弹出来的框</span></span><br><span class="line">        <span class="comment">// alert(options)；</span></span><br><span class="line">        <span class="comment">// $mount() document.body.appendChild</span></span><br><span class="line">        <span class="keyword">let</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">            render: <span class="function"><span class="params">h</span> =&gt;</span> h(MessageComponent)</span><br><span class="line">        &#125;).$mount();</span><br><span class="line">        <span class="comment">// 点击弹窗 需要将.vue文件挂载到内存中(挂载到虚拟元素上)</span></span><br><span class="line">        <span class="comment">// 这里 vm就是 返回的渲染后的实例</span></span><br><span class="line">        <span class="comment">// vm.$el 就是DOM节点</span></span><br><span class="line">        <span class="comment">// 将渲染好的内容放到页面中</span></span><br><span class="line">        <span class="built_in">document</span>.body.appendChild(vm.$el);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 现在希望通过数据来驱动， 而不是每次点都通过append渲染，点一次渲染一次点一次渲染一次，性能不好,</span></span><br><span class="line">        <span class="comment">// 如 Message.vue改成数据驱动视图</span></span><br><span class="line">        vm.$children[<span class="number">0</span>].add(options); <span class="comment">// 这里的vm.$children[0]就是添加的这个 MessageComponent，因为只添加了一个，所以这里是$children[0]</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">export</span> &#123;</span><br><span class="line">    Message</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Message.vue</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">v-for</span>=<span class="string">"(layer,index) in layers"</span> <span class="attr">:key</span>=<span class="string">"index"</span>&gt;</span></span><br><span class="line">            &#123;&#123;layer.message&#125;&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="javascript">    <span class="comment">// 每次用户点击按钮时 都是增加数据 自动渲染到视图上</span></span></span><br><span class="line">    data()&#123;</span><br><span class="line"><span class="javascript">        <span class="keyword">return</span> &#123;</span></span><br><span class="line">            layers:[]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line"><span class="javascript">    methods:&#123; <span class="comment">// 提供方法 供外界去调取   $children</span></span></span><br><span class="line">        add(options)&#123; </span><br><span class="line"><span class="javascript">            <span class="keyword">this</span>.layers.push(options);</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="https://jiafei2333.github.io/html/images/vue-message-ui1.gif" alt></p>
<p>现在情况是 一点击 创建一个实例(vm)，给实例添加options属性，没有累加的效果，每次点击都产生新的<br>需要将new Vue操作只做一次 ，不能重复new<br>用单例模式</p>
<h4 id="2-3-单例模式"><a href="#2-3-单例模式" class="headerlink" title="2.3 单例模式"></a>2.3 单例模式</h4><p>Message.js</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> instance;</span><br><span class="line"><span class="keyword">let</span> getVueInstance = <span class="function"><span class="params">()</span> =&gt;</span>&#123;</span><br><span class="line">    <span class="comment">// 此 instance 是全局的</span></span><br><span class="line">    instance = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">        render: <span class="function"><span class="params">h</span> =&gt;</span> h(MessageComponent)</span><br><span class="line">    &#125;).$mount();</span><br><span class="line">    <span class="comment">// 把生成的结果放到页面中</span></span><br><span class="line">    <span class="built_in">document</span>.body.appendChild(instance.$el);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> MessageComponent <span class="keyword">from</span> <span class="string">'./Message.vue'</span>;</span><br><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Message = &#123;</span><br><span class="line">    success(options)&#123;</span><br><span class="line">        !instance &amp;&amp; getVueInstance();</span><br><span class="line">        instance.$children[<span class="number">0</span>].add(options);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">export</span> &#123;</span><br><span class="line">    Message</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://jiafei2333.github.io/html/images/vue-message-ui2.gif" alt></p>
<p>如图可以看到每次都只在body中添加一个div，在这个div里面产生多个message组件，而不是一直在body中新增由div包裹的组件一直append</p>
<h4 id="2-4-设置定时-时间到销毁"><a href="#2-4-设置定时-时间到销毁" class="headerlink" title="2.4 设置定时 时间到销毁"></a>2.4 设置定时 时间到销毁</h4><p>增加序号，时间到了，需要根据序号删除<br>Message.vue</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">v-for</span>=<span class="string">"(layer,index) in layers"</span> <span class="attr">:key</span>=<span class="string">"index"</span>&gt;</span></span><br><span class="line">            &#123;&#123;layer.message&#125;&#125; &#123;&#123;layer.id&#125;&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="javascript">    <span class="comment">// 每次用户点击按钮时 都是增加数据 自动渲染到视图上</span></span></span><br><span class="line">    data()&#123;</span><br><span class="line"><span class="javascript">        <span class="keyword">return</span> &#123;</span></span><br><span class="line">            layers:[]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    mounted()&#123;</span><br><span class="line"><span class="javascript">        <span class="keyword">this</span>.id = <span class="number">0</span>;</span></span><br><span class="line">    &#125;,</span><br><span class="line"><span class="javascript">    methods:&#123; <span class="comment">// 提供方法 供外界去调取   $children</span></span></span><br><span class="line"><span class="javascript">        add(options)&#123; <span class="comment">// 增加序号，时间到了，需要根据序号删除</span></span></span><br><span class="line"><span class="javascript">            <span class="keyword">let</span> layer = &#123;...options, <span class="attr">id</span>: ++<span class="keyword">this</span>.id&#125;;</span></span><br><span class="line"><span class="javascript">            layer.timer = setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">                <span class="keyword">this</span>.remove(layer);</span></span><br><span class="line">            &#125;, options.duration);</span><br><span class="line"></span><br><span class="line"><span class="javascript">            <span class="keyword">this</span>.layers.push(layer);</span></span><br><span class="line">        &#125;,</span><br><span class="line">        remove(layer)&#123;</span><br><span class="line">            clearTimeout(layer.timer);</span><br><span class="line"><span class="javascript">            <span class="keyword">this</span>.layers = <span class="keyword">this</span>.layers.filter(<span class="function"><span class="params">item</span>=&gt;</span> item.id !== layer.id);</span></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="2-5-全局引入的方式"><a href="#2-5-全局引入的方式" class="headerlink" title="2.5 全局引入的方式"></a>2.5 全局引入的方式</h4><p>上面是单独引入Message的方式调取 这里参考element-ui 中</p>
<blockquote>
<p>原文： 全局方法   Element 为 Vue.prototype 添加了全局方法 $message。因此在 vue instance 中可以采用本页面中的方式调用 Message。 </p>
</blockquote>
<p>即可以通过 this.$message 调取 如下：<br>Message.js</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> instance;</span><br><span class="line"><span class="keyword">let</span> getVueInstance = <span class="function"><span class="params">()</span> =&gt;</span>&#123;</span><br><span class="line">    instance = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">        render: <span class="function"><span class="params">h</span> =&gt;</span> h(MessageComponent)</span><br><span class="line">    &#125;).$mount();</span><br><span class="line">    <span class="built_in">document</span>.body.appendChild(instance.$el);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> MessageComponent <span class="keyword">from</span> <span class="string">'./Message.vue'</span>;</span><br><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Message = &#123;</span><br><span class="line">    success(options)&#123;</span><br><span class="line">        !instance &amp;&amp; getVueInstance();</span><br><span class="line">        instance.$children[<span class="number">0</span>].add(&#123;</span><br><span class="line">            ...options,</span><br><span class="line">            type: <span class="string">'success'</span></span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;,</span><br><span class="line">    info()&#123;&#125;,</span><br><span class="line">    warn()&#123;&#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">export</span> &#123;</span><br><span class="line">    Message</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 现在如App.vue line6调取方式可知 走的是如下的export</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span>&#123;</span><br><span class="line">    <span class="comment">// _Vue是当前的构造函数，默认Vue.use(line7) 就会使用调用这个方法</span></span><br><span class="line">    install(_Vue)&#123;</span><br><span class="line">        <span class="comment">// 当前的这个_Vue是 App.vue中line5引入的Vue</span></span><br><span class="line">        <span class="comment">// 这个install里面主要做什么: 1） 注册全局组件(Vue.component); 2) 注册全局指令； 3）往原型上添加方法、属性</span></span><br><span class="line">        <span class="keyword">let</span> $message = &#123;&#125;;</span><br><span class="line">        <span class="built_in">Object</span>.keys(Message).forEach(<span class="function"><span class="params">key</span>=&gt;</span>&#123;</span><br><span class="line">            $message[key] = Message[key];</span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="comment">// 一般使用新对象时 采用拷贝的方式</span></span><br><span class="line">        Vue.prototype.$message = $message;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>App.vue</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"show"</span>&gt;</span>点我<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span>; <span class="comment">// 模块之间是独立的，因为下面要用到Vue,所以这里需要引入Vue</span></span></span><br><span class="line"><span class="javascript"><span class="keyword">import</span> ZfUi <span class="keyword">from</span> <span class="string">'./Message'</span>;</span></span><br><span class="line">Vue.use(ZfUi);</span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line">    methods:&#123;</span><br><span class="line">        show()&#123;</span><br><span class="line"><span class="javascript">            <span class="keyword">this</span>.$message.success(&#123;</span></span><br><span class="line"><span class="javascript">                message: <span class="string">'你好'</span>,</span></span><br><span class="line">                duration: 3000</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>执行 还是跟之前的使用效果一样的 和 图 设置定时时间到销毁  一样</p>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue核心应用（五）— 组件间的通讯</title>
    <url>/2019/10/29/Vue-component/</url>
    <content><![CDATA[<h2 id="Vue-CLI-快速原型开发"><a href="#Vue-CLI-快速原型开发" class="headerlink" title="Vue CLI 快速原型开发"></a>Vue CLI 快速原型开发</h2><h3 id="安装工具"><a href="#安装工具" class="headerlink" title="安装工具"></a>安装工具</h3><ul>
<li>npm install @vue/cli@3 -g</li>
<li>npm install @vue/cli-service-global@3 -g</li>
</ul>
<p>启动 vue serve</p>
<a id="more"></a>

<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><h3 id="1）son1改parent中的钱"><a href="#1）son1改parent中的钱" class="headerlink" title="1）son1改parent中的钱"></a>1）son1改parent中的钱</h3><p>入口文件 main.js</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span>;</span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">'./App'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当前文件的作用 主要：加载全局样式 全局组件 全局指令</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//1.入口文件 webpack会根据这个入口文件进行打包(这里不需要额外安装webpack，上面的包里已集成)</span></span><br><span class="line"><span class="comment">//2.默认会渲染App.vue组件</span></span><br><span class="line"><span class="comment">// 创建一个vue实例</span></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    el: <span class="string">'#app'</span>,</span><br><span class="line">    render:<span class="function"><span class="params">h</span>=&gt;</span>h(App) <span class="comment">// 用h(createElement)</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// vue serve 启动  会默认去找当前文件夹下的main.js 没有就找App.vue</span></span><br></pre></td></tr></table></figure>

<p>App.vue</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--根实例 根组件--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Parent</span> @<span class="attr">say</span>=<span class="string">"say"</span>&gt;</span><span class="tag">&lt;/<span class="name">Parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="comment">// 组件使用的三部： 声明 + 注册 + 使用</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">import</span> Parent <span class="keyword">from</span> <span class="string">'./components/parent'</span>;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">export</span> <span class="keyword">default</span>&#123;</span></span><br><span class="line">        components:&#123;</span><br><span class="line">            Parent</span><br><span class="line">        &#125;,</span><br><span class="line">        methods:&#123;</span><br><span class="line">            say()&#123;</span><br><span class="line"><span class="javascript">                <span class="built_in">console</span>.log(<span class="string">'say'</span>);</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>组件（components）<br>/components/parent.vue</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">        父亲有&#123;&#123;mny&#125;&#125;</span><br><span class="line">        <span class="comment">&lt;!-- 这里需要给子组件绑定一个自定义事件 --&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- son1.$on('changeItem', change)  'changeItem'是属性名，后面是值，绑定的是一个函数， = 号右边的内容都是当前组件的内容--&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 事件绑完之后在这个实例上有个属性 vm._event 订阅 原理--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Son1</span> <span class="attr">:mny</span>=<span class="string">"mny"</span> @<span class="attr">changeItem</span>=<span class="string">"change"</span>&gt;</span><span class="tag">&lt;/<span class="name">Son1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">import</span> Son1 <span class="keyword">from</span> <span class="string">'./son1'</span>;</span></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line">    components:&#123;</span><br><span class="line">        Son1</span><br><span class="line">    &#125;,</span><br><span class="line">    data()&#123;</span><br><span class="line"><span class="javascript">        <span class="keyword">return</span>&#123;</span></span><br><span class="line">            mny: 100</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    methods:&#123;</span><br><span class="line">        change(newValue)&#123;</span><br><span class="line"><span class="javascript">            <span class="keyword">this</span>.mny = newValue;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>/components/son1.vue<br>单向数据流 不能子组件直接修改父组件的数据 这里指mny 可以子组件点击让父组件修改</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">        son1  &#123;&#123;mny&#125;&#125;</span><br><span class="line">        <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"changeMoney()"</span>&gt;</span>修改钱<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span>&#123;</span></span><br><span class="line">    props:&#123;</span><br><span class="line">        mny:&#123;</span><br><span class="line"><span class="javascript">            type: <span class="built_in">Number</span> <span class="comment">// 校验类型</span></span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    methods:&#123;</span><br><span class="line">        changeMoney()&#123;</span><br><span class="line"><span class="javascript">            <span class="comment">// 这里面的这个this 就相当于 son1.$on('changeItem', change) 里面的son1</span></span></span><br><span class="line"><span class="javascript">            <span class="keyword">this</span>.$emit(<span class="string">'changeItem'</span>,<span class="number">200</span>);</span></span><br><span class="line"><span class="javascript">            <span class="built_in">console</span>.log(<span class="keyword">this</span>._events); <span class="comment">// 这里能够打印出发布订阅绑定的事件</span></span></span><br><span class="line"><span class="javascript">            <span class="comment">//  &#123;changeItem: Array(1)&#125; 如下图</span></span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="https://jiafei2333.github.io/html/images/vue-2.png" alt title="绑定的发布订阅事件"></p>
<h3 id="2-grandson1改parent中的钱"><a href="#2-grandson1改parent中的钱" class="headerlink" title="2) grandson1改parent中的钱"></a>2) grandson1改parent中的钱</h3><ul>
<li>孙=&gt;子=&gt;父 三层触发</li>
<li>.$parent.$parent.$parent 多级</li>
</ul>
<p>/components/son1.vue</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">        son1  &#123;&#123;mny&#125;&#125;</span><br><span class="line">        <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"changeMoney()"</span>&gt;</span>修改钱<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 给Grandson1绑定事件 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Grandson1</span> <span class="attr">:mny</span>=<span class="string">"mny"</span> @<span class="attr">changeGrand</span>=<span class="string">"grandChange"</span>&gt;</span><span class="tag">&lt;/<span class="name">Grandson1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">import</span> Grandson1 <span class="keyword">from</span> <span class="string">'./grandson1'</span>;</span></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span>&#123;</span></span><br><span class="line">    components:&#123;</span><br><span class="line">        Grandson1</span><br><span class="line">    &#125;,</span><br><span class="line">    props:&#123;</span><br><span class="line">        mny:&#123;</span><br><span class="line"><span class="javascript">            type: <span class="built_in">Number</span> <span class="comment">// 校验类型</span></span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    methods:&#123;</span><br><span class="line">        changeMoney()&#123;</span><br><span class="line"><span class="javascript">            <span class="comment">// 这里面的这个this 就相当于 son1.$on('changeItem', change) 里面的son1</span></span></span><br><span class="line"><span class="javascript">            <span class="keyword">this</span>.$emit(<span class="string">'changeItem'</span>,<span class="number">200</span>);</span></span><br><span class="line"><span class="javascript">            <span class="built_in">console</span>.log(<span class="keyword">this</span>._events); <span class="comment">// 这里能够打印出发布订阅绑定的事件</span></span></span><br><span class="line">        &#125;,</span><br><span class="line">        grandChange(newValue)&#123;</span><br><span class="line"><span class="javascript">            <span class="keyword">this</span>.$emit(<span class="string">'changeItem'</span>,newValue);</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>/components/grandson1.vue</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">        grandson1</span><br><span class="line">        &#123;&#123;mny&#125;&#125;</span><br><span class="line">        <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"changeMoney"</span>&gt;</span>孙子组件改变钱<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">export</span> <span class="keyword">default</span>&#123;</span></span><br><span class="line">        props:&#123;</span><br><span class="line">            mny:&#123;</span><br><span class="line"><span class="javascript">                type: <span class="built_in">Number</span></span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        methods:&#123;</span><br><span class="line">            changeMoney()&#123;</span><br><span class="line"><span class="javascript">                <span class="comment">// 触发自己的事件</span></span></span><br><span class="line"><span class="javascript">                <span class="keyword">this</span>.$emit(<span class="string">'changeGrand'</span>, <span class="number">300</span>); <span class="comment">// 孙=&gt;子=&gt;父 三层触发</span></span></span><br><span class="line"></span><br><span class="line"><span class="javascript">                <span class="comment">// this.$parent.$emit('changeItem', 400); // 直接触发父组件绑定的事件，当前父组件是另一个父组件的子组件，触发了绑定的该父组件的changeItem事件</span></span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>.$dispatch 自动向上查找</li>
</ul>
<p>/components/grandson1.vue</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">        grandson1</span><br><span class="line">        &#123;&#123;mny&#125;&#125;</span><br><span class="line">        <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"changeMoney"</span>&gt;</span>孙子组件改变钱<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">export</span> <span class="keyword">default</span>&#123;</span></span><br><span class="line">        props:&#123;</span><br><span class="line">            mny:&#123;</span><br><span class="line"><span class="javascript">                type: <span class="built_in">Number</span></span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        methods:&#123;</span><br><span class="line">            changeMoney()&#123;</span><br><span class="line"><span class="javascript">                <span class="comment">// 触发自己的事件</span></span></span><br><span class="line"><span class="javascript">                <span class="comment">// this.$emit('changeGrand', 300); // 孙=&gt;子=&gt;父 三层触发</span></span></span><br><span class="line"><span class="javascript">                <span class="comment">// this.$parent.$emit('changeItem', 400); // 直接触发父组件绑定的事件，当前父组件是另一个父组件的子组件，触发了绑定的该父组件的changeItem事件</span></span></span><br><span class="line"></span><br><span class="line"><span class="javascript">                <span class="keyword">this</span>.$dispatch(<span class="string">'changeItem'</span>, <span class="number">500</span>); </span></span><br><span class="line"><span class="javascript">                <span class="comment">// 自动向上查找他的父亲，有changeItem的话就触发   在main里写一个这个方法</span></span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>main.js</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Vue.prototype.$dispatch = <span class="function"><span class="keyword">function</span>(<span class="params">eventName,value</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> parent = <span class="keyword">this</span>.$parent; <span class="comment">// 先找第一层的parent</span></span><br><span class="line">    <span class="keyword">while</span>(parent)&#123;</span><br><span class="line">        parent.$emit(eventName,value); <span class="comment">// 触发方法</span></span><br><span class="line">        parent = parent.$parent; <span class="comment">// 接着向上找</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-往下"><a href="#3-往下" class="headerlink" title="3) 往下"></a>3) 往下</h3><blockquote>
<p>注意：一定要先订阅，才能触发</p>
</blockquote>
<p>触发所有子组件带有 eat 方法<br>main.js中写 $broadcast方法</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 验证这个方法 在App.vue中加个say，底下子组件调用 </span></span><br><span class="line">Vue.prototype.$broadcast = <span class="function"><span class="keyword">function</span>(<span class="params">eventName</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> children = <span class="keyword">this</span>.$children;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">broad</span>(<span class="params">children</span>)</span>&#123;</span><br><span class="line">        children.forEach(<span class="function"><span class="params">child</span> =&gt;</span> &#123; <span class="comment">// 如果自己的儿子下面还有儿子 继续查找</span></span><br><span class="line">            child.$emit(eventName); <span class="comment">// 触发当前儿子上的对应事件</span></span><br><span class="line">            <span class="keyword">if</span>(child.$children)&#123;</span><br><span class="line">                broad(child.$children)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    broad(children); <span class="comment">// 先找自己的儿子</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>App.vue</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--根实例 根组件--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Parent</span>&gt;</span><span class="tag">&lt;/<span class="name">Parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"broadcast"</span>&gt;</span>触发所有子组件带有 eat 的方法<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">import</span> Parent <span class="keyword">from</span> <span class="string">'./components/parent'</span>;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">export</span> <span class="keyword">default</span>&#123;</span></span><br><span class="line">        components:&#123;</span><br><span class="line">            Parent</span><br><span class="line">        &#125;,</span><br><span class="line">        methods:&#123;</span><br><span class="line">            broadcast()&#123;</span><br><span class="line"><span class="javascript">                <span class="built_in">console</span>.log(<span class="string">"App-this:"</span>, <span class="keyword">this</span>);</span></span><br><span class="line"><span class="javascript">                <span class="keyword">this</span>.$broadcast(<span class="string">'eat'</span>);</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>parent.vue</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 这里需要给子组件绑定一个自定义事件 --&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- son1.$on('changeItem', change)  'changeItem'是属性名，后面是值，绑定的是一个函数  =号右边的内容都是当前组件的内容--&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 事件绑完之后在这个实例上有个属性 vm._event 订阅 原理--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Son1</span> @<span class="attr">eat</span>=<span class="string">"eatFun"</span> &gt;</span><span class="tag">&lt;/<span class="name">Son1</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 注意： 这里的 @eat="eatFun" 就是订阅的过程，如果没有订阅 则不会触发。************************************************** --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">import</span> Son1 <span class="keyword">from</span> <span class="string">'./son1'</span>;</span></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line">    components:&#123;</span><br><span class="line">        Son1</span><br><span class="line">    &#125;,</span><br><span class="line">    methods:&#123;</span><br><span class="line">        eatFun()&#123;</span><br><span class="line"><span class="javascript">            <span class="built_in">console</span>.log(<span class="string">'parent-eat~'</span>)</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>son1.vue</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 给Grandson1绑定事件 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Grandson1</span> @<span class="attr">eat</span>=<span class="string">"eat"</span>&gt;</span><span class="tag">&lt;/<span class="name">Grandson1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">import</span> Grandson1 <span class="keyword">from</span> <span class="string">'./grandson1'</span>;</span></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span>&#123;</span></span><br><span class="line">    components:&#123;</span><br><span class="line">        Grandson1</span><br><span class="line">    &#125;,</span><br><span class="line">    methods:&#123;</span><br><span class="line">        eat()&#123;</span><br><span class="line"><span class="javascript">            <span class="built_in">console</span>.log(<span class="string">'son-eat~~'</span>);</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>点击App.vue中的 <button>触发所有子组件带有 eat 的方法</button>，打印: parent-eat~  &nbsp;&nbsp; son-eat~~</p>
<h3 id="4-子组件-gt-父组件（多种写法）"><a href="#4-子组件-gt-父组件（多种写法）" class="headerlink" title="4) 子组件 =&gt; 父组件（多种写法）"></a>4) 子组件 =&gt; 父组件（多种写法）</h3><h4 id="gt-4-1"><a href="#gt-4-1" class="headerlink" title="&gt; 4.1"></a>&gt; 4.1</h4><p>parent.vue</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Son2</span> <span class="attr">:count</span>=<span class="string">"count"</span> @<span class="attr">update:count</span>=<span class="string">"newValue=&gt;count=newValue"</span>&gt;</span><span class="tag">&lt;/<span class="name">Son2</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">import</span> Son2 <span class="keyword">from</span> <span class="string">'./son2'</span>;</span></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line">    components:&#123;</span><br><span class="line">        Son2</span><br><span class="line">    &#125;,</span><br><span class="line">    data()&#123;</span><br><span class="line"><span class="javascript">        <span class="keyword">return</span>&#123;</span></span><br><span class="line">            count: 1,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>son2.vue</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">        son2</span><br><span class="line">        count: &#123;&#123;count&#125;&#125;</span><br><span class="line">        <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"changeCount"</span>&gt;</span>点我改变count<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line">    props:&#123;</span><br><span class="line">        count:&#123;</span><br><span class="line"><span class="javascript">            type: <span class="built_in">Number</span> <span class="comment">// 类型检测</span></span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    methods:&#123;</span><br><span class="line">        changeCount()&#123;</span><br><span class="line"><span class="javascript">            <span class="keyword">this</span>.$emit(<span class="string">"update:count"</span>,<span class="number">2</span>); <span class="comment">//注意这里触发的写法 ****************************************</span></span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>点击子组件 <button>点我改变count</button>，修改父组件 count的值  1 =&gt; 2</p>
<h4 id="gt-4-2"><a href="#gt-4-2" class="headerlink" title="&gt; 4.2"></a>&gt; 4.2</h4><p>parent.vue</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- &lt;Son2 :count="count" @update:count="newValue=&gt;count=newValue"&gt;&lt;/Son2&gt; --&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--1.下面是上一行的语法糖 写成 :count.sync 那么子组件中$emit触发的事件必须是 update:变量名 这里是count--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Son2</span> <span class="attr">:count.sync</span>=<span class="string">"count"</span>&gt;</span><span class="tag">&lt;/<span class="name">Son2</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">import</span> Son2 <span class="keyword">from</span> <span class="string">'./son2'</span>;</span></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line">    components:&#123;</span><br><span class="line">        Son2</span><br><span class="line">    &#125;,</span><br><span class="line">    data()&#123;</span><br><span class="line"><span class="javascript">        <span class="keyword">return</span>&#123;</span></span><br><span class="line">            count: 1,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>son2.vue</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">        son2</span><br><span class="line">        count: &#123;&#123;count&#125;&#125;</span><br><span class="line">        <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"changeCount"</span>&gt;</span>点我改变count<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line">    props:&#123;</span><br><span class="line">        count:&#123;</span><br><span class="line"><span class="javascript">            type: <span class="built_in">Number</span> <span class="comment">// 类型检测</span></span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    methods:&#123;</span><br><span class="line">        changeCount()&#123;</span><br><span class="line"><span class="javascript">            <span class="keyword">this</span>.$emit(<span class="string">"update:count"</span>,<span class="number">2</span>);</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>点击子组件 <button>点我改变count</button>，修改父组件 count的值  1 =&gt; 2</p>
<h4 id="gt-4-3"><a href="#gt-4-3" class="headerlink" title="&gt; 4.3"></a>&gt; 4.3</h4><p>parent.vue</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- &lt;Son2 :count="count" @update:count="newValue=&gt;count=newValue"&gt;&lt;/Son2&gt; --&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--1.上一行的语法糖 写成 :count.sync 那么子组件中$emit触发的事件必须是 update:变量名 这里是count--&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- &lt;Son2 :count.sync="count"&gt;&lt;/Son2&gt; --&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!--这里传过去的值不是名字不是count，而是value，对应的子组件也需要改下，触发的方法是 input--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Son2</span> <span class="attr">:value</span>=<span class="string">"count"</span> @<span class="attr">input</span>=<span class="string">"newValue=&gt;count=newValue"</span>&gt;</span><span class="tag">&lt;/<span class="name">Son2</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">import</span> Son2 <span class="keyword">from</span> <span class="string">'./son2'</span>;</span></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line">    components:&#123;</span><br><span class="line">        Son2</span><br><span class="line">    &#125;,</span><br><span class="line">    data()&#123;</span><br><span class="line"><span class="javascript">        <span class="keyword">return</span>&#123;</span></span><br><span class="line">            count: 1,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>son.vue</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- son2</span></span><br><span class="line"><span class="comment">        count: &#123;&#123;count&#125;&#125;</span></span><br><span class="line"><span class="comment">        &lt;button @click="changeCount"&gt;点我改变count&lt;/button&gt; --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">        "value":</span><br><span class="line">        &#123;&#123;value&#125;&#125;</span><br><span class="line">        <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"changeValue"</span>&gt;</span>点我改变value<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line">    props:&#123;</span><br><span class="line">        count:&#123;</span><br><span class="line"><span class="javascript">            type: <span class="built_in">Number</span> <span class="comment">// 类型检测</span></span></span><br><span class="line">        &#125;,</span><br><span class="line">        value:&#123;</span><br><span class="line"><span class="javascript">            type: <span class="built_in">Number</span></span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    methods:&#123;</span><br><span class="line"><span class="javascript">        <span class="comment">// changeCount()&#123;</span></span></span><br><span class="line"><span class="javascript">        <span class="comment">//     this.$emit("update:count",2);</span></span></span><br><span class="line"><span class="javascript">        <span class="comment">// &#125;,</span></span></span><br><span class="line">        changeValue()&#123;</span><br><span class="line"><span class="javascript">            <span class="keyword">this</span>.$emit(<span class="string">'input'</span>,<span class="number">3</span>);</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>点击子组件 <button>点我改变value</button>，修改父组件 count的值  1 =&gt; 3</p>
<h4 id="gt-4-4"><a href="#gt-4-4" class="headerlink" title="&gt; 4.4"></a>&gt; 4.4</h4><p>parent.vue</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- &lt;Son2 :count="count" @update:count="newValue=&gt;count=newValue"&gt;&lt;/Son2&gt; --&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--1.上一行的语法糖 写成 :count.sync 那么子组件中$emit触发的事件必须是 update:变量名 这里是count--&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- &lt;Son2 :count.sync="count"&gt;&lt;/Son2&gt; --&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!--这里传过去的值不是名字不是count，而是value，对应的子组件也需要改下，触发的方法是 input--&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- &lt;Son2 :value="count" @input="newValue=&gt;count=newValue"&gt;&lt;/Son2&gt;  --&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 2. 这个写法是上面写法的替代品，默认组件内部需要触发 input--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Son2</span> <span class="attr">v-model</span>=<span class="string">"count"</span>&gt;</span><span class="tag">&lt;/<span class="name">Son2</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- v-model局限 只能传递一个属性，如果只有一个可以使用v-model,多个依然需要使用.sync --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">import</span> Son2 <span class="keyword">from</span> <span class="string">'./son2'</span>;</span></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line">    components:&#123;</span><br><span class="line">        Son2</span><br><span class="line">    &#125;,</span><br><span class="line">    data()&#123;</span><br><span class="line"><span class="javascript">        <span class="keyword">return</span>&#123;</span></span><br><span class="line">            count: 1,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>son.vue</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- son2</span></span><br><span class="line"><span class="comment">        count: &#123;&#123;count&#125;&#125;</span></span><br><span class="line"><span class="comment">        &lt;button @click="changeCount"&gt;点我改变count&lt;/button&gt; --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">        "value":</span><br><span class="line">        &#123;&#123;value&#125;&#125;</span><br><span class="line">        <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"changeValue"</span>&gt;</span>点我改变value<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line">    props:&#123;</span><br><span class="line">        count:&#123;</span><br><span class="line"><span class="javascript">            type: <span class="built_in">Number</span> <span class="comment">// 类型检测</span></span></span><br><span class="line">        &#125;,</span><br><span class="line">        value:&#123;</span><br><span class="line"><span class="javascript">            type: <span class="built_in">Number</span></span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    methods:&#123;</span><br><span class="line"><span class="javascript">        <span class="comment">// changeCount()&#123;</span></span></span><br><span class="line"><span class="javascript">        <span class="comment">//     this.$emit("update:count",2);</span></span></span><br><span class="line"><span class="javascript">        <span class="comment">// &#125;,</span></span></span><br><span class="line">        changeValue()&#123;</span><br><span class="line"><span class="javascript">            <span class="keyword">this</span>.$emit(<span class="string">'input'</span>,<span class="number">3</span>);</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="5-传递多个属性"><a href="#5-传递多个属性" class="headerlink" title="5) 传递多个属性"></a>5) 传递多个属性</h3><p>将多个属性 mny、count都传给son2</p>
<h4 id="gt-5-1-attrs-属性的集合"><a href="#gt-5-1-attrs-属性的集合" class="headerlink" title="&gt; 5.1 $attrs 属性的集合"></a>&gt; 5.1 $attrs 属性的集合</h4><p>parent.vue</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;Son2 :mny=&quot;mny&quot; :count=&quot;count&quot;&gt;&lt;/Son2&gt;</span><br></pre></td></tr></table></figure>

<p>son2.vue</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">        son2</span><br><span class="line">        <span class="comment">&lt;!-- 属性的集合 --&gt;</span></span><br><span class="line">        &#123;&#123;$attrs&#125;&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>如下图：<br><img src="https://jiafei2333.github.io/html/images/vue-attr-1.png" alt></p>
<h4 id="gt-5-2-props-attrs"><a href="#gt-5-2-props-attrs" class="headerlink" title="&gt; 5.2 props + $attrs"></a>&gt; 5.2 props + $attrs</h4><p>parent.vue</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;Son2 :mny=&quot;mny&quot; :count=&quot;count&quot;&gt;&lt;/Son2&gt;</span><br></pre></td></tr></table></figure>

<p>son2.vue</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">        son2</span><br><span class="line">        <span class="comment">&lt;!-- //属性的集合 --&gt;</span></span><br><span class="line">        &#123;&#123;$attrs&#125;&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="comment">// 如果组件中使用了 props 就会将 attrs 从当前的 $attrs 移除掉</span></span></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line">    props:&#123;</span><br><span class="line"><span class="javascript">        mny:&#123;&#125; <span class="comment">// 从$attrs中移除mny属性</span></span></span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>如下图：<br><img src="https://jiafei2333.github.io/html/images/vue-attr-2.png" alt></p>
<h4 id="gt-5-3-inheritAttrs"><a href="#gt-5-3-inheritAttrs" class="headerlink" title="&gt; 5.3 inheritAttrs"></a>&gt; 5.3 inheritAttrs</h4><p>parent.vue</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;Son2 :mny=&quot;mny&quot; :count=&quot;count&quot;&gt;&lt;/Son2&gt;</span><br></pre></td></tr></table></figure>

<p>son2.vue</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">        son2</span><br><span class="line">        <span class="comment">&lt;!-- //属性的集合 --&gt;</span></span><br><span class="line">        &#123;&#123;$attrs&#125;&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="comment">// 如果组件中使用了 props 就会将 attrs 从当前的 $attrs 移除掉</span></span></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="javascript">    <span class="comment">// props:&#123;</span></span></span><br><span class="line"><span class="javascript">    <span class="comment">//     mny:&#123;&#125; // 从$attrs中移除mny属性</span></span></span><br><span class="line"><span class="javascript">    <span class="comment">// &#125;,</span></span></span><br><span class="line"><span class="javascript">    <span class="comment">// 不用props写 也可以用下面这个属性</span></span></span><br><span class="line"><span class="javascript">    inheritAttrs: <span class="literal">false</span>,</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>如下图：<br><img src="https://jiafei2333.github.io/html/images/vue-attr-3.png" alt></p>
<blockquote>
<p>官方文档：<br>inheritAttrs: 默认情况下父作用域的不被认作 props 的特性绑定 (attribute bindings) 将会“回退”且作为普通的 HTML 特性应用在子组件的根元素上。当撰写包裹一个目标元素或另一个组件的组件时，这可能不会总是符合预期行为。通过设置 inheritAttrs 到 false，这些默认行为将会被去掉。而通过 (同样是 2.4 新增的) 实例属性 $attrs 可以让这些特性生效，且可以通过 v-bind 显性的绑定到非根元素上。 inheritAttrs默认为true。</p>
</blockquote>
<h4 id="gt-5-4-attrs-应用"><a href="#gt-5-4-attrs-应用" class="headerlink" title="&gt; 5.4 $attrs 应用"></a>&gt; 5.4 $attrs 应用</h4><p>父传递给子 =&gt; 儿子 有属性用不到 =&gt; 孙子<br>parent.vue</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;Son2 :mny=&quot;mny&quot; :count=&quot;count&quot;&gt;&lt;/Son2&gt;</span><br></pre></td></tr></table></figure>

<p>son2.vue</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">        son2</span><br><span class="line">        <span class="comment">&lt;!-- 属性的集合 --&gt;</span></span><br><span class="line">        &#123;&#123;$attrs.mny&#125;&#125;</span><br><span class="line">        <span class="tag">&lt;<span class="name">Grandson2</span> <span class="attr">v-bind</span>=<span class="string">"$attrs"</span>&gt;</span><span class="tag">&lt;/<span class="name">Grandson2</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 可以理解为把当前组件的所有属性都传递下去 如果这里line19-23注释打开，即props里面有用到属性，那么mny属性就不会往下传--&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">import</span> Grandson2 <span class="keyword">from</span> <span class="string">'./grandson2'</span>;</span></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line">    components:&#123;</span><br><span class="line">        Grandson2</span><br><span class="line">    &#125;,</span><br><span class="line"><span class="javascript">    inheritAttrs: <span class="literal">false</span>,</span></span><br><span class="line"><span class="javascript">    <span class="comment">// props:&#123;</span></span></span><br><span class="line"><span class="javascript">    <span class="comment">//     mny:&#123;</span></span></span><br><span class="line"><span class="javascript">    <span class="comment">//         type:Number</span></span></span><br><span class="line"><span class="javascript">    <span class="comment">//     &#125;</span></span></span><br><span class="line"><span class="javascript">    <span class="comment">// &#125;,</span></span></span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>如下图：<br><img src="https://jiafei2333.github.io/html/images/vue-attr-4.png" alt></p>
<h4 id="6-传递事件"><a href="#6-传递事件" class="headerlink" title="6) 传递事件"></a>6) 传递事件</h4><p>要给组件传递一个show方法  跨组件传递 父 =&gt; 孙 </p>
<h5 id="gt-6-1-native"><a href="#gt-6-1-native" class="headerlink" title="&gt; 6.1 .native"></a>&gt; 6.1 .native</h5><p>parent.vue</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span>		</span><br><span class="line">        <span class="comment">&lt;!-- 传递事件 要给组件传递一个show方法  跨组件传递 父 =&gt; 孙 --&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 如下这样写，给Son2绑定show方法，点击Son2是不会有click事件的，因为这是自定义事件 这个@click和上面的 @input一样，名字和原生事件相同 想要变成原生事件可以如下加上.navive--&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 这时点击son2组件没有反应 *********************************--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Son2</span> <span class="attr">:mny</span>=<span class="string">"mny"</span> <span class="attr">:count</span>=<span class="string">"count"</span> @<span class="attr">click</span>=<span class="string">"show"</span>&gt;</span><span class="tag">&lt;/<span class="name">Son2</span>&gt;</span>  </span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- .native 就是给组件的最外层div元素上绑定事件--&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 这时点击son2组件最外层就会触发show事件 ***********************--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Son2</span> <span class="attr">:mny</span>=<span class="string">"mny"</span> <span class="attr">:count</span>=<span class="string">"count"</span> @<span class="attr">click.native</span>=<span class="string">"show"</span>&gt;</span><span class="tag">&lt;/<span class="name">Son2</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">import</span> Son2 <span class="keyword">from</span> <span class="string">'./son2'</span>;</span></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line">    components:&#123;</span><br><span class="line">        Son2</span><br><span class="line">    &#125;,</span><br><span class="line">    data()&#123;</span><br><span class="line"><span class="javascript">        <span class="keyword">return</span>&#123;</span></span><br><span class="line">            mny: 100,</span><br><span class="line">            count: 1,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    methods:&#123;</span><br><span class="line">        show()&#123;</span><br><span class="line"><span class="javascript">            <span class="built_in">console</span>.log(<span class="string">'show~~'</span>);</span></span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h5 id="gt-6-2-listeners"><a href="#gt-6-2-listeners" class="headerlink" title="&gt; 6.2 $listeners"></a>&gt; 6.2 $listeners</h5><p>现在希望点击 grandson2 中的 button 时才触发 parent 中的 show 方法<br>在son2中添加$listeners<br>parnet.vue</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 现在希望点击grandson中的button时才触发show方法   在son2中添加$listeners  这里的 @click @mouseup 都不是原生事件 同名而已--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">Son2</span> <span class="attr">:mny</span>=<span class="string">"mny"</span> <span class="attr">:count</span>=<span class="string">"count"</span> @<span class="attr">click</span>=<span class="string">"show"</span> @<span class="attr">mouseup</span>=<span class="string">"show"</span>&gt;</span><span class="tag">&lt;/<span class="name">Son2</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>son2.vue</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 传递事件  可以在mounted中打印  v-bind 将属性全部向下传递  方法绑定v-on 将方法全部向下传递 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Grandson2</span> <span class="attr">v-bind</span>=<span class="string">"$attrs"</span> <span class="attr">v-on</span>=<span class="string">"$listeners"</span>&gt;</span><span class="tag">&lt;/<span class="name">Grandson2</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">import</span> Grandson2 <span class="keyword">from</span> <span class="string">'./grandson2'</span>;</span></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line">    mounted()&#123;</span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="string">"listeners:"</span>,<span class="keyword">this</span>.$listeners); <span class="comment">// 如下图</span></span></span><br><span class="line">    &#125;,</span><br><span class="line">    components:&#123;</span><br><span class="line">        Grandson2</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="https://jiafei2333.github.io/html/images/vue-attr-5.png" alt></p>
<p>grandson2.vue</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">        grandson2</span><br><span class="line">        &#123;&#123;$attrs&#125;&#125;</span><br><span class="line">        <span class="comment">&lt;!-- 这里的 @click 和 $mouseup 是原生的--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"$listeners.click"</span>&gt;</span>点我click<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">button</span> @<span class="attr">mouseup</span>=<span class="string">"$listeners.mouseup"</span>&gt;</span>点我mouseup<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>如上，点击 grandson2.vue 中的 button 触发的是 parent.vue 中的say方法</p>
<h5 id="gt-6-3-provide-amp-amp-inject"><a href="#gt-6-3-provide-amp-amp-inject" class="headerlink" title="&gt; 6.3 provide &amp;&amp; inject"></a>&gt; 6.3 provide &amp;&amp; inject</h5><p>grandson2.vue 触发 App.vue 中的方法</p>
<p>App.vue</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">import</span> Parent <span class="keyword">from</span> <span class="string">'./components/parent'</span>;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">export</span> <span class="keyword">default</span>&#123;</span></span><br><span class="line">        provide()&#123;</span><br><span class="line"><span class="javascript">            <span class="keyword">return</span> &#123; <span class="attr">vm</span>: <span class="keyword">this</span>&#125; <span class="comment">// 暴露全局方法</span></span></span><br><span class="line">        &#125;,</span><br><span class="line">        components:&#123;</span><br><span class="line">            Parent</span><br><span class="line">        &#125;,</span><br><span class="line">        methods:&#123;</span><br><span class="line">            say()&#123;</span><br><span class="line"><span class="javascript">                <span class="built_in">console</span>.log(<span class="string">'say-provide'</span>);</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>grandson2.vue</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="javascript">    inject:[<span class="string">'vm'</span>],  <span class="comment">// 注入 会向上查找  如果重名，找到就停止。</span></span></span><br><span class="line">    mounted()&#123;</span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.vm); <span class="comment">// 这个vm就是App.vue组件的实例</span></span></span><br><span class="line"><span class="javascript">        <span class="keyword">this</span>.vm.say(); <span class="comment">// 可以直接触发父级方法</span></span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h5 id="gt-6-4-ref-amp-amp-ref"><a href="#gt-6-4-ref-amp-amp-ref" class="headerlink" title="&gt; 6.4 ref &amp;&amp; $ref"></a>&gt; 6.4 ref &amp;&amp; $ref</h5><p>parent.vue</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- ref示例 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Son2</span> <span class="attr">ref</span>=<span class="string">"son2"</span> <span class="attr">:mny</span>=<span class="string">"mny"</span> <span class="attr">:count</span>=<span class="string">"count"</span> @<span class="attr">click</span>=<span class="string">"show"</span> @<span class="attr">mouseup</span>=<span class="string">"show"</span>&gt;</span><span class="tag">&lt;/<span class="name">Son2</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">import</span> Son2 <span class="keyword">from</span> <span class="string">'./son2'</span>;</span></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="javascript">    <span class="comment">// refs 示例</span></span></span><br><span class="line">    mounted()&#123;</span><br><span class="line"><span class="javascript">        <span class="keyword">this</span>.$refs.son2.alertLayer(); <span class="comment">// 直接在父组件中拿到组件的实例，并且ref不要重名，只有v-for才会出现数组的情况</span></span></span><br><span class="line">    &#125;,</span><br><span class="line">    components:&#123;</span><br><span class="line">        Son2</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>son2.vue</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line">    methods:&#123;</span><br><span class="line"><span class="javascript">        alertLayer()&#123;<span class="comment">// ref示例</span></span></span><br><span class="line"><span class="javascript">            alert(<span class="string">"ref示例"</span>);</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>如上，页面弹出 alert(“ref示例”)；</p>
<p>和上述 <code>provide &amp;&amp; inject</code> 相反，<code>provide &amp;&amp; inject</code>是父组件将实例暴露出来供子组件调用，<code>ref</code>是父组件去调用子组件的实例。</p>
<h5 id="gt-6-5-bus"><a href="#gt-6-5-bus" class="headerlink" title="&gt; 6.5 $bus"></a>&gt; 6.5 $bus</h5><p>main.js</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建一个全局的发布订阅 偶尔用一次还可以，使用起来比较混乱</span></span><br><span class="line">Vue.prototype.$bus = <span class="keyword">new</span> Vue(); <span class="comment">// 创建一个实例 把它放到$bus上</span></span><br><span class="line"><span class="comment">// 创建的这个vue实例上有 $on  $emit ，这样就可以去任何的一个组件中绑定事件</span></span><br><span class="line"><span class="comment">// 这样就可以全局调用 $bus</span></span><br></pre></td></tr></table></figure>

<p>parent.vue</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">import</span> Son2 <span class="keyword">from</span> <span class="string">'./son2'</span>;</span></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line">    mounted()&#123;</span><br><span class="line"><span class="javascript">        <span class="keyword">this</span>.$bus.$on(<span class="string">"changeBus"</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="comment">// this.$bus 是通过全局的实例去绑定事件 (订阅)</span></span></span><br><span class="line"><span class="javascript">            <span class="built_in">console</span>.log(<span class="string">"change bus绑定事件"</span>)</span></span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;,</span><br><span class="line">    components:&#123;</span><br><span class="line">        Son2</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>grandson2.vue</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line">    mounted()&#123;</span><br><span class="line"><span class="javascript">        <span class="keyword">this</span>.$bus.$emit(<span class="string">"changeBus"</span>); <span class="comment">//这样是不会执行的，多级组件的挂载顺序 </span></span></span><br><span class="line"><span class="javascript">        <span class="comment">// 可以</span></span></span><br><span class="line"><span class="javascript">        <span class="keyword">this</span>.$nextTick(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">this</span>.$bus.$emit(<span class="string">"changeBus"</span>);</span></span><br><span class="line">        &#125;)</span><br><span class="line"><span class="javascript">        <span class="comment">// 这样就会执行 console.log 打印出 change bus绑定事件</span></span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>父传递给子数据 props emit （这个用的多些）</li>
<li>$parent $children</li>
<li>$attrs $listeners</li>
<li>provide inject  和 context很像 （可以在父组件中声明一个公共数据），在子组件中可以注入原理 (特点：比较混乱，名称问题 他不会在业务代码中使用) 组件库 多级通信时为了方便可以使用provide</li>
<li>ref 能获取真实dom元素，如果放到组件上 代表的是 当前组件的实例 ,父组件中可以直接获取子组件的方法或者数据 示例 6.4</li>
<li>eventbus (像 $parent，$children 中，比如 a.$on() 必须 a.$emit() 来触发， b.$emit() 不行) 绑定 $on 只能通过绑定 $on 的那个组件来触发， (这里 eventbus 使用混乱，不管在哪里绑定都能触发 $bus )</li>
</ul>
<p>vue 初学者用 props + emit 就够用了</p>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue核心应用（四）— 生命周期</title>
    <url>/2019/10/29/Vue-core-4/</url>
    <content><![CDATA[<h2 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h2><p><img src="https://cn.vuejs.org/images/lifecycle.png" alt title="生命周期"></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"./node_modules/vue/dist/vue.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">let</span> vm = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">            <span class="comment">// el: "#app", // 和下面的 vm.$mount是一样的</span></span></span><br><span class="line"><span class="javascript">            <span class="comment">// 如图，初始化时：当前这个实例 他的父亲是谁 儿子是谁（当有父子组件关系的时候可以看到 parent|children ） 有一套发布订阅 $on $emit</span></span></span><br><span class="line"><span class="javascript">            beforeCreate()&#123; <span class="comment">// 回调函数</span></span></span><br><span class="line"><span class="javascript">                <span class="comment">// 创建之前</span></span></span><br><span class="line"><span class="javascript">                <span class="built_in">console</span>.log(<span class="keyword">this</span>); <span class="comment">// 打印的this依然是这个实例</span></span></span><br><span class="line"><span class="javascript">                <span class="comment">// debugger;</span></span></span><br><span class="line"><span class="javascript">                <span class="comment">// 混合 希望在每个组件中增加一些特定的属性，可以采用这个钩子, 但是这里不能取到data、methods、watch，基本上业务逻辑是不需要他的</span></span></span><br><span class="line"><span class="javascript">                <span class="built_in">console</span>.log(<span class="string">'before create'</span>);</span></span><br><span class="line">            &#125;,</span><br><span class="line">            created()&#123;</span><br><span class="line"><span class="javascript">                <span class="comment">// 当前这个组件实例 已经实现了数据劫持（data里面的数据已经加了getter、setter）,把方法、计算属性也都挂载到了实例上，但是不能获取到真实的dom元素</span></span></span><br><span class="line"><span class="javascript">                <span class="comment">// 这里从 beforeCreate()=&gt;create()是依次执行的，如果beforeCreate()里面有异步操作 不会等待，会接着走create()</span></span></span><br><span class="line"><span class="javascript">                <span class="built_in">console</span>.log(<span class="string">'created'</span>); <span class="comment">// 创建完成 这里可以放 ajax，并且不会阻塞渲染的过程，当ajax回调时可以将数据绑定到实例上，缺点是不能操作dom</span></span></span><br><span class="line"><span class="javascript">                <span class="built_in">console</span>.log(<span class="keyword">this</span>);</span></span><br><span class="line"><span class="javascript">                <span class="comment">// debugger;</span></span></span><br><span class="line">            &#125;,</span><br><span class="line">            data:&#123;</span><br><span class="line">                a: 1,</span><br><span class="line">            &#125;,</span><br><span class="line"><span class="javascript">            beforeMount()&#123; <span class="comment">// 调用render 但是一般不会增加业务逻辑</span></span></span><br><span class="line"><span class="javascript">                <span class="comment">// 1、如果这里没有写 el: "#app" | vm.$mount("#app"); 不会执行到这里</span></span></span><br><span class="line"><span class="javascript">                <span class="comment">// 2、 如果 vm.$mount(""); 为空，没有指定节点，那么默认会渲染到一个内存中的节点。 运行 报错：vue.js:634 [Vue warn]: Failed to mount component: template or render function not defined. (found in &lt;Root&gt;) 但是还是打印了'挂载之前',走到了这个钩子中</span></span></span><br><span class="line"><span class="javascript">                <span class="built_in">console</span>.log(<span class="string">'挂载之前'</span>);</span></span><br><span class="line">            &#125;,</span><br><span class="line"><span class="javascript">            <span class="comment">// 针对beforeMount() 中的问题，下面来添加render() 或者 template</span></span></span><br><span class="line"><span class="javascript">            <span class="comment">// 可以看到加了render之后 vm.$mount("");没有写挂载节点，页面没有报错； 如果有了render，就不会使用template，因为内部会把template渲染成render，在beforeMount()挂载之前调用render方法，优先级的话有render就不会调用template</span></span></span><br><span class="line"><span class="javascript">            <span class="comment">// render()&#123; </span></span></span><br><span class="line"><span class="javascript">            <span class="comment">//     console.log('render');</span></span></span><br><span class="line"><span class="javascript">            <span class="comment">// &#125;,</span></span></span><br><span class="line"><span class="xml">            // template: '<span class="tag">&lt;<span class="name">div</span>&gt;</span>hello<span class="tag">&lt;/<span class="name">div</span>&gt;</span>',</span></span><br><span class="line"><span class="javascript">            <span class="comment">// **********************************这个过程中会渲染子组件 像之前的那个切洋葱一样 的执行顺序</span></span></span><br><span class="line"><span class="javascript">			<span class="comment">// 父 beforeMount =&gt; 子 beforeMount =&gt; 子 Mounted =&gt; 父 Mounted</span></span></span><br><span class="line"><span class="javascript">            mounted()&#123; <span class="comment">// 一般会把ajax的操作放在mounted中，ajax是异步的，不会阻塞组件渲染</span></span></span><br><span class="line"><span class="javascript">                <span class="built_in">console</span>.log(<span class="string">'当前组件挂载完成'</span>);</span></span><br><span class="line"><span class="javascript">                <span class="built_in">console</span>.log(vm.$el);</span></span><br><span class="line">            &#125;,</span><br><span class="line"><span class="javascript">            beforeUpdate()&#123; <span class="comment">// 这个数据是应用在视图上的</span></span></span><br><span class="line"><span class="javascript">                <span class="built_in">console</span>.log(<span class="string">"数据更新之前"</span>); <span class="comment">//可以在这里增加一些数据更新，不会导致视图多次更新（用的很少）</span></span></span><br><span class="line">            &#125;,</span><br><span class="line"><span class="javascript">            <span class="comment">// 组件化的好处：方便复用，比较好维护，减少不必要的渲染</span></span></span><br><span class="line"><span class="javascript">            <span class="comment">// vue的更新方式是组件级别的</span></span></span><br><span class="line"><span class="javascript">            updated()&#123; <span class="comment">// 这里不要再去更新数据，可能发生死循环</span></span></span><br><span class="line"><span class="javascript">                <span class="built_in">console</span>.log(<span class="string">"更新完成"</span>);</span></span><br><span class="line">            &#125;,</span><br><span class="line"><span class="javascript">            beforeDestroy()&#123; <span class="comment">// 可以在这里做事件的移除 清空定时器</span></span></span><br><span class="line"><span class="javascript">                <span class="built_in">console</span>.log(<span class="string">"销毁前"</span>);</span></span><br><span class="line">            &#125;,</span><br><span class="line">            destroyed()&#123;</span><br><span class="line"><span class="javascript">                <span class="built_in">console</span>.log(<span class="string">"销毁后"</span>);</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line"><span class="javascript">        <span class="comment">// $mount 可以指定一个元素（放置真实节点的id），不指定元素的话，内部会默认渲染到一个内存中的节点</span></span></span><br><span class="line"><span class="javascript">        <span class="comment">// vm.$mount("");</span></span></span><br><span class="line"><span class="javascript">        vm.$mount(<span class="string">"#app"</span>);</span></span><br><span class="line"></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(vm.$el); <span class="comment">// 这个el指 真实挂载的dom节点  现在页面中是没有内容的，浏览器打印：&lt;div&gt;hello&lt;/div&gt;</span></span></span><br><span class="line"><span class="javascript">        <span class="comment">// 使用$mount挂载而非el:'#app'，优点是 可以自己将渲染好的元素插入到自己想放的节点中</span></span></span><br><span class="line"><span class="javascript">        <span class="comment">// document.body.appendChild(vm.$el); // 这里自己手动将渲染后的结果放到页面中</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="javascript">        <span class="comment">// 默认是不会销毁的 方式有：手动移除组件、路由切换</span></span></span><br><span class="line"><span class="javascript">        vm.$destroy(); <span class="comment">// 移除所有的观察者，移除监听事件  这时console.log中做改变数据测试，数据没有变化</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="javascript">        <span class="comment">// 每个组件都有这套流程</span></span></span><br><span class="line"></span><br><span class="line"><span class="javascript">        <span class="comment">// 每一个生命周期、每一个钩子函数</span></span></span><br><span class="line"><span class="javascript">        <span class="comment">// 钩子函数：当代码执行到特定阶段的时候会调用的函数，这个函数就叫做钩子函数，也可以说是回调函数</span></span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="Vue中的生命周期"><a href="#Vue中的生命周期" class="headerlink" title="Vue中的生命周期"></a>Vue中的生命周期</h3><ul>
<li>beforeCreate 在实例初始化之后，数据观测(data observer) 和 event/watcher 事件配置之前被调用。</li>
<li>created 实例已经创建完成之后被调用。在这一步，实例已完成以下的配置：数据观测(data observer)，属性和方法的运算， watch/event 事件回调。这里没有$el</li>
<li>beforeMount 在挂载开始之前被调用：相关的 render 函数首次被调用。</li>
<li>mounted el 被新创建的 vm.$el 替换，并挂载到实例上去之后调用该钩子。</li>
<li>beforeUpdate 数据更新时调用，发生在虚拟 DOM 重新渲染和打补丁之前。</li>
<li>updated 由于数据更改导致的虚拟 DOM 重新渲染和打补丁，在这之后会调用该钩子。</li>
<li>beforeDestroy 实例销毁之前调用。在这一步，实例仍然完全可用。</li>
<li>destroyed Vue 实例销毁后调用。调用后，Vue 实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁。 该钩子在服务器端渲染期间不被调用。</li>
</ul>
<h3 id="钩子函数中该做的事情"><a href="#钩子函数中该做的事情" class="headerlink" title="钩子函数中该做的事情"></a>钩子函数中该做的事情</h3><ul>
<li>created 实例已经创建完成，因为它是最早触发的原因可以进行一些数据，资源的请求。</li>
<li>mounted 实例已经挂载完成，可以进行一些DOM操作</li>
<li>beforeUpdate 可以在这个钩子中进一步地更改状态，这不会触发附加的重渲染过程。</li>
<li>updated 可以执行依赖于 DOM 的操作。然而在大多数情况下，你应该避免在此期间更改状态，因为这可能会导致更新无限循环。 该钩子在服务器端渲染期间不被调用。</li>
<li>destroyed 可以执行一些优化操作,清空定时器，解除绑定事件</li>
</ul>
<h2 id="组件的应用"><a href="#组件的应用" class="headerlink" title="组件的应用"></a>组件的应用</h2><h3 id="父子组件挂载顺序"><a href="#父子组件挂载顺序" class="headerlink" title="父子组件挂载顺序"></a>父子组件挂载顺序</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">my</span>&gt;</span><span class="tag">&lt;/<span class="name">my</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"./node_modules/vue/dist/vue.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">        <span class="comment">// 组件： 复用、方便维护、减少渲染</span></span></span><br><span class="line"><span class="javascript">        <span class="comment">// 全局组件、局部组件  指令</span></span></span><br><span class="line"><span class="xml">        // 如果把vue 在html中使用 注意1、html不支持自定义自闭和标签（<span class="tag">&lt;<span class="name">my</span>/&gt;</span> 不行）；2、标签名不要和原生的一样；3、如果组件名有大写的情况（<span class="tag">&lt;<span class="name">Aa</span>&gt;</span><span class="tag">&lt;/<span class="name">Aa</span>&gt;</span>）,因为html没有大写的标签，内部会全部转成小写aa，全部采用小写 + 短横线方式</span></span><br><span class="line"><span class="javascript">        <span class="comment">// 组件特点：独立，每个组件间应该是不相关的，单向数据流</span></span></span><br><span class="line"><span class="javascript">        <span class="keyword">let</span> obj = &#123;&#125;;</span></span><br><span class="line"><span class="javascript">        Vue.component(<span class="string">'my'</span>,&#123;</span></span><br><span class="line"><span class="xml">            template: '<span class="tag">&lt;<span class="name">div</span>&gt;</span>my组件<span class="tag">&lt;/<span class="name">div</span>&gt;</span>',</span></span><br><span class="line">            data()&#123;</span><br><span class="line"><span class="javascript">                <span class="keyword">return</span> obj;</span></span><br><span class="line">            &#125;,</span><br><span class="line">            beforeMount()&#123;</span><br><span class="line"><span class="javascript">                <span class="built_in">console</span>.log(<span class="string">'挂载前1'</span>);</span></span><br><span class="line">            &#125;,</span><br><span class="line">            mounted()&#123;</span><br><span class="line"><span class="javascript">                <span class="built_in">console</span>.log(<span class="string">'挂载后1'</span>);</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line"><span class="javascript">        <span class="keyword">let</span> vm = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">            el: <span class="string">'#app'</span>,</span></span><br><span class="line">            beforeMount()&#123;</span><br><span class="line"><span class="javascript">                <span class="built_in">console</span>.log(<span class="string">'挂载前'</span>);</span></span><br><span class="line">            &#125;,</span><br><span class="line">            mounted()&#123;</span><br><span class="line"><span class="javascript">                <span class="built_in">console</span>.log(<span class="string">'挂载后'</span>);</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line"><span class="javascript">        <span class="comment">// 执行顺序： 挂载前 挂载前1 挂载后1 挂载后</span></span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="组件的注册"><a href="#组件的注册" class="headerlink" title="组件的注册"></a>组件的注册</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">my</span>&gt;</span><span class="tag">&lt;/<span class="name">my</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"./node_modules/vue/dist/vue.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">        <span class="comment">// 每个组件都应该有三部分 1）html 2)js 3) 样式</span></span></span><br><span class="line"><span class="javascript">        <span class="keyword">let</span> component = &#123;</span></span><br><span class="line"><span class="xml">            template: `<span class="tag">&lt;<span class="name">div</span>&gt;</span>儿子<span class="tag">&lt;/<span class="name">div</span>&gt;</span>`,</span></span><br><span class="line">            data()&#123;</span><br><span class="line"><span class="javascript">                <span class="keyword">return</span> &#123;<span class="attr">m</span>:<span class="number">1</span>&#125;</span></span><br><span class="line">            &#125;,</span><br><span class="line"><span class="javascript">            beforeCreate()&#123; <span class="comment">// 这里可以解释生命周期为beforeCreate时可以知道，它的父亲是谁 儿子是谁 这一说明</span></span></span><br><span class="line"><span class="javascript">                <span class="built_in">console</span>.log(<span class="keyword">this</span>);</span></span><br><span class="line"><span class="javascript">                <span class="built_in">console</span>.log(<span class="keyword">this</span>.$parent.$children[<span class="number">0</span>] === <span class="keyword">this</span>); <span class="comment">// true</span></span></span><br><span class="line"><span class="javascript">                <span class="keyword">debugger</span>;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"><span class="javascript">        <span class="comment">// 全局注册</span></span></span><br><span class="line"><span class="javascript">        <span class="comment">// Vue.component('my',component); </span></span></span><br><span class="line"></span><br><span class="line"><span class="javascript">        <span class="keyword">let</span> vm = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">            el: <span class="string">'#app'</span>,</span></span><br><span class="line"><span class="javascript">            components:&#123; <span class="comment">// 局部注册  这个vm实例上注册组件</span></span></span><br><span class="line">                my:component</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line"><span class="javascript">        <span class="comment">// 组件的使用三部： 1）导入一个组件 2） 注册 3）使用：在当前组件定义的模板中使用 如上面这个my组件只能在id=app的这个模板中使用</span></span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="组件的通讯"><a href="#组件的通讯" class="headerlink" title="组件的通讯"></a>组件的通讯</h3><p>将父组件的数据 通过儿子的属性传入<br>单向数据流 父组件将数据传递给儿子</p>
<h4 id="入手示例"><a href="#入手示例" class="headerlink" title="入手示例"></a>入手示例</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 将父组件的数据 通过儿子的属性传入 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">my</span> <span class="attr">:mny</span>=<span class="string">"mny"</span>&gt;</span><span class="tag">&lt;/<span class="name">my</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"./node_modules/vue/dist/vue.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">        <span class="comment">// 单向数据流 父组件将数据传递给儿子</span></span></span><br><span class="line"><span class="javascript">        <span class="keyword">let</span> component = &#123;</span></span><br><span class="line"><span class="xml">            template: `<span class="tag">&lt;<span class="name">div</span>&gt;</span>儿子&#123;&#123;mny&#125;&#125; <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"change"</span>&gt;</span>更改<span class="tag">&lt;/<span class="name">button</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span>`,</span></span><br><span class="line"><span class="javascript">            <span class="comment">// props:['mny'], // 相当于在实例上添加了一个mny属性 this.mny = 100;</span></span></span><br><span class="line"><span class="javascript">            <span class="comment">// 如果要对传入的值做校验，用如下写法：</span></span></span><br><span class="line">            props: &#123;</span><br><span class="line">                mny: &#123;</span><br><span class="line"><span class="javascript">                    <span class="comment">// 普通类型直接写默认值即可，如果是对象或者数组，必须写成函数返回值的效果</span></span></span><br><span class="line"><span class="javascript">                    type: <span class="built_in">Number</span>,  <span class="comment">// 类型校验  Object     Array</span></span></span><br><span class="line"><span class="javascript">                    <span class="keyword">default</span>: <span class="number">100</span>, <span class="comment">// 默认值检验  ()=&gt;(&#123;a:1&#125;)   ()=&gt;[1,2,3]</span></span></span><br><span class="line"><span class="javascript">                    <span class="comment">// required: true, // 必填校验</span></span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            data()&#123;</span><br><span class="line"><span class="javascript">                <span class="keyword">return</span> &#123;<span class="attr">m</span>:<span class="number">1</span>&#125;</span></span><br><span class="line">            &#125;,</span><br><span class="line">            methods:&#123;</span><br><span class="line">                change()&#123;</span><br><span class="line"><span class="javascript">                    <span class="keyword">this</span>.mny = <span class="number">200</span>; <span class="comment">// 会报错，值是变了。子组件不应该去更改父组件的数据</span></span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            beforeCreate()&#123;</span><br><span class="line"><span class="javascript">                <span class="built_in">console</span>.log(<span class="keyword">this</span>.$parent.$children[<span class="number">0</span>] === <span class="keyword">this</span>); <span class="comment">// true</span></span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        </span><br><span class="line"><span class="javascript">        <span class="keyword">let</span> vm = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">            el: <span class="string">'#app'</span>,</span></span><br><span class="line">            data:&#123;</span><br><span class="line">                mny: 100</span><br><span class="line">            &#125;,</span><br><span class="line">            components:&#123;</span><br><span class="line">                my:component</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>组件： 复用、方便维护、减少渲染</li>
<li>组件特点：独立，每个组件间应该是不相关的，单向数据流</li>
</ul>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue核心应用（三）— 动画</title>
    <url>/2019/10/28/Vue-core-animation/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>元素的显示隐藏都可以增加动画效果<code>v-if</code>、<code>v-show</code>、<code>v-for</code>、路由切换等操作。  </p>
<p>常见的增加动画的方式有  <code>animation</code> 、 <code>transition</code> 、 <code>js编写动画</code></p>
<a id="more"></a>

<h3 id="css3动画"><a href="#css3动画" class="headerlink" title="css3动画"></a>css3动画</h3><p><img src="https://cn.vuejs.org/images/transition.png" alt></p>
<p>我们先要具体掌握一下每个样式的触发阶段</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> @<span class="attr">click</span>=<span class="string">"show()"</span>&gt;</span>显示/隐藏<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">transition</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"content"</span> <span class="attr">v-if</span>=<span class="string">"isShow"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">transition</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.content</span>&#123;</span><br><span class="line">    width: 100px;height: 100px;background: red;;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.v-enter</span>&#123; <span class="comment">/*进入前*/</span></span><br><span class="line">    <span class="attribute">background</span>: blue;</span><br><span class="line">    <span class="attribute">opacity</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.v-enter-active</span>&#123; <span class="comment">/*进入中*/</span></span><br><span class="line">    <span class="attribute">transition</span>: all <span class="number">2s</span> linear;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.v-enter-to</span>&#123; <span class="comment">/*目标*/</span></span><br><span class="line">    <span class="attribute">background</span>: black;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 回到默认效果 红色 */</span></span><br><span class="line"><span class="selector-class">.v-leave</span>&#123; <span class="comment">/*开始离开*/</span></span><br><span class="line">    <span class="attribute">background</span>: yellow;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.v-leave-active</span>&#123; <span class="comment">/*离开中*/</span></span><br><span class="line">    <span class="attribute">transition</span>: all <span class="number">2s</span> linear;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.v-leave-to</span>&#123; <span class="comment">/*目标*/</span></span><br><span class="line">    <span class="attribute">background</span>: green;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*元素隐藏*/</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>我们可以使用<code>name属性来更改默认v-前缀</code></p>
</blockquote>
<p><strong>配合<code>animate.css</code>使用</strong></p>
<p>安装<code>animate.css</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install animate.css</span><br></pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;link rel="stylesheet" href="node_modules/animate.css/animate.css"&gt;</span><br><span class="line">&lt;<span class="selector-tag">style</span> &gt;</span><br><span class="line">    <span class="selector-class">.content</span>&#123;</span><br><span class="line">        <span class="attribute">background</span>: red;<span class="attribute">width</span>: <span class="number">100px</span>;<span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="selector-class">.v-enter-active</span>&#123;</span><br><span class="line">        <span class="attribute">animation</span>:bounceIn <span class="number">1s</span> ease-in;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="selector-class">.v-leave-active</span>&#123;</span><br><span class="line">        <span class="attribute">animation</span>:bounceOut <span class="number">1s</span> ease-in ;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure>

<p>也可以采用直接指定样式的方式</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">transition</span> <span class="attr">enter-active-class</span>=<span class="string">"bounceIn"</span> <span class="attr">leave-active-class</span>=<span class="string">"bounceOut"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"content animated"</span> <span class="attr">v-if</span>=<span class="string">"isShow"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">transition</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"X-UA-Compatible"</span> <span class="attr">content</span>=<span class="string">"ie=edge"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span> &gt;</span></span><br><span class="line"><span class="css">        <span class="selector-class">.content</span>&#123;</span></span><br><span class="line">            width: 100px;height: 100px;background: red;;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="css">        <span class="selector-class">.v-enter</span>&#123; <span class="comment">/*进入前*/</span></span></span><br><span class="line">            background: blue;;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="css">        <span class="selector-class">.v-enter-active</span>&#123;</span></span><br><span class="line">            background: purple;</span><br><span class="line">            transition: all 10s linear;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="css">        <span class="selector-class">.v-enter-to</span>&#123;</span></span><br><span class="line">            background: chartreuse;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="css">        <span class="comment">/* 默认变成红色 */</span></span></span><br><span class="line"><span class="css">        <span class="selector-class">.v-leave</span>&#123;</span></span><br><span class="line">            background: rgb(98, 0, 255);</span><br><span class="line">        &#125;</span><br><span class="line"><span class="css">        <span class="selector-class">.v-leave-active</span>&#123;</span></span><br><span class="line">            background: crimson;</span><br><span class="line">            transition: all 10s linear;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="css">        <span class="selector-class">.v-leave-to</span>&#123;</span></span><br><span class="line">            background: yellow;</span><br><span class="line">        &#125;   </span><br><span class="line"><span class="css">        <span class="comment">/*最终 消失 */</span></span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- VUE 中的动画 v-if v-for v-show 路由切换 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"change"</span>&gt;</span>点击我<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">transition</span>&gt;</span> <span class="comment">&lt;!-- transition vue提供的添加动画标识--&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">div</span> <span class="attr">v-if</span>=<span class="string">"isShow"</span> <span class="attr">class</span>=<span class="string">"content"</span>&gt;</span></span><br><span class="line">                    content</span><br><span class="line">                <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">transition</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"./node_modules/vue/dist/vue.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">let</span> vm = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">            el: <span class="string">"#app"</span>,</span></span><br><span class="line">            data:&#123;</span><br><span class="line"><span class="javascript">                isShow: <span class="literal">false</span>,</span></span><br><span class="line">            &#125;,</span><br><span class="line">            methods:&#123;</span><br><span class="line">                change()&#123;</span><br><span class="line"><span class="javascript">                    <span class="keyword">this</span>.isShow = !<span class="keyword">this</span>.isShow;</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="js编写动画"><a href="#js编写动画" class="headerlink" title="js编写动画"></a>js编写动画</h3><p><strong>常用的钩子</strong></p>
<ul>
<li>before-enter 触发enter之前</li>
<li>before-leave 触发leave之前</li>
<li>enter 进入动画过程</li>
<li>leave 离开动画过程</li>
<li>after-enter 进入动画结束</li>
<li>after-leave 离开动画结束</li>
</ul>
<h4 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h4><p>添加购物车的例子</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">"(list,index) in lists"</span> <span class="attr">ref</span>=<span class="string">"lists"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">img</span> <span class="attr">:src</span>=<span class="string">"list.cover"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"addCart(index)"</span>&gt;</span>加入购物车<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"cart"</span> <span class="attr">ref</span>=<span class="string">"cart"</span>&gt;</span>快进来!!!<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 实现动画 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">transition</span> @<span class="attr">enter</span>=<span class="string">"enter"</span> @<span class="attr">after-enter</span>=<span class="string">"after"</span>&gt;</span> <span class="comment">&lt;!-- transition 创建动画元素 --&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- span 进入写动画--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"animate"</span> <span class="attr">v-if</span>=<span class="string">"isShow"</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">transition</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>我们可以借助 <code>v-if</code>来实现动画效果</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0, maximum-scale=1.0"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"X-UA-Compatible"</span> <span class="attr">content</span>=<span class="string">"ie=edge"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">        ul li &#123;</span><br><span class="line">            list-style: none;</span><br><span class="line">            display: flex;</span><br><span class="line">            align-items: center;</span><br><span class="line">            margin-bottom: 5px;</span><br><span class="line">        &#125;</span><br><span class="line">        li img &#123;</span><br><span class="line">            width: 150px;</span><br><span class="line">            height: 80px;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="css">        <span class="selector-class">.cart</span> &#123;</span></span><br><span class="line">            position: fixed;</span><br><span class="line">            bottom: 0;</span><br><span class="line">            right: 0;</span><br><span class="line">            width: 150px;</span><br><span class="line">            height: 50px;</span><br><span class="line">            line-height: 50px;</span><br><span class="line">            text-align: center;</span><br><span class="line">            background: chartreuse;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="css">        <span class="selector-class">.animate</span> &#123;</span></span><br><span class="line">            position: absolute;</span><br><span class="line">            width: 150px;</span><br><span class="line">            height: 80px;</span><br><span class="line">            display: block;</span><br><span class="line"><span class="css">            <span class="selector-tag">transition</span><span class="selector-pseudo">:all</span> 1<span class="selector-tag">s</span> <span class="selector-tag">linear</span> ;</span></span><br><span class="line">        &#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">"(list,index) in lists"</span> <span class="attr">ref</span>=<span class="string">"lists"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">img</span> <span class="attr">:src</span>=<span class="string">"list.cover"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"addCart(index)"</span>&gt;</span>加入购物车<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"cart"</span> <span class="attr">ref</span>=<span class="string">"cart"</span>&gt;</span>快进来!!!<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 实现动画 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">transition</span> @<span class="attr">enter</span>=<span class="string">"enter"</span> @<span class="attr">after-enter</span>=<span class="string">"after"</span>&gt;</span> <span class="comment">&lt;!-- transition 创建动画元素 --&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- span 进入写动画--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"animate"</span> <span class="attr">v-if</span>=<span class="string">"isShow"</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">transition</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"node_modules/vue/dist/vue.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">let</span> vm = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">            el: <span class="string">'#app'</span>,</span></span><br><span class="line">            methods: &#123;</span><br><span class="line"><span class="javascript">                enter(el,done)&#123; <span class="comment">// el：当前动画元素(即这里的span元素)  done：动画完事了 需要调用done方法</span></span></span><br><span class="line"><span class="javascript">                    <span class="comment">// 如果将ref 添加到v-for 可以通过 this.$refs.lists = ['真实dom'];</span></span></span><br><span class="line"><span class="javascript">                    <span class="keyword">let</span> li = <span class="keyword">this</span>.$refs.lists[<span class="keyword">this</span>.currentIndex];</span></span><br><span class="line"><span class="javascript">                    <span class="keyword">let</span> &#123;x,y&#125; = li.getBoundingClientRect(); <span class="comment">// js原生方法 获取坐标</span></span></span><br><span class="line"><span class="javascript">                    el.style.left = x+<span class="string">'px'</span>;</span></span><br><span class="line"><span class="javascript">                    el.style.top = y+<span class="string">'px'</span>;</span></span><br><span class="line"><span class="javascript">                    el.style.background = <span class="string">`url(<span class="subst">$&#123;<span class="keyword">this</span>.lists[<span class="keyword">this</span>.currentIndex].cover&#125;</span>)`</span>;</span></span><br><span class="line"><span class="javascript">                    el.style.backgroundSize = <span class="string">`100% 100%`</span>; </span></span><br><span class="line"><span class="javascript">                    <span class="comment">// 以上 将span元素放置到当前点击的元素上</span></span></span><br><span class="line"></span><br><span class="line"><span class="javascript">                    <span class="keyword">let</span> &#123;<span class="attr">x</span>:a,<span class="attr">y</span>:b&#125; = <span class="keyword">this</span>.$refs.cart.getBoundingClientRect(); <span class="comment">// 获取目的地坐标</span></span></span><br><span class="line"><span class="javascript">                    <span class="comment">// volicaty第三方库 纯js写</span></span></span><br><span class="line"><span class="javascript">                    el.style.transform = <span class="string">`translate3d(<span class="subst">$&#123;a-x&#125;</span>px,<span class="subst">$&#123;b-y&#125;</span>px,0) scale(0,0)`</span>;</span></span><br><span class="line"><span class="javascript">                    <span class="comment">// Vue 为了知道过渡的完成，必须设置相应的事件监听器。</span></span></span><br><span class="line"><span class="javascript">                    el.addEventListener(<span class="string">'transitionend'</span>,done); </span></span><br><span class="line">                &#125;,</span><br><span class="line"><span class="javascript">                after()&#123; <span class="comment">// 结束后重置动画</span></span></span><br><span class="line"><span class="javascript">                    <span class="keyword">this</span>.isShow = <span class="literal">false</span>; <span class="comment">// 直接隐藏</span></span></span><br><span class="line">                &#125;,</span><br><span class="line"><span class="javascript">                addCart(index)&#123; <span class="comment">// 加入购物车 </span></span></span><br><span class="line"><span class="javascript">                    <span class="keyword">this</span>.currentIndex = index; <span class="comment">// 点击谁就保存起来</span></span></span><br><span class="line"><span class="javascript">                    <span class="keyword">this</span>.isShow = <span class="literal">true</span>;</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            data() &#123;</span><br><span class="line"><span class="javascript">                <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="javascript">                    isShow: <span class="literal">false</span>,</span></span><br><span class="line">                    currentIndex:-1,</span><br><span class="line">                    lists: [&#123;</span><br><span class="line"><span class="javascript">                            cover: <span class="string">'http://www.javascriptpeixun.cn/files/course/2019/10-13/20510264fa40871768.png'</span>,</span></span><br><span class="line">                            id: 1,</span><br><span class="line">                        &#125;,</span><br><span class="line">                        &#123;</span><br><span class="line"><span class="javascript">                            cover: <span class="string">'http://www.javascriptpeixun.cn/files/course/2019/10-13/21114956089d654633.png'</span>,</span></span><br><span class="line">                            id: 2,</span><br><span class="line">                        &#125;,</span><br><span class="line">                        &#123;</span><br><span class="line"><span class="javascript">                            cover: <span class="string">'http://www.javascriptpeixun.cn/files/course/2019/10-13/2048331a9c5a183234.png'</span>,</span></span><br><span class="line">                            id: 3,</span><br><span class="line">                        &#125;</span><br><span class="line">                    ]</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="4-3-多元素动画"><a href="#4-3-多元素动画" class="headerlink" title="4.3 多元素动画"></a>4.3 多元素动画</h3><p>如果动画遇到<code>v-for</code>就需要使用<code>transition-group</code>,而且每个元素必须增加<code>key</code>属性</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"nav-list"</span> <span class="attr">ref</span>=<span class="string">"box"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">transition-group</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"nav-item"</span> <span class="attr">v-for</span>=<span class="string">"i in count"</span> <span class="attr">v-show</span>=<span class="string">"isShow"</span> <span class="attr">:key</span>=<span class="string">"i"</span>&gt;</span>&#123;&#123;i&#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">transition-group</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"nav"</span> @<span class="attr">click</span>=<span class="string">"show()"</span>&gt;</span>导航<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> vm = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">        el: <span class="string">'#app'</span>,</span></span><br><span class="line"><span class="javascript">        methods:&#123; <span class="comment">// 控制是否显示</span></span></span><br><span class="line"><span class="javascript">            show()&#123;<span class="keyword">this</span>.isShow = !<span class="keyword">this</span>.isShow&#125;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        data() &#123;</span><br><span class="line"><span class="javascript">            <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="javascript">                isShow: <span class="literal">false</span>, <span class="attr">count</span>:<span class="number">6</span> <span class="comment">// 循环六个导航</span></span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.nav-list</span> <span class="selector-class">.v-enter</span>&#123; <span class="comment">/*进入前的状态*/</span></span><br><span class="line">    <span class="attribute">opacity</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">translate</span>(0,0);</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.v-enter-active</span>,<span class="selector-class">.v-leave-active</span>&#123; <span class="comment">/*运动中的效果*/</span></span><br><span class="line">    <span class="attribute">transition</span>: all .<span class="number">5s</span> linear;</span><br><span class="line">&#125; </span><br><span class="line"><span class="selector-class">.nav-list</span> <span class="selector-class">.v-leave-to</span>&#123; <span class="comment">/*离开后的目标*/</span></span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">translate</span>(0,0);</span><br><span class="line">    <span class="attribute">opacity</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="六-面试题环节"><a href="#六-面试题环节" class="headerlink" title="六.面试题环节"></a>六.面试题环节</h2><ul>
<li>computed和watch有什么区别?</li>
<li>Vue的生命周期,每个生命周期具体适合哪些场景</li>
<li>Vue中ref是什么?</li>
<li>Vue动画的生命周期?</li>
<li>Vue如何编写自定义指令?</li>
</ul>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue核心应用（二）</title>
    <url>/2019/10/25/Vue-core/</url>
    <content><![CDATA[<blockquote>
<p>vue MVVM双向绑定  用户可以更改视图 </p>
</blockquote>
<p>表单: input select radio checkbox textarea</p>
<a id="more"></a>

<h2 id="一-v-model的使用"><a href="#一-v-model的使用" class="headerlink" title="一.v-model的使用"></a>一.v-model的使用</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"X-UA-Compatible"</span> <span class="attr">content</span>=<span class="string">"ie=edge"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- input textarea --&gt;</span></span><br><span class="line">        &#123;&#123;text&#125;&#125;</span><br><span class="line">        <span class="tag">&lt;<span class="name">textarea</span> <span class="attr">v-model</span>=<span class="string">"text"</span>&gt;</span><span class="tag">&lt;/<span class="name">textarea</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">hr</span>/&gt;</span></span><br><span class="line">		</span><br><span class="line">        <span class="comment">&lt;!-- select 单选--&gt;</span></span><br><span class="line">        &#123;&#123;selectValue&#125;&#125;</span><br><span class="line">        <span class="tag">&lt;<span class="name">select</span> <span class="attr">v-model</span>=<span class="string">"selectValue"</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 默认值 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">""</span> <span class="attr">disabled</span>&gt;</span>请选择<span class="tag">&lt;/<span class="name">option</span>&gt;</span><span class="comment">&lt;!--初始选中 请选择--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">option</span> <span class="attr">:value</span>=<span class="string">"o.id"</span> <span class="attr">v-for</span>=<span class="string">"o of selectOptions"</span>&gt;</span>&#123;&#123;o.value&#125;&#125;<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line">		</span><br><span class="line">        <span class="comment">&lt;!-- select 多选 值是数组--&gt;</span></span><br><span class="line">        &#123;&#123;selectValue_arr&#125;&#125; <span class="comment">&lt;!--  [ 1, 2 ]  --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">select</span> <span class="attr">v-model</span>=<span class="string">"selectValue_arr"</span> <span class="attr">multiple</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 默认值 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">""</span> <span class="attr">disabled</span>&gt;</span>请选择<span class="tag">&lt;/<span class="name">option</span>&gt;</span><span class="comment">&lt;!--初始选中 请选择--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">option</span> <span class="attr">:value</span>=<span class="string">"o.id"</span> <span class="attr">v-for</span>=<span class="string">"o of selectOptions"</span>&gt;</span>&#123;&#123;o.value&#125;&#125;<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">hr</span>/&gt;</span></span><br><span class="line">		</span><br><span class="line">        <span class="comment">&lt;!-- radio男女 分组 根据v-model取对应的值 --&gt;</span></span><br><span class="line">        &#123;&#123;radioValue&#125;&#125;  </span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"radio"</span> <span class="attr">value</span>=<span class="string">"男"</span> <span class="attr">v-model</span>=<span class="string">"radioValue"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"radio"</span> <span class="attr">value</span>=<span class="string">"女"</span> <span class="attr">v-model</span>=<span class="string">"radioValue"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">hr</span>/&gt;</span></span><br><span class="line">		</span><br><span class="line">        <span class="comment">&lt;!-- checkbox默认值是不选择 true false --&gt;</span></span><br><span class="line">        &#123;&#123;check&#125;&#125;</span><br><span class="line">        爱好:</span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"checkbox"</span> <span class="attr">v-model</span>=<span class="string">"check"</span> <span class="attr">value</span>=<span class="string">"游泳"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"checkbox"</span> <span class="attr">v-model</span>=<span class="string">"check"</span> <span class="attr">value</span>=<span class="string">"健身"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">hr</span>/&gt;</span></span><br><span class="line">		</span><br><span class="line">        <span class="comment">&lt;!-- 修饰符 --&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- trim 去前后空格 只能输入number 可以限制只能输入数字 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">v-model.trim</span>=<span class="string">"text"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">v-model.number</span>=<span class="string">"text"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"./node_modules/vue/dist/vue.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">let</span> vm = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">            el: <span class="string">"#app"</span>,</span></span><br><span class="line">            data()&#123;</span><br><span class="line"><span class="javascript">                <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="javascript">                    text: <span class="string">'jf'</span>,</span></span><br><span class="line"><span class="javascript">                    selectValue: <span class="string">""</span>,</span></span><br><span class="line"><span class="javascript">                    selectValue_arr: [], <span class="comment">// 多选 初始值是数组类型</span></span></span><br><span class="line">                    selectOptions:[</span><br><span class="line"><span class="javascript">                        &#123;<span class="attr">value</span>:<span class="string">'香蕉'</span>,<span class="attr">id</span>:<span class="number">1</span>&#125;,</span></span><br><span class="line"><span class="javascript">                        &#123;<span class="attr">value</span>:<span class="string">'苹果'</span>,<span class="attr">id</span>:<span class="number">2</span>&#125;</span></span><br><span class="line">                    ],</span><br><span class="line"><span class="javascript">                    radioValue:<span class="string">'男'</span>,</span></span><br><span class="line">                    check:[],</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="二-自定义指令"><a href="#二-自定义指令" class="headerlink" title="二.自定义指令"></a>二.自定义指令</h2><p>自定义指令就是操作dom元素， 可以把操作dom元素的功能封装到一起。</p>
<ul>
<li>全局指令和局部指令</li>
<li>编写一个自定义指令</li>
</ul>
<h3 id="自动获取焦点"><a href="#自动获取焦点" class="headerlink" title="自动获取焦点"></a>自动获取焦点</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 指令由几部分组成 v-model.a.b.c="abc"  这里abc是变量--&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 要实现的功能：让输入框自动获取焦点 --&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 全局指令：所有组件 实例都可以使用 --&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">v-focus.a.b.c</span>=<span class="string">"xxx"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"./node_modules/vue/dist/vue.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">        <span class="comment">// 官方文档有这个例子 获取焦点</span></span></span><br><span class="line"><span class="javascript">        <span class="comment">// el 代表当前指令元素,可以用来直接操作dom</span></span></span><br><span class="line"><span class="javascript">        <span class="comment">// binding 绑定属性 （例如上面的.a.b.c xxx）</span></span></span><br><span class="line"><span class="javascript">        <span class="comment">// vnode 虚拟节点 context上下文，当前指令所在的上下文</span></span></span><br><span class="line">        </span><br><span class="line"><span class="javascript">        Vue.directive(<span class="string">'focus'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">el,binding,vnode</span>) </span>&#123; <span class="comment">// 此写法相当于 bind + update</span></span></span><br><span class="line"><span class="javascript">            <span class="comment">// 此方法 默认只在绑定的时候 才会执行 和 更新(只有依赖的数据发生变化)的时候也会重新执行</span></span></span><br><span class="line"><span class="javascript">            <span class="built_in">console</span>.log(el,binding,vnode);</span></span><br><span class="line">            el.focus();</span><br><span class="line">        &#125;)</span><br><span class="line">		</span><br><span class="line"><span class="javascript">		<span class="comment">// 等同于上面的 bind + update</span></span></span><br><span class="line"><span class="javascript">		Vue.directive(<span class="string">'focus'</span>,&#123;</span></span><br><span class="line">            bind(el,binding,vnode)&#123;</span><br><span class="line"><span class="javascript">                <span class="built_in">console</span>.log(<span class="string">'bind~'</span>,el,binding,vnode);</span></span><br><span class="line">                el.focus();</span><br><span class="line">            &#125;,</span><br><span class="line">            update(el,binding,vnode)&#123;</span><br><span class="line"><span class="javascript">                <span class="built_in">console</span>.log(<span class="string">'update~'</span>,el,binding,vnode);</span></span><br><span class="line">                el.focus();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">		</span><br><span class="line"><span class="javascript">		<span class="comment">// 现在希望的是dom节点插到页面上才获取焦点，而不是已绑定就获取焦点 可以如下：</span></span></span><br><span class="line"><span class="javascript">		Vue.directive(<span class="string">'focus'</span>,&#123;</span></span><br><span class="line"><span class="javascript">            inserted(el,binding,vnode)&#123; <span class="comment">// 指令元素插入到页面时执行</span></span></span><br><span class="line"><span class="javascript">                <span class="built_in">console</span>.log(<span class="string">'bind~'</span>,el,binding,vnode);</span></span><br><span class="line">                el.focus();</span><br><span class="line">            &#125;</span><br><span class="line"><span class="javascript">        &#125;)  <span class="comment">// 或者可以如下：</span></span></span><br><span class="line">       </span><br><span class="line"><span class="javascript">       Vue.directive(<span class="string">'focus'</span>,&#123;</span></span><br><span class="line">           bind(el,binding,vnode)&#123;</span><br><span class="line"><span class="javascript">            Vue.nextTick(<span class="function"><span class="params">()</span>=&gt;</span>&#123; <span class="comment">//下一个事件环</span></span></span><br><span class="line">                el.focus();</span><br><span class="line">            &#125;)</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;)</span><br><span class="line">	   </span><br><span class="line"><span class="javascript">	   <span class="keyword">let</span> vm = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">            el: <span class="string">'#app'</span>,</span></span><br><span class="line">            data()&#123;</span><br><span class="line"><span class="javascript">                <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="javascript">                    color: <span class="string">'red'</span></span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="添加一个背景色"><a href="#添加一个背景色" class="headerlink" title="添加一个背景色"></a>添加一个背景色</h3><p>现在要给输入框添加一个背景色</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">v-focus.color</span>=<span class="string">"color"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"./node_modules/vue/dist/vue.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">        <span class="comment">// el 代表当前指令元素,可以用来直接操作dom</span></span></span><br><span class="line"><span class="javascript">        <span class="comment">// binding 绑定属性 （例如上面的.a.b.c xxx）</span></span></span><br><span class="line"><span class="javascript">        <span class="comment">// vnode 虚拟节点 context上下文，当前指令所在的上下文</span></span></span><br><span class="line"></span><br><span class="line"><span class="javascript">       Vue.directive(<span class="string">'focus'</span>,&#123;</span></span><br><span class="line">           inserted(el,binding,vnode)&#123;</span><br><span class="line"><span class="javascript">               <span class="keyword">if</span>(binding.modifiers.color)&#123;</span></span><br><span class="line">                el.style.background = binding.value;</span><br><span class="line">               &#125;</span><br><span class="line"><span class="javascript">               <span class="built_in">console</span>.log(el,binding,vnode);</span></span><br><span class="line">               el.focus();</span><br><span class="line">           &#125;,</span><br><span class="line"><span class="javascript">           unbind()&#123; <span class="comment">// 指令销毁的时候 会触发此函数</span></span></span><br><span class="line"></span><br><span class="line">           &#125;</span><br><span class="line">       &#125;)</span><br><span class="line"><span class="javascript">       <span class="comment">// 顺序 bind =&gt; inserted =&gt; update =&gt; unbind</span></span></span><br><span class="line"><span class="javascript">        <span class="keyword">let</span> vm = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">            el: <span class="string">'#app'</span>,</span></span><br><span class="line">            data()&#123;</span><br><span class="line"><span class="javascript">                <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="javascript">                    color: <span class="string">'red'</span></span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>v-click-outside<br>日历 弹层 获取焦点的时候弹出来, 点弹框和input之外的区域才消失</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"X-UA-Compatible"</span> <span class="attr">content</span>=<span class="string">"ie=edge"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">        input &#123;</span><br><span class="line">            border: 1px solid red</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="css">        <span class="selector-class">.content</span> &#123;</span></span><br><span class="line">            width: 100px;</span><br><span class="line">            height: 100px;</span><br><span class="line">            background: burlywood;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">v-click-outside</span>&gt;</span> <span class="comment">&lt;!--将 它们包起来，点击这个div之外的地方才隐藏，加一个指令--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span>&gt;</span> <span class="comment">&lt;!-- 获取焦点的时候显示--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"content"</span> <span class="attr">v-if</span>=<span class="string">"isShow"</span>&gt;</span>content</span><br><span class="line">                <span class="tag">&lt;<span class="name">button</span>&gt;</span>点我 <span class="tag">&lt;/<span class="name">button</span>&gt;</span> <span class="comment">&lt;!-- 点击的时候显示--&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"./node_modules/vue/dist/vue.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">        <span class="comment">// 可以实现为 点击时判断是否存在当前的dom中</span></span></span><br><span class="line"><span class="javascript">        <span class="keyword">let</span> vm = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">            el: <span class="string">'#app'</span>,</span></span><br><span class="line"><span class="javascript">            directives:&#123; <span class="comment">// 局部指令 只对当前实例和它的子组件才生效，可以写多个，所以是复数形式</span></span></span><br><span class="line">                clickOutside: &#123;</span><br><span class="line"><span class="javascript">                    bind(el,binding,vnode)&#123; <span class="comment">// 只在绑定的时候执行</span></span></span><br><span class="line"><span class="javascript">                        <span class="comment">// 事件委托</span></span></span><br><span class="line"><span class="javascript">                        el.fn =<span class="function">(<span class="params">e</span>)=&gt;</span>&#123;</span></span><br><span class="line"><span class="javascript">                            <span class="comment">// 根据当前点击的元素，判断是不是在div里面</span></span></span><br><span class="line"><span class="javascript">                            <span class="keyword">if</span>(el.contains(e.target))&#123;</span></span><br><span class="line"><span class="javascript">                                <span class="comment">// 在div里面 现在要调用 methods中的 focus() | bind() ,如何调用</span></span></span><br><span class="line"><span class="javascript">                                <span class="comment">// vnode.context 代表当前指令所在的上下文，这个上下文可以理解为当前的这个vm</span></span></span><br><span class="line"><span class="javascript">                                <span class="built_in">console</span>.log(<span class="string">"上下文~"</span>, vnode.context);</span></span><br><span class="line"><span class="javascript">                                vnode.context[<span class="string">'focus'</span>]();</span></span><br><span class="line"><span class="javascript">                            &#125;<span class="keyword">else</span>&#123;</span></span><br><span class="line"><span class="javascript">                                vnode.context[<span class="string">'blur'</span>]();</span></span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line"><span class="javascript">                        <span class="built_in">document</span>.addEventListener(<span class="string">'click'</span>,el.fn)</span></span><br><span class="line">                    &#125;,</span><br><span class="line"><span class="javascript">                    unbind(el)&#123;  <span class="comment">// 事件绑定必须要解绑</span></span></span><br><span class="line"><span class="javascript">                        <span class="built_in">document</span>.removeEventListener(<span class="string">'click'</span>,el.fn);</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            data()&#123;</span><br><span class="line"><span class="javascript">                <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="javascript">                    isShow: <span class="literal">false</span></span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            methods:&#123;</span><br><span class="line">                focus()&#123;</span><br><span class="line"><span class="javascript">                    <span class="keyword">this</span>.isShow = <span class="literal">true</span>;</span></span><br><span class="line">                &#125;,</span><br><span class="line">                blur()&#123;</span><br><span class="line"><span class="javascript">                    <span class="keyword">this</span>.isShow = <span class="literal">false</span>;</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="三-watch和computed"><a href="#三-watch和computed" class="headerlink" title="三.watch和computed"></a>三.watch和computed</h2><p>为什么总有面试问他们的区别? 先说watch 和 computed内部调用的都是<code>new Watcher</code></p>
<ul>
<li><p>有的时候可以实现相同的功能<br>computed 计算 会根据其他的值来算<br>watch  监控 监控某个值的变化<br>这两个方法都是基于 vm.$watch</p>
</li>
<li><p>区别：<br>watch 每次值变化后 都能执行对应的回调<br>computed 计算属性 多次取值是有缓存效果的，如果依赖的值变化 才会重新执行<br>computed 内部用 defineProperty （get / set）</p>
</li>
</ul>
<h3 id="wacth（监控）"><a href="#wacth（监控）" class="headerlink" title="wacth（监控）"></a>wacth（监控）</h3><blockquote>
<p>官方解释： 一个对象，键是需要观察的表达式，值是对应回调函数。值也可以是方法名，或者包含选项的对象。Vue 实例将会在实例化时调用 $watch()，遍历 watch 对象的每一个属性。</p>
</blockquote>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"./node_modules/vue/dist/vue.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">let</span> vm = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">            el: <span class="string">'#app'</span>,</span></span><br><span class="line">            data:&#123;</span><br><span class="line"><span class="javascript">                name: <span class="string">'jf'</span>,</span></span><br><span class="line"><span class="javascript">                <span class="comment">// name: &#123;name:'jf2'&#125;, </span></span></span><br><span class="line">            &#125;,</span><br><span class="line"><span class="javascript">            watch:&#123; <span class="comment">// 当前watch这样的写法与下面initWatch() 这样的写法是一样的功能 内部就是遍历 调用 $watch()</span></span></span><br><span class="line"><span class="javascript">                <span class="comment">// *********************************************************************</span></span></span><br><span class="line">                name(newValue)&#123;</span><br><span class="line"><span class="javascript">                    <span class="built_in">console</span>.log(<span class="string">'newValue~'</span>, newValue);</span></span><br><span class="line"><span class="javascript">                &#125;<span class="comment">// 浏览器执行 打开console.log 输入 vm.name= '123'，改变name的值，可以看到打印line16将新值打出 </span></span></span><br><span class="line"><span class="javascript">                <span class="comment">// 也可以按下面的写法</span></span></span><br><span class="line"><span class="javascript">                <span class="comment">// *********************************************************************</span></span></span><br><span class="line">                name:&#123;</span><br><span class="line">                   handler(newValue)&#123;</span><br><span class="line"><span class="javascript">                        <span class="built_in">console</span>.log(<span class="string">'newValue~'</span>, newValue);</span></span><br><span class="line">                   &#125;,</span><br><span class="line"><span class="javascript">                   immediate: <span class="literal">true</span>,<span class="comment">// 立即执行handler  // 浏览器打开页面 刷新可以看到 console.log中已经打印出了name 的值 jf</span></span></span><br><span class="line"><span class="javascript">                   deep: <span class="literal">true</span>, <span class="comment">// 深度监控 浏览器执行，如果不加 改变name 的值line22不能打印，加了，当 vm.name2.name='123'时，可以打印出新值</span></span></span><br><span class="line"><span class="javascript">                   lazy: <span class="literal">true</span>, <span class="comment">// 就是computed的实现 </span></span></span><br><span class="line">               &#125;</span><br><span class="line"><span class="javascript">            &#125;,<span class="comment">// watch 当一个值变化了 可以做一件事（例如调用ajax）         </span></span></span><br><span class="line">        &#125;)</span><br><span class="line">		</span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>当数据变化后会执行对应的处理函数 handler</p>
</blockquote>
<p>watch功能的内部实现如下： 源码  node_modules/vue/src/core/</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">initWatch</span>(<span class="params">watch</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> key <span class="keyword">in</span> watch)&#123;</span><br><span class="line">        vm.$watch(key,watch[key]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">initWatch(</span><br><span class="line">    &#123;</span><br><span class="line">        name(newValue)&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'打印新值：'</span>,newValue)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h3 id="computed"><a href="#computed" class="headerlink" title="computed"></a>computed</h3><p>计算属性最大的特点 可以缓存</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"./node_modules/vue/dist/vue.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">let</span> vm = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">            el: <span class="string">'#app'</span>,</span></span><br><span class="line">            data:&#123;</span><br><span class="line"><span class="javascript">                name: <span class="string">'jf'</span>,</span></span><br><span class="line">            &#125;,           </span><br><span class="line"><span class="javascript">            <span class="comment">// computed    initComputed原理解释</span></span></span><br><span class="line">            computed:&#123;</span><br><span class="line"><span class="javascript">                <span class="comment">// computed 内部具有缓存 如果依赖的属性没有变化 不会重新执行对应函数</span></span></span><br><span class="line"><span class="javascript">                fullname()&#123; <span class="comment">// new Watcher  vm.$watch </span></span></span><br><span class="line"><span class="javascript">                    <span class="keyword">return</span> <span class="keyword">this</span>.name;</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line"><span class="javascript">        <span class="comment">// computed功能的内部实现如下：</span></span></span><br><span class="line"><span class="javascript">        <span class="function"><span class="keyword">function</span> <span class="title">initComputed</span>(<span class="params">key,handler</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="built_in">Object</span>.defineProperty(vm,key,&#123;</span></span><br><span class="line"><span class="javascript">                <span class="keyword">get</span>()&#123;</span></span><br><span class="line">                    handler();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line"><span class="javascript">        initComputed(<span class="string">'fullname'</span>,()=&gt;&#123;</span></span><br><span class="line"><span class="javascript">            <span class="built_in">console</span>.log(<span class="string">'刷新'</span>)</span></span><br><span class="line"><span class="javascript">            <span class="keyword">return</span> vm.name + <span class="string">'jw'</span>;</span></span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line"><span class="javascript">        <span class="comment">// 计算属性最大的特点 可以缓存</span></span></span><br><span class="line"><span class="javascript">        vm.fullname; <span class="comment">// 刷新浏览器执行</span></span></span><br><span class="line"><span class="javascript">        vm.fullname; <span class="comment">// 刷新浏览器执行 </span></span></span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line"><span class="javascript">        <span class="comment">// 可以看到输出了2次  做缓存 如下:</span></span></span><br><span class="line"><span class="javascript">        <span class="keyword">let</span> dirty = <span class="literal">true</span>; <span class="comment">// 内部有脏值检测系统</span></span></span><br><span class="line"><span class="javascript">        <span class="function"><span class="keyword">function</span> <span class="title">initComputed</span>(<span class="params">key,handler</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        	<span class="comment">// 源码中dirty 是通过watcher中来实现自动更新dirty的值</span></span></span><br><span class="line"><span class="javascript">			<span class="keyword">let</span> watcher = <span class="keyword">new</span> Watcher(vm,handler,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;,&#123;<span class="attr">lazy</span>:<span class="literal">true</span>&#125;);</span></span><br><span class="line"><span class="javascript">			<span class="built_in">Object</span>.defineProperty(vm, key, &#123;</span></span><br><span class="line"><span class="javascript">				<span class="keyword">get</span>() &#123;</span></span><br><span class="line"><span class="javascript">					<span class="keyword">if</span> (watcher.dirty) &#123; <span class="comment">// 取值后会将dirty 变成false</span></span></span><br><span class="line">						value = handler();</span><br><span class="line"><span class="javascript">						watcher.dirty = <span class="literal">false</span>;</span></span><br><span class="line">					&#125;</span><br><span class="line"><span class="javascript">					<span class="keyword">return</span> value</span></span><br><span class="line">				&#125;</span><br><span class="line">			&#125;);</span><br><span class="line">		&#125;</span><br><span class="line"><span class="javascript">        initComputed(<span class="string">'fullname'</span>,()=&gt;&#123;</span></span><br><span class="line"><span class="javascript">            <span class="built_in">console</span>.log(<span class="string">'刷新'</span>)</span></span><br><span class="line"><span class="javascript">            <span class="keyword">return</span> vm.name + <span class="string">'jw'</span>;</span></span><br><span class="line">        &#125;)</span><br><span class="line"><span class="javascript">        <span class="comment">// 计算属性最大的特点 可以缓存</span></span></span><br><span class="line">        vm.fullname</span><br><span class="line"><span class="javascript">        vm.fullname  <span class="comment">// 运行可以看到 只刷新了一次</span></span></span><br><span class="line"><span class="javascript">        vm.name = <span class="string">'jw'</span>; <span class="comment">// 因为line56 fullname返回的值里面依赖这个name的值，所以当name值改变时，如下,内部自动加上下面这句话 如下，将dirty=true即可</span></span></span><br><span class="line"><span class="javascript">        dirty = <span class="literal">true</span>; </span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(vm.fullname);</span></span><br><span class="line">        </span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="computed-示例"><a href="#computed-示例" class="headerlink" title="computed 示例"></a>computed 示例</h4><h5 id="（1）"><a href="#（1）" class="headerlink" title="（1）"></a>（1）</h5><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">        &#123;&#123;getFullname&#125;&#125;</span><br><span class="line">        &#123;&#123;a&#125;&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"./node_modules/vue/dist/vue.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">let</span> vm = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">            el: <span class="string">"#app"</span>,</span></span><br><span class="line">            data()&#123;</span><br><span class="line"><span class="javascript">                <span class="keyword">return</span>&#123;</span></span><br><span class="line"><span class="javascript">                    firstName: <span class="string">'jiafei'</span>,</span></span><br><span class="line"><span class="javascript">                    lastName: <span class="string">'H'</span>,</span></span><br><span class="line">                    a: 1,</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            computed:&#123;</span><br><span class="line"><span class="javascript">                getFullname()&#123; <span class="comment">// 默认这个是get方法 这样写只有get方法</span></span></span><br><span class="line"><span class="javascript">                    <span class="built_in">console</span>.log(<span class="string">'更新~'</span>);</span></span><br><span class="line"><span class="javascript">                    <span class="keyword">return</span> <span class="keyword">this</span>.firstName + <span class="keyword">this</span>.lastName;</span></span><br><span class="line">                &#125;</span><br><span class="line"><span class="javascript">            &#125;<span class="comment">// 可以看到 浏览器打开 console.log vm.a=...改变a的值getFullname()里面没有执行，只有改变与之相关的firstName、lastName时才会触发更新</span></span></span><br><span class="line">        &#125;)</span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h5 id="（2）-全选、非全选"><a href="#（2）-全选、非全选" class="headerlink" title="（2） 全选、非全选"></a>（2） 全选、非全选</h5><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">        全选：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"checkbox"</span> <span class="attr">v-model</span>=<span class="string">"checkAll"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"checkbox"</span> <span class="attr">v-for</span>=<span class="string">"(check,index) in checks"</span> <span class="attr">v-model</span>=<span class="string">"check.value"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"./node_modules/vue/dist/vue.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">let</span> vm = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">            el: <span class="string">"#app"</span>,</span></span><br><span class="line">            data()&#123;</span><br><span class="line"><span class="javascript">                <span class="keyword">return</span>&#123;</span></span><br><span class="line"><span class="javascript">                    checks:[&#123;<span class="attr">value</span>: <span class="literal">true</span>&#125;,&#123;<span class="attr">value</span>:<span class="literal">false</span>&#125;,&#123;<span class="attr">value</span>: <span class="literal">false</span>&#125;]</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line"><span class="javascript">            computed:&#123; <span class="comment">// 内部是Object.defineProperty</span></span></span><br><span class="line">                checkAll:&#123;</span><br><span class="line"><span class="javascript">                    <span class="keyword">get</span>()&#123; <span class="comment">// 如果一个为false就为false</span></span></span><br><span class="line"><span class="javascript">                        <span class="keyword">return</span> <span class="keyword">this</span>.checks.every(<span class="function"><span class="params">check</span>=&gt;</span>check.value);</span></span><br><span class="line">                    &#125;,</span><br><span class="line"><span class="javascript">                    <span class="keyword">set</span>(newValue)&#123; <span class="comment">// 用set 比较少</span></span></span><br><span class="line"><span class="javascript">                        <span class="keyword">this</span>.checks.forEach(<span class="function"><span class="params">check</span> =&gt;</span> &#123;</span></span><br><span class="line">                            check.value = newValue;</span><br><span class="line">                        &#125;);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue核心概念及特性 (一)</title>
    <url>/2019/10/18/Vue-base/</url>
    <content><![CDATA[<h1 id="Vue核心概念及特性-一"><a href="#Vue核心概念及特性-一" class="headerlink" title="Vue核心概念及特性 (一)"></a>Vue核心概念及特性 (一)</h1><p>Vue (读音 /vjuː/，类似于 view) 是一套用于构建用户界面的渐进式框架。<br>特点: 易用，灵活，高效 渐进式框架</p>
<p><img src="https://www.fullstackjavascript.cn/vue.png" alt></p>
<blockquote>
<p>可以随意组合需要用到的模块 vue + components + vue-router + vuex + vue-cli</p>
</blockquote>
<a id="more"></a>

<h2 id="一-Vue的概念和特性"><a href="#一-Vue的概念和特性" class="headerlink" title="一.Vue的概念和特性"></a>一.Vue的概念和特性</h2><h3 id="1-什么是库，什么是框架"><a href="#1-什么是库，什么是框架" class="headerlink" title="1.什么是库，什么是框架?"></a>1.什么是库，什么是框架?</h3><p>react 用于构建用户界面的JavaScript 库</p>
<ul>
<li>库是将代码集合成一个产品,库是我们调用库中的方法实现自己的功能。(jquery、react)</li>
<li>框架则是为解决一类问题而开发的产品,框架是我们在指定的位置编写好代码，框架帮我们调用。  </li>
</ul>
<p>框架与库之间最本质区别在于控制权：you call libs, frameworks call you</p>
<p><strong>Vue属于框架</strong></p>
<h3 id="2-MVC模型-amp-amp-MVVM模型"><a href="#2-MVC模型-amp-amp-MVVM模型" class="headerlink" title="2.MVC模型 &amp;&amp; MVVM模型"></a>2.MVC模型 &amp;&amp; MVVM模型</h3><p><img src="http://img.fullstackjavascript.cn/process.png?a=1" alt></p>
<p>在传统的mvc中除了model和view以外的逻辑都放在了controller中，导致controller逻辑复杂难以维护,在mvvm中view和model没有直接的关系，全部通过viewModel进行交互。</p>
<p>可以将html页面看出View，数据看成Model，不需要关系两者之间是如何交互的，不需要关心这个核心调度者，我们写数据会自动放到View上，页面上的数据变化了也会自动更新Model。</p>
<p><strong>Vue是MVVM模式</strong></p>
<h3 id="3-声明式和命令式"><a href="#3-声明式和命令式" class="headerlink" title="3.声明式和命令式"></a>3.声明式和命令式</h3><ul>
<li>自己写for循环就是命令式 (命令其按照自己的方式得到结果)（delete obj[key] 、 target[key]=val）</li>
<li>声明式就是利用数组的方法forEach、map (我们想要的是循环，内部帮我们去做，我们并不知道map内部是如何的，但是它可以帮我们实现功能)</li>
</ul>
<p>区别是：声明式方便应用，命令式 自己可以控制里面的逻辑。Vue是一个声明式框架，要按照它自己的逻辑去写，不能更改它的逻辑。</p>
<h2 id="二-Vue的基本使用"><a href="#二-Vue的基本使用" class="headerlink" title="二.Vue的基本使用"></a>二.Vue的基本使用</h2><h3 id="1-安装"><a href="#1-安装" class="headerlink" title="1.安装"></a>1.安装</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">npm init -y</span><br><span class="line">npm install vue</span><br></pre></td></tr></table></figure>

<h3 id="2-使用"><a href="#2-使用" class="headerlink" title="2.使用"></a>2.使用</h3><h4 id="2-1-基础使用"><a href="#2-1-基础使用" class="headerlink" title="2.1. 基础使用"></a>2.1. 基础使用</h4><p>新建index.html</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"X-UA-Compatible"</span> <span class="attr">content</span>=<span class="string">"ie=edge"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"container"</span>&gt;</span></span><br><span class="line">        &#123;&#123;name&#125;&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"./node_modules/vue/dist/vue.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">        <span class="comment">// 这个vm就是Vue的实例，即 View model</span></span></span><br><span class="line"><span class="javascript">        <span class="comment">// 我们只需要将数据挂在这个View model，上面div line10-12 即视图就能够获取到数据了</span></span></span><br><span class="line"><span class="javascript">        <span class="keyword">let</span> vm = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">            el: <span class="string">'#container'</span>,</span></span><br><span class="line"><span class="javascript">            data()&#123; <span class="comment">// 如果是根节点，这个data可以写成对象，现在这里写成函数</span></span></span><br><span class="line"><span class="javascript">                <span class="comment">// 这里就是model层</span></span></span><br><span class="line"><span class="javascript">                <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="javascript">                    name: <span class="string">'jf'</span>,</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line"><span class="javascript">        <span class="comment">// vue是响应式变化的，如果数据更新了，默认会刷新视图</span></span></span><br><span class="line"><span class="javascript">        vm.name = <span class="string">'jf2'</span>;</span></span><br><span class="line"><span class="javascript">        <span class="comment">// 这里可以看到页面上的数据变化了   jf2</span></span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="2-2-响应式数据变化"><a href="#2-2-响应式数据变化" class="headerlink" title="2.2 响应式数据变化"></a>2.2 响应式数据变化</h4><p>Vue中使用<code>Object.defineProperty</code>重新将对象中的属性定义，如果是数组的话需要重写数组原型上的方法</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"container"</span>&gt;</span></span><br><span class="line">        &#123;&#123;name&#125;&#125;</span><br><span class="line">        &#123;&#123;arr&#125;&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"./node_modules/vue/dist/vue.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="javascript">        <span class="keyword">let</span> vm = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">            el: <span class="string">'#container'</span>,</span></span><br><span class="line">            data()&#123;</span><br><span class="line"><span class="javascript">                <span class="keyword">return</span> &#123;<span class="attr">name</span>: <span class="string">'jf'</span>, <span class="attr">arr</span>:[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]&#125;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line"><span class="javascript">        <span class="comment">// 绑定的数据类型，什么样的数据可以响应式变化</span></span></span><br><span class="line">        vm.arr[0] = 1000;</span><br><span class="line"><span class="javascript">        <span class="comment">// 页面显示   jf [ 1, 2, 3 ]，没有改变</span></span></span><br><span class="line"></span><br><span class="line"><span class="javascript">        <span class="comment">// vue源码中是如何实现响应式变化的  新建observe.js</span></span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>新建observe.js</p>
<p>观察一个数据 Vue2.0  definePrototype 看mdn上可以知道definePrototype重定义数组的 length 时会有兼容问题所以<br>这里只针对对象 数组没有使用definePrototype</p>
<ul>
<li>1) 增加不存在的属性，不能更新视图（vm.$set 可以）</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// observer.js</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">observer</span>(<span class="params">obj</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">typeof</span> obj !== <span class="string">'object'</span> || obj == <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 循环对象 重新定义key属性</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> key <span class="keyword">in</span> obj)&#123;</span><br><span class="line">        defineReactive(obj,key,obj[key]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">defineReactive</span>(<span class="params">obj,key,value</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">Object</span>.defineProperty(obj,key,&#123;</span><br><span class="line">        <span class="keyword">get</span>()&#123;</span><br><span class="line">            <span class="keyword">return</span> value;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="keyword">set</span>(newValue)&#123;</span><br><span class="line">            <span class="keyword">if</span>(value !== newValue)&#123;</span><br><span class="line">                value = newValue;</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="string">"视图更新"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> data = &#123;<span class="attr">name</span>:<span class="string">'jf'</span>&#125;;</span><br><span class="line">observer(data);</span><br><span class="line"><span class="comment">// data.name = 123;</span></span><br><span class="line"><span class="comment">// // Run Code  运行之后可以看到 "视图更新"</span></span><br><span class="line">data.age = <span class="number">28</span>;</span><br><span class="line"><span class="comment">// Run Code   没有更新视图</span></span><br><span class="line"><span class="comment">// 缺点：</span></span><br><span class="line"><span class="comment">// 1. 增加不存在的属性，不能更新视图（vm.$set 可以）</span></span><br></pre></td></tr></table></figure>

<ul>
<li>2) vue默认会递归所有数据，增加getter setter</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// observer.js</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">observer</span>(<span class="params">obj</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">typeof</span> obj !== <span class="string">'object'</span> || obj == <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> key <span class="keyword">in</span> obj)&#123;</span><br><span class="line">        <span class="comment">// 默认只循环第一层</span></span><br><span class="line">        defineReactive(obj,key,obj[key]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">defineReactive</span>(<span class="params">obj,key,value</span>) </span>&#123;</span><br><span class="line">    observer(value); <span class="comment">// 递归创建 响应式数据，性能不好</span></span><br><span class="line">    <span class="built_in">Object</span>.defineProperty(obj,key,&#123;</span><br><span class="line">        <span class="keyword">get</span>()&#123;</span><br><span class="line">            <span class="keyword">return</span> value;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="keyword">set</span>(newValue)&#123;</span><br><span class="line">            <span class="keyword">if</span>(value !== newValue)&#123;</span><br><span class="line">                value = newValue;</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="string">"视图更新"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> data = &#123;<span class="attr">name</span>:&#123;<span class="attr">n</span>:<span class="string">'jf'</span>&#125;&#125;;</span><br><span class="line">observer(data);</span><br><span class="line">data.name.n = <span class="number">123</span>;</span><br><span class="line"><span class="comment">// Run Code 递归创建之后现在  运行之后可以看到 "视图更新"</span></span><br><span class="line"><span class="comment">// 2.vue默认会递归所有数据，增加getter setter</span></span><br></pre></td></tr></table></figure>

<h5 id="特点：-使用对象的时候必须先声明属性，这个属性才是响应式的"><a href="#特点：-使用对象的时候必须先声明属性，这个属性才是响应式的" class="headerlink" title="特点： 使用对象的时候必须先声明属性，这个属性才是响应式的"></a>特点： 使用对象的时候必须先声明属性，这个属性才是响应式的</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">observer</span>(<span class="params">obj</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">typeof</span> obj !== <span class="string">'object'</span> || obj == <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> key <span class="keyword">in</span> obj)&#123;</span><br><span class="line">        defineReactive(obj,key,obj[key]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">defineReactive</span>(<span class="params">obj,key,value</span>) </span>&#123;</span><br><span class="line">    observer(value); </span><br><span class="line">    <span class="built_in">Object</span>.defineProperty(obj,key,&#123;</span><br><span class="line">        <span class="keyword">get</span>()&#123;</span><br><span class="line">            <span class="keyword">return</span> value;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="keyword">set</span>(newValue)&#123; <span class="comment">// 给某个key设置值的时候也是一个对象</span></span><br><span class="line">            <span class="keyword">if</span>(value !== newValue)&#123;</span><br><span class="line">                observer(newValue); <span class="comment">// 这里也要递归创建</span></span><br><span class="line">                value = newValue;</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="string">"视图更新"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> data = &#123;<span class="attr">name</span>:&#123;<span class="attr">n</span>:<span class="string">'jf'</span>&#125;&#125;;</span><br><span class="line">observer(data);</span><br><span class="line">data.name = &#123;<span class="attr">n</span>: <span class="string">'123'</span>&#125;; <span class="comment">// Run Code 执行  更新视图了</span></span><br><span class="line">data.name.n = <span class="string">'456'</span>;  <span class="comment">// Run Code  也执行视图更新了  如果这里将line8注释掉 则这个n属性不是响应式的，更改数值不更新视图</span></span><br><span class="line"><span class="comment">// 特点： 使用对象的时候必须先声明属性，这个属性才是响应式的</span></span><br></pre></td></tr></table></figure>

<h5 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h5><ul>
<li>3) 数组里套对象 对象是支持响应式变化的，如果是常量则不可以</li>
<li>4) 修改数组索引和长度是不会更新视图的</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 数组</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">observer</span>(<span class="params">obj</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">typeof</span> obj !== <span class="string">'object'</span> || obj == <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">Array</span>.isArray(obj))&#123; <span class="comment">// 如果调用push unshift splice这三个方法，即增加了数组，也应该把这个值判断下是否是对象</span></span><br><span class="line">        <span class="comment">// 这里处理数组</span></span><br><span class="line">        <span class="comment">// console.log(obj); // [ 1, 2, 3 ]</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i&lt;obj.length; i++)&#123;</span><br><span class="line">            <span class="keyword">let</span> item = obj[i];</span><br><span class="line">            observer(item); <span class="comment">// 如果是对象会被 defineReactive</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">// 这里处理对象</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> key <span class="keyword">in</span> obj)&#123;</span><br><span class="line">            defineReactive(obj,key,obj[key]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">defineReactive</span>(<span class="params">obj,key,value</span>) </span>&#123;</span><br><span class="line">    observer(value); </span><br><span class="line">    <span class="built_in">Object</span>.defineProperty(obj,key,&#123;</span><br><span class="line">        <span class="keyword">get</span>()&#123;</span><br><span class="line">            <span class="keyword">return</span> value;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="keyword">set</span>(newValue)&#123;</span><br><span class="line">            <span class="keyword">if</span>(value !== newValue)&#123;</span><br><span class="line">                observer(newValue);</span><br><span class="line">                value = newValue;</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="string">"视图更新"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> data = &#123;<span class="attr">d</span>: [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,&#123;<span class="attr">name</span>:<span class="string">'jf'</span>&#125;]&#125;;</span><br><span class="line">observer(data);</span><br><span class="line"><span class="comment">// data.d[0] = 100; // 没有更新</span></span><br><span class="line">data.d[<span class="number">3</span>].name = <span class="string">'hhh'</span>; <span class="comment">// 更新</span></span><br></pre></td></tr></table></figure>

<p>现在希望更新数组也能更新视图 见index.html</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"X-UA-Compatible"</span> <span class="attr">content</span>=<span class="string">"ie=edge"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"container"</span>&gt;</span></span><br><span class="line">        &#123;&#123;name[0].n&#125;&#125;</span><br><span class="line">        &#123;&#123;name[1]&#125;&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"./node_modules/vue/dist/vue.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="javascript">        <span class="keyword">let</span> vm = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">            el: <span class="string">'#container'</span>,</span></span><br><span class="line">            data()&#123;</span><br><span class="line"><span class="javascript">                <span class="keyword">return</span> &#123;<span class="attr">name</span>:[&#123;<span class="attr">n</span>:<span class="number">123</span>&#125;,<span class="number">2</span>]&#125;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line"><span class="javascript">        <span class="comment">// vm.name[0].n = 100;  // 更新的</span></span></span><br><span class="line"><span class="javascript">        vm.name[<span class="number">1</span>] = <span class="number">500</span>;  <span class="comment">// 不更新</span></span></span><br><span class="line"></span><br><span class="line"><span class="javascript">        <span class="comment">// 分别注释line24 25 可以看到</span></span></span><br><span class="line"><span class="javascript">        <span class="comment">// 如果数组里面放的是对象，那么更改对象中的属性是可以导致视图更新的   回到observe.js</span></span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>重写 push unshift splice</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// observer.js</span></span><br><span class="line"><span class="keyword">let</span> arrayProto = <span class="built_in">Array</span>.prototype; <span class="comment">// 这是数组原型上的方法</span></span><br><span class="line"><span class="keyword">let</span> proto = <span class="built_in">Object</span>.create(arrayProto); </span><br><span class="line">[<span class="string">'push'</span>, <span class="string">'unshift'</span>, <span class="string">'splice'</span>].forEach(<span class="function"><span class="params">method</span>=&gt;</span>&#123;</span><br><span class="line">    proto[method] = <span class="function"><span class="keyword">function</span>(<span class="params">...args</span>)</span>&#123; <span class="comment">// args 这个数组参数也应该被监控</span></span><br><span class="line">        <span class="keyword">let</span> inserted; <span class="comment">// 默认没有插入新的数据</span></span><br><span class="line">        <span class="keyword">switch</span> (method) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'push'</span>:</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'unshift'</span>:</span><br><span class="line">                inserted = args;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'splice'</span>: <span class="comment">// 数组的splice 只有传递3个参数才有追加效果</span></span><br><span class="line">                inserted = args.slice(<span class="number">2</span>);</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'视图更新'</span>);</span><br><span class="line">        ArrayObserver(inserted);</span><br><span class="line">        <span class="comment">// 相当于 Array.prototype.push.call( [1,2,3,&#123;name:'jf'&#125;],4,5,6,7,8...);</span></span><br><span class="line">        arrayProto[method].call(<span class="keyword">this</span>,...args); <span class="comment">// 谁调的push，this就指向谁</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ArrayObserver</span>(<span class="params">obj</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i&lt;obj.length; i++)&#123;</span><br><span class="line">        <span class="keyword">let</span> item = obj[i];</span><br><span class="line">        <span class="comment">// 如果是普通值 就不监控了</span></span><br><span class="line">        observer(item); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">observer</span>(<span class="params">obj</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">typeof</span> obj !== <span class="string">'object'</span> || obj == <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">Array</span>.isArray(obj))&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">Object</span>.setPrototypeOf(obj,proto);<span class="comment">// 实现对数组的方法进行重写</span></span><br><span class="line">        <span class="comment">// obj.__proto__ = proto; // 意思是把obj原型的链指向proto</span></span><br><span class="line">		</span><br><span class="line">        <span class="comment">// for(let i = 0; i&lt;obj.length; i++)&#123;</span></span><br><span class="line">        <span class="comment">//     let item = obj[i];</span></span><br><span class="line">        <span class="comment">//     observer(item); </span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        ArrayObserver(obj);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> key <span class="keyword">in</span> obj)&#123;</span><br><span class="line">            defineReactive(obj,key,obj[key]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">defineReactive</span>(<span class="params">obj,key,value</span>) </span>&#123;</span><br><span class="line">    observer(value); </span><br><span class="line">    <span class="built_in">Object</span>.defineProperty(obj,key,&#123;</span><br><span class="line">        <span class="keyword">get</span>()&#123;</span><br><span class="line">            <span class="keyword">return</span> value;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="keyword">set</span>(newValue)&#123;</span><br><span class="line">            <span class="keyword">if</span>(value !== newValue)&#123;</span><br><span class="line">                observer(newValue); </span><br><span class="line">                value = newValue;</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="string">"视图更新"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> data = &#123;<span class="attr">d</span>: [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,&#123;<span class="attr">name</span>:<span class="string">'jf'</span>&#125;]&#125;;</span><br><span class="line">observer(data);</span><br><span class="line">data.d.push(&#123;<span class="attr">name</span>:<span class="string">'haha'</span>&#125;);</span><br><span class="line">data.d[<span class="number">4</span>].name = <span class="string">'haha2'</span>; <span class="comment">// push进去的数据也做了监控</span></span><br><span class="line"><span class="comment">// 可以看到有2次更新视图 </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 5.如果新增的数据 Vue中也会帮你监控（对象类型）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果整个数组更新</span></span><br><span class="line">data.d = <span class="number">1000</span>; <span class="comment">// 也会更新，应为这里看的是 data.d，data是对象，d是它的属性</span></span><br><span class="line"><span class="comment">// data.d[0] = 1000; // 这样就不会更新视图</span></span><br></pre></td></tr></table></figure>

<h3 id="3-Vue实例上的方法"><a href="#3-Vue实例上的方法" class="headerlink" title="3.Vue实例上的方法"></a>3.Vue实例上的方法</h3><ul>
<li>vm.$el;  </li>
<li>vm.$data;</li>
<li>vm.$options;</li>
<li>vm.$nextTick();</li>
<li>vm.$watch();</li>
<li>vm.$set();</li>
</ul>
<p>新建 instance.html</p>
<h4 id="1】"><a href="#1】" class="headerlink" title="1】"></a>1】</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">        &#123;&#123;name&#125;&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"./node_modules/vue/dist/vue.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">let</span> vm = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">            el: <span class="string">'#app'</span>,</span></span><br><span class="line">            data()&#123;</span><br><span class="line"><span class="javascript">                <span class="keyword">return</span> &#123;<span class="attr">name</span>:<span class="string">'jf'</span>&#125;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line"><span class="javascript">        <span class="comment">// console.log(vm.$el);// 指渲染后的真实的dom元素</span></span></span><br><span class="line"></span><br><span class="line"><span class="javascript">        <span class="comment">// 1) vue有个特点 不会在本轮代码执行的时候 去重新渲染dom</span></span></span><br><span class="line"><span class="javascript">        <span class="comment">// 2) 下一个事件环中执行 (promie.then mutationobserver setimmediate settimeout)</span></span></span><br><span class="line">        </span><br><span class="line"><span class="javascript">        <span class="comment">// 这里会等待数据更新后，再调用回调函数</span></span></span><br><span class="line"><span class="javascript">        vm.$watch(<span class="string">"name"</span>,<span class="function"><span class="keyword">function</span>(<span class="params">newVal, oldVal</span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="built_in">console</span>.log(<span class="string">'line30~'</span>,newVal, oldVal); <span class="comment">// jf3 jf</span></span></span><br><span class="line">        &#125;)</span><br><span class="line"><span class="javascript">        vm.name = <span class="string">'jf2'</span>;</span></span><br><span class="line"><span class="javascript">        vm.name = <span class="string">'jf3'</span>;</span></span><br><span class="line"><span class="javascript">        <span class="comment">// 浏览器 显示 jf3 已改变</span></span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="2】"><a href="#2】" class="headerlink" title="2】"></a>2】</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">        &#123;&#123;name&#125;&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"./node_modules/vue/dist/vue.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">let</span> vm = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">            el: <span class="string">'#app'</span>,</span></span><br><span class="line">            data()&#123;</span><br><span class="line"><span class="javascript">                <span class="keyword">return</span> &#123;<span class="attr">name</span>:<span class="string">'jf'</span>&#125;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line"><span class="javascript">        vm.$watch(<span class="string">"name"</span>,<span class="function"><span class="keyword">function</span>(<span class="params">newVal, oldVal</span>)</span>&#123; <span class="comment">// 视图是异步更新的</span></span></span><br><span class="line"><span class="javascript">            <span class="built_in">console</span>.log(<span class="string">'line30~'</span>,newVal, oldVal);</span></span><br><span class="line">        &#125;)</span><br><span class="line"><span class="javascript">        vm.name = <span class="string">'jf2'</span>;</span></span><br><span class="line"><span class="javascript">        vm.name = <span class="string">'jf3'</span>;</span></span><br><span class="line">        </span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(vm.$el.innerHTML);</span></span><br><span class="line"><span class="javascript">        <span class="comment">// 页面显示 jf3</span></span></span><br><span class="line">        /* 浏览器打印</span><br><span class="line">            jf</span><br><span class="line">            line30~ jf3 jf</span><br><span class="line">        */</span><br><span class="line"><span class="javascript">        <span class="comment">// 可以看到line19 先打印 line14后打印   视图是异步更新的</span></span></span><br><span class="line"></span><br><span class="line"><span class="javascript">        <span class="comment">// 如何拿到最新的 如下：</span></span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="3】"><a href="#3】" class="headerlink" title="3】"></a>3】</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">        &#123;&#123;name&#125;&#125;</span><br><span class="line">        &#123;&#123;age&#125;&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"./node_modules/vue/dist/vue.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">let</span> vm = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">            el: <span class="string">'#app'</span>,</span></span><br><span class="line">            data()&#123;</span><br><span class="line"><span class="javascript">                <span class="keyword">return</span> &#123;<span class="attr">name</span>:<span class="string">'jf'</span>&#125;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line"><span class="javascript">        vm.$watch(<span class="string">"name"</span>,<span class="function"><span class="keyword">function</span>(<span class="params">newVal, oldVal</span>)</span>&#123; </span></span><br><span class="line"><span class="javascript">            <span class="built_in">console</span>.log(<span class="string">'line30~'</span>,newVal, oldVal);</span></span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line"><span class="javascript">        vm.name = <span class="string">'jf2'</span>;</span></span><br><span class="line"><span class="javascript">        vm.name = <span class="string">'jf3'</span>;</span></span><br><span class="line"><span class="javascript">        <span class="comment">// 数据更新后会有一个队列，将watch的callback放到队列中，会将nextTick往后叠加，所以会拿到新的数据</span></span></span><br><span class="line"><span class="javascript">        vm.$nextTick(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="built_in">console</span>.log(vm.$el.innerHTML); <span class="comment">// jf3</span></span></span><br><span class="line">        &#125;)</span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="string">"vm的数据"</span>,vm.$data); <span class="comment">// 代表当前实例的数据</span></span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="string">"vm中的options"</span>,vm.$options);</span></span><br><span class="line"></span><br><span class="line"><span class="javascript">        <span class="comment">// vm.$set vm.$delete 帮我们更新属性的</span></span></span><br><span class="line"><span class="javascript">        <span class="comment">// 新增的属性不会导致视图更新，更改数组索引也不会更新</span></span></span><br><span class="line"><span class="javascript">        <span class="comment">// 现在增加新的属性</span></span></span><br><span class="line"><span class="javascript">        vm.age = <span class="number">18</span>; <span class="comment">// 因为上面有个更新数据，所以这里直接写新的属性，也能够更新，因为更新会取最新的数据，如果上面没有更新name属性 如下：</span></span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="4】"><a href="#4】" class="headerlink" title="4】"></a>4】</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">        &#123;&#123;name&#125;&#125;</span><br><span class="line">        &#123;&#123;age.age&#125;&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"./node_modules/vue/dist/vue.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">let</span> vm = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">            el: <span class="string">'#app'</span>,</span></span><br><span class="line">            data()&#123;</span><br><span class="line"><span class="javascript">                <span class="keyword">return</span> &#123;<span class="attr">name</span>:<span class="string">'jf'</span>,<span class="attr">age</span>:&#123;&#125;&#125;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line"><span class="javascript">        <span class="comment">// vm.age.age = 18; // 这样不行</span></span></span><br><span class="line"><span class="javascript">        vm.$<span class="keyword">set</span>(vm.age,'age',18); // 这样视图跟新了</span></span><br><span class="line"></span><br><span class="line"><span class="javascript">        <span class="comment">// vm.$el</span></span></span><br><span class="line"><span class="javascript">        <span class="comment">// vm.$options</span></span></span><br><span class="line"><span class="javascript">        <span class="comment">// vm.$watch</span></span></span><br><span class="line"><span class="javascript">        <span class="comment">// vm.$nextTick</span></span></span><br><span class="line"><span class="javascript">        <span class="comment">// vm.$set</span></span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="三-Vue中的指令"><a href="#三-Vue中的指令" class="headerlink" title="三.Vue中的指令"></a>三.Vue中的指令</h2><p>在vue中 指令 (Directives) 是带有 v- 前缀的特殊特性,主要的功能就是操作DOM</p>
<h4 id="v-for"><a href="#v-for" class="headerlink" title="v-for"></a>v-for</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span> <span class="attr">v-for</span>=<span class="string">"(fruit,index) in fruits"</span> &gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">:key</span>=<span class="string">"`item_$&#123;index&#125;`"</span>&gt;</span>&#123;&#123;fruit&#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">:key</span>=<span class="string">"`fruit_$&#123;index&#125;`"</span>&gt;</span>&#123;&#123;fruit&#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>多个元素循环时外层需要增加<code>template</code>标签,需要给真实元素增加<code>key</code>,而且<code>key</code>不能重复，尽量不要采用索引作为<code>key</code>的值</p>
</blockquote>
<p>举个<code>key</code>值的例子:</p>
<p><img src="http://img.fullstackjavascript.cn/k.png" alt></p>
<p>新建 drective.html</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- &#123;&#123;&#125;&#125; 小胡子语法 取值 能运算（算出来得有返回结果） 做三元表达式 --&gt;</span></span><br><span class="line">        &#123;&#123;name&#125;&#125;</span><br><span class="line">        <span class="tag">&lt;<span class="name">hr</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">        &#123;&#123;1+1&#125;&#125;</span><br><span class="line">        <span class="tag">&lt;<span class="name">hr</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">        &#123;&#123;[1,2,3]&#125;&#125;</span><br><span class="line">        <span class="tag">&lt;<span class="name">hr</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">        &#123;&#123;true?'是':null&#125;&#125;</span><br><span class="line">        <span class="tag">&lt;<span class="name">hr</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- 取对象  必须空格隔开 --&gt;</span></span><br><span class="line">        &#123;&#123; &#123;name:'123'&#125; &#125;&#125;</span><br><span class="line">        <span class="tag">&lt;<span class="name">hr</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!--这里name不会改变，只会取第一次的值--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">span</span> <span class="attr">v-once</span>&gt;</span>一次 &#123;&#123;name&#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">hr</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- 不要将用户输入的内容显示到页面上 xss攻击 --&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 后端返回的数据 可以通过v-html来格式化 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">span</span> <span class="attr">v-html</span>=<span class="string">"tmp"</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">hr</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- 动态绑定 这里的name是变量属性 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">v-bind:title</span>=<span class="string">"name"</span>&gt;</span>你好<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 绑定的是一个变量属性 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">:title</span>=<span class="string">"name"</span>&gt;</span>你好<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">hr</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- v-for 循环数据 数组 对象 数字 (字符串) --&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 要循环谁 就将 v-for 写到谁的身上 --&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- vue的中的key 有什么作用 区分元素,如果我有个按钮做反序 --&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 只是静态展示可以使用这个索引  使用唯一的key 来区分元素--&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 每次循环时候可以自己拼接一些内容保证唯一性 --&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- template是Vue中自定义的模板标签 没有意义 不能在上面加key --&gt;</span></span><br><span class="line">        渲染</span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">v-if</span>=<span class="string">"true"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">template</span> <span class="attr">v-for</span>=<span class="string">"(fruit,index) in arr"</span> &gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">li</span> <span class="attr">:key</span>=<span class="string">"`name_$&#123;index&#125;`"</span>&gt;</span></span><br><span class="line">                    &#123;&#123;fruit.name&#125;&#125;</span><br><span class="line">                <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">li</span> <span class="attr">:key</span>=<span class="string">"`color_$&#123;index&#125;`"</span>&gt;</span></span><br><span class="line">                    &#123;&#123;fruit.color&#125;&#125;</span><br><span class="line">                <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        不渲染</span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">v-if</span>=<span class="string">"false"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">template</span> <span class="attr">v-for</span>=<span class="string">"(fruit,index) in arr"</span> &gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">li</span> <span class="attr">:key</span>=<span class="string">"`name_$&#123;index&#125;`"</span>&gt;</span></span><br><span class="line">                    &#123;&#123;fruit.name&#125;&#125;</span><br><span class="line">                <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">li</span> <span class="attr">:key</span>=<span class="string">"`color_$&#123;index&#125;`"</span>&gt;</span></span><br><span class="line">                    &#123;&#123;fruit.color&#125;&#125;</span><br><span class="line">                <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">hr</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- v-if (操作dom是否显示))  v-show（显示隐藏 style） --&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 指令的功能是封装dom 操作的 --&gt;</span> </span><br><span class="line">        <span class="comment">&lt;!-- v-for 和 v-if 不要一起用 --&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- v-show 不能和template一起用 --&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- vue默认会采用复用的策略 会复用代码  所以这里input中加了key区分 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">template</span> <span class="attr">v-if</span>=<span class="string">"isShow"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">span</span>&gt;</span>你好<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">key</span>=<span class="string">"1"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">template</span> <span class="attr">v-else</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">span</span>&gt;</span>不好<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">key</span>=<span class="string">"2"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">hr</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 双向绑定 只要能改的 组件也可以双向绑定 --&gt;</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">&lt;!-- 如何绑定方法  v-on | @ ， v-on是@的全拼--&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- $event指代的是事件源 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">:value</span>=<span class="string">"value"</span> @<span class="attr">input</span>=<span class="string">"fn($event)"</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 很长 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">:value</span>=<span class="string">"value"</span> @<span class="attr">input</span>=<span class="string">"e=&gt;value=e.target.value"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- v-model 他就是上面的简写 语法糖 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">v-model</span>=<span class="string">"value"</span>&gt;</span></span><br><span class="line">        &#123;&#123;value&#125;&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- </span></span><br><span class="line"><span class="comment">        v-once</span></span><br><span class="line"><span class="comment">        v-html</span></span><br><span class="line"><span class="comment">        v-bind</span></span><br><span class="line"><span class="comment">        v-for</span></span><br><span class="line"><span class="comment">        v-if / else show</span></span><br><span class="line"><span class="comment">        v-model 双向绑定</span></span><br><span class="line"><span class="comment">     --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"node_modules/vue/dist/vue.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">let</span> vm = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">            el: <span class="string">'#app'</span>,</span></span><br><span class="line"><span class="javascript">            methods:&#123;<span class="comment">// 就是把所有的方法的this 都变成vm,bind了 多次bind 不会生效</span></span></span><br><span class="line">                fn(e)&#123;</span><br><span class="line"><span class="javascript">                     <span class="keyword">this</span>.value = e.target.value</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            data() &#123;</span><br><span class="line"><span class="javascript">                <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="javascript">                    value:<span class="string">'你好'</span>,</span></span><br><span class="line"><span class="javascript">                    isShow:<span class="literal">true</span>,</span></span><br><span class="line"><span class="xml">                    tmp:'<span class="tag">&lt;<span class="name">h1</span>&gt;</span>我很帅<span class="tag">&lt;/<span class="name">h1</span>&gt;</span>',</span></span><br><span class="line"><span class="javascript">                    name: <span class="string">'jf'</span>,</span></span><br><span class="line"><span class="javascript">                    arr:[&#123;<span class="attr">name</span>:<span class="string">'橘子'</span>,<span class="attr">color</span>:<span class="string">'绿色'</span>&#125;,&#123;<span class="attr">name</span>:<span class="string">'香蕉'</span>,<span class="attr">color</span>:<span class="string">' 黄色'</span>&#125;]</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>结果如图：</p>
<p><img src="https://jiafei2333.github.io/html/images/vue-1.png" alt></p>
<h2 id="四-面试题环节"><a href="#四-面试题环节" class="headerlink" title="四.面试题环节"></a>四.面试题环节</h2><ul>
<li>请说下对于MVVM的理解</li>
<li>Vue实现数据双向绑定的原理</li>
<li>Vue常用的指令有哪些?</li>
<li>v-model的原理</li>
<li>v-if 和 v-show 区别</li>
<li>Vue中 key 值的作用</li>
</ul>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>cookie-session</title>
    <url>/2019/10/16/Cookie-Session/</url>
    <content><![CDATA[<h2 id="HTTP无状态的"><a href="#HTTP无状态的" class="headerlink" title="HTTP无状态的"></a>HTTP无状态的</h2><p>不知道每次是哪里发过来的请求</p>
<ul>
<li>cookie 是存放到 浏览器上的 ,服务器可以设置，每此请求时会带上cookie</li>
<li>cookie 不安全 不能存放敏感信息 </li>
</ul>
<ul>
<li>session 服务端（基于cookie） 存放在服务器的内存中 或者=&gt; redis 数据库 (get set)</li>
</ul>
<a id="more"></a>

<h3 id="cookie"><a href="#cookie" class="headerlink" title="cookie"></a>cookie</h3><p>新建cookie.js</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 基本的 设置cookie 和 获取cookie</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line"><span class="keyword">const</span> querystring = <span class="built_in">require</span>(<span class="string">'querystring'</span>);</span><br><span class="line">http.createServer(<span class="function">(<span class="params">req,res</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> arr = [];</span><br><span class="line">    res.setCookie = <span class="function"><span class="keyword">function</span>(<span class="params">key,value,options=&#123;&#125;</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">let</span> opts = [];</span><br><span class="line">        <span class="keyword">if</span>(options.domain)&#123;</span><br><span class="line">            opts.push(<span class="string">`domain=<span class="subst">$&#123;options.domain&#125;</span>`</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(options.maxAge)&#123;</span><br><span class="line">            opts.push(<span class="string">`max-age=<span class="subst">$&#123;options.maxAge&#125;</span>`</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(options.httpOnly)&#123;</span><br><span class="line">            opts.push(<span class="string">`httpOnly=<span class="subst">$&#123;options.httpOnly&#125;</span>`</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        arr.push(<span class="string">`<span class="subst">$&#123;key&#125;</span>=<span class="subst">$&#123;value&#125;</span>; <span class="subst">$&#123;opts.join(<span class="string">'; '</span>)&#125;</span>`</span>);</span><br><span class="line">        res.setHeader(<span class="string">'Set-Cookie'</span>,arr);</span><br><span class="line">    &#125;</span><br><span class="line">    req.getCookie = <span class="function"><span class="keyword">function</span>(<span class="params">key,options = &#123;&#125;</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">let</span> obj = querystring.parse(req.headers.cookie,<span class="string">'; '</span>); <span class="comment">// a=b; c=d; www=xxx  a=b&amp;c=d</span></span><br><span class="line">        <span class="keyword">return</span> obj[key];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(req.url === <span class="string">'/write'</span>)&#123;</span><br><span class="line">        <span class="comment">// 服务端不能跨域设置cookie 但是可以给子域设置</span></span><br><span class="line">        <span class="comment">// domain 限制某个域下可以访问</span></span><br><span class="line">        <span class="comment">// path 在哪个路径下可以访问cookie，以path开头的都能访问到，一般不设置</span></span><br><span class="line">        <span class="comment">// expires、max-age 过期时间(秒) 如果做一些电商网站(如果用户一直访问这个页面，是不会退出登录的，所以每次操作的时候会把过期时间延长) 续命</span></span><br><span class="line">        <span class="comment">// HttpOnly 只能服务器操作 默认false，如果改成true 客户端就不能操作cookie</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 客户端能篡改cookie 仿造请求</span></span><br><span class="line">        res.setHeader(<span class="string">'Set-Cookie'</span>,<span class="string">'name=jf; domain=.test.cn; path=/; max-age=10'</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 设置多个cookie，这里将line33注释，封装方法设置多个cookie 如下：</span></span><br><span class="line">        res.setCookie(<span class="string">'name'</span>,<span class="string">'jf'</span>,&#123;<span class="attr">domain</span>: <span class="string">'.test.cn'</span>&#125;);</span><br><span class="line">        res.setCookie(<span class="string">'age'</span>,<span class="string">'18'</span>,&#123;<span class="attr">httpOnly</span>:<span class="literal">true</span>&#125;);</span><br><span class="line">        res.end(<span class="string">'write ok'</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(req.url === <span class="string">'/read'</span>)&#123;</span><br><span class="line">        <span class="comment">// res.end(req.headers.cookie || '空'); // 注释，用下面的方法获取设置的多个cookie的值</span></span><br><span class="line">        res.end(req.getCookie(<span class="string">'name'</span>) || <span class="string">'空'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).listen(<span class="number">3000</span>);</span><br><span class="line"><span class="comment">// 执行 nodemon cookie.js</span></span><br></pre></td></tr></table></figure>

<h4 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h4><p>新加一个功能 算下用户访问的次数 visit</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line"><span class="keyword">const</span> querystring = <span class="built_in">require</span>(<span class="string">'querystring'</span>);</span><br><span class="line"><span class="keyword">const</span> sign = <span class="function">(<span class="params">value</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="comment">// + / = 浏览器不支持</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">require</span>(<span class="string">'crypto'</span>).createHmac(<span class="string">'sha256'</span>,<span class="string">'jf'</span>).update(value).digest(<span class="string">'base64'</span>).replace(<span class="regexp">/\/|\+|\=/g</span>,<span class="string">''</span>);</span><br><span class="line">&#125;</span><br><span class="line">http.createServer(<span class="function">(<span class="params">req,res</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> arr = [];</span><br><span class="line">    res.setCookie = <span class="function"><span class="keyword">function</span>(<span class="params">key,value,options=&#123;&#125;</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">let</span> opts = [];</span><br><span class="line">        <span class="keyword">if</span>(options.domain)&#123;</span><br><span class="line">            opts.push(<span class="string">`domain=<span class="subst">$&#123;options.domain&#125;</span>`</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(options.maxAge)&#123;</span><br><span class="line">            opts.push(<span class="string">`max-age=<span class="subst">$&#123;options.maxAge&#125;</span>`</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(options.httpOnly)&#123;</span><br><span class="line">            opts.push(<span class="string">`httpOnly=<span class="subst">$&#123;options.httpOnly&#125;</span>`</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 有signed  value + 加密代码（当value被客户端篡改时，用加密的代码做判断）</span></span><br><span class="line">        <span class="keyword">if</span>(options.signed)&#123; <span class="comment">// 加盐算法 </span></span><br><span class="line">            value =  value + <span class="string">'.'</span> + sign(value)</span><br><span class="line">        &#125;</span><br><span class="line">        arr.push(<span class="string">`<span class="subst">$&#123;key&#125;</span>=<span class="subst">$&#123;value&#125;</span>; <span class="subst">$&#123;opts.join(<span class="string">'; '</span>)&#125;</span>`</span>);</span><br><span class="line">        res.setHeader(<span class="string">'Set-Cookie'</span>,arr);</span><br><span class="line">    &#125;</span><br><span class="line">    req.getCookie = <span class="function"><span class="keyword">function</span>(<span class="params">key,options = &#123;&#125;</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">let</span> obj = querystring.parse(req.headers.cookie,<span class="string">'; '</span>); <span class="comment">// a=b; c=d; www=xxx  a=b&amp;c=d</span></span><br><span class="line">        <span class="keyword">if</span>(options.signed)&#123;</span><br><span class="line">            <span class="keyword">let</span> [value,s] = obj[key].split(<span class="string">'.'</span>);</span><br><span class="line">            <span class="keyword">let</span> newSign = sign(value);</span><br><span class="line">            <span class="keyword">if</span>(s === newSign)&#123; <span class="comment">// 判断用户是否改过</span></span><br><span class="line">                <span class="keyword">return</span> value;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">undefined</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> obj[key];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(req.url === <span class="string">'/write'</span>)&#123;</span><br><span class="line">        res.setCookie(<span class="string">'name'</span>,<span class="string">'jf'</span>,&#123;<span class="attr">domain</span>: <span class="string">'.test.cn'</span>&#125;);</span><br><span class="line">        res.setCookie(<span class="string">'age'</span>,<span class="string">'18'</span>,&#123;<span class="attr">httpOnly</span>:<span class="literal">true</span>&#125;);</span><br><span class="line">        res.end(<span class="string">'write ok'</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 新加一个功能 算下用户访问的次数 visit</span></span><br><span class="line">    <span class="keyword">if</span>(req.url == <span class="string">'/visit'</span>)&#123;</span><br><span class="line">        <span class="comment">// signed:true 表示 签名  不被用户所篡改</span></span><br><span class="line">        <span class="keyword">let</span> visit = req.getCookie(<span class="string">'visit'</span>,&#123;<span class="attr">signed</span>:<span class="literal">true</span>&#125;);</span><br><span class="line">        <span class="keyword">if</span>(visit)&#123;</span><br><span class="line">            visit = visit<span class="number">-0</span>+<span class="number">1</span>;</span><br><span class="line">            res.setCookie(<span class="string">'visit'</span>,visit+<span class="string">''</span>,&#123;<span class="attr">httpOnly</span>:<span class="literal">false</span>,<span class="attr">signed</span>:<span class="literal">true</span>&#125;);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            visit = <span class="number">1</span></span><br><span class="line">            res.setCookie(<span class="string">'visit'</span>,<span class="string">'1'</span>,&#123;<span class="attr">httpOnly</span>:<span class="literal">true</span>,<span class="attr">signed</span>:<span class="literal">true</span>&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        res.end(<span class="string">`当前第<span class="subst">$&#123;visit&#125;</span>次访问`</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(req.url === <span class="string">'/read'</span>)&#123;</span><br><span class="line">        res.end(req.getCookie(<span class="string">'name'</span>) || <span class="string">'空'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).listen(<span class="number">3000</span>);</span><br></pre></td></tr></table></figure>

<h3 id="session"><a href="#session" class="headerlink" title="session"></a>session</h3><p>新建session.js</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line"><span class="keyword">const</span> uuid = <span class="built_in">require</span>(<span class="string">'uuid'</span>);</span><br><span class="line"><span class="keyword">const</span> querystring = <span class="built_in">require</span>(<span class="string">'querystring'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> session = &#123;&#125;; </span><br><span class="line"><span class="comment">// 这里存储的是session的初始值，缺陷是存到内存中了，服务器挂了，这个对象里面的数据会丢失，如果放到数据库中，数据库挂了，信息也会丢失，问题就是 持久化丢了</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> cardName = <span class="string">'no.123456789'</span>;</span><br><span class="line">http.createServer(<span class="function">(<span class="params">req,res</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> arr = [];</span><br><span class="line">    res.setCookie = <span class="function"><span class="keyword">function</span>(<span class="params">key,value,options=&#123;&#125;</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">let</span> opts = [];</span><br><span class="line">        <span class="keyword">if</span>(options.domain)&#123;</span><br><span class="line">            opts.push(<span class="string">`domain=<span class="subst">$&#123;options.domain&#125;</span>`</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(options.maxAge)&#123;</span><br><span class="line">            opts.push(<span class="string">`max-age=<span class="subst">$&#123;options.maxAge&#125;</span>`</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(options.httpOnly)&#123;</span><br><span class="line">            opts.push(<span class="string">`httpOnly=<span class="subst">$&#123;options.httpOnly&#125;</span>`</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 有signed</span></span><br><span class="line">        <span class="keyword">if</span>(options.signed)&#123; <span class="comment">// 加盐算法 </span></span><br><span class="line">            value =  value + <span class="string">'.'</span> + sign(value)</span><br><span class="line">        &#125;</span><br><span class="line">        arr.push(<span class="string">`<span class="subst">$&#123;key&#125;</span>=<span class="subst">$&#123;value&#125;</span>; <span class="subst">$&#123;opts.join(<span class="string">'; '</span>)&#125;</span>`</span>);</span><br><span class="line">        res.setHeader(<span class="string">'Set-Cookie'</span>,arr);</span><br><span class="line">    &#125;</span><br><span class="line">    req.getCookie = <span class="function"><span class="keyword">function</span>(<span class="params">key,options = &#123;&#125;</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">let</span> obj = querystring.parse(req.headers.cookie,<span class="string">'; '</span>); <span class="comment">// a=b; c=d; www=xxx  a=b&amp;c=d</span></span><br><span class="line">        <span class="keyword">if</span>(options.signed)&#123;</span><br><span class="line">            <span class="keyword">let</span> [value,s] = obj[key].split(<span class="string">'.'</span>);</span><br><span class="line">            <span class="keyword">let</span> newSign = sign(value);</span><br><span class="line">            <span class="keyword">if</span>(s === newSign)&#123; <span class="comment">// 判断用户是否改过</span></span><br><span class="line">                <span class="keyword">return</span> value;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">undefined</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> obj[key];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将cookie里面写的2个方法复制过来 setCookie、getCookie</span></span><br><span class="line">    <span class="keyword">if</span>(req.url === <span class="string">'/wash'</span>)&#123;</span><br><span class="line">        <span class="keyword">let</span> id = req.getCookie(cardName)</span><br><span class="line">        <span class="keyword">if</span>(id &amp;&amp; session[id])&#123; <span class="comment">// 有卡</span></span><br><span class="line">            session[id].money -=<span class="number">100</span>;</span><br><span class="line">            res.end(<span class="string">'current money is # '</span>+session[id].mny)</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">let</span> cardId = uuid.v4();</span><br><span class="line">            session[cardId] = &#123;<span class="attr">money</span>:<span class="number">500</span>&#125;;</span><br><span class="line">            res.setCookie(cardName,cardId);</span><br><span class="line">            res.end(<span class="string">'current money is # 500 '</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    res.end(<span class="string">'Not Found'</span>);</span><br><span class="line">&#125;).listen(<span class="number">3000</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模拟场景 去理发店办卡，服务器给客户端一个唯一的cardId, 客户端通过cookie得到cardID，去服务端获取卡上的信息，服务端进行余额减少操作</span></span><br></pre></td></tr></table></figure>

<p>后序会讲 jwt   json web token (基于cookie的原理)</p>
<h3 id="拓展-1"><a href="#拓展-1" class="headerlink" title="拓展"></a>拓展</h3><p>localStroage sessionStorage cookie session 区别</p>
<ul>
<li>localStroage 不能跨域 最多能存 5M 超过丢失 发请求的时候不会自动带上</li>
<li>sessionStorage 浏览器关闭丢失</li>
<li>cookie 在header上 每次请求自动带上 解决http无状态的问题 header中不能存太多，最多4k 太多了也会浪费流量</li>
<li>session 基于cookie 存到服务器上</li>
</ul>
<p>前后端分离 cookie 不支持，前后端分离基本上都是用token</p>
]]></content>
      <categories>
        <category>Http</category>
      </categories>
      <tags>
        <tag>Http</tag>
        <tag>cookie</tag>
        <tag>session</tag>
      </tags>
  </entry>
  <entry>
    <title>Review（一）</title>
    <url>/2019/10/16/Review-1/</url>
    <content><![CDATA[<h2 id="1-Promise中await的问题"><a href="#1-Promise中await的问题" class="headerlink" title="1.Promise中await的问题"></a>1.Promise中await的问题</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">        resolve([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">getData</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">await</span> fn(); </span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">getData();</span><br><span class="line"><span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="params">data</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<p>分析：在node中会编译成如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">        resolve([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">getData</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    await fn(); </span></span><br><span class="line"><span class="comment">    console.log(1);</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="comment">// 上述代码node 中会编译成如下:  这里resolve(fn()),resolve里面返回的是promise，会等待这个promise成功完成(即这个promise里面的resolve()之后的then，line18执行完)之后，再执行最外层的then()line13</span></span><br><span class="line">    <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>resolve(fn())).then(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line">getData();</span><br><span class="line"><span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="params">data</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line">&#125;); </span><br><span class="line"><span class="comment">// 执行结果： 2 1</span></span><br></pre></td></tr></table></figure>

<p>分析：在浏览器中会编译如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">        resolve([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">getData</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    await fn(); </span></span><br><span class="line"><span class="comment">    console.log(1);</span></span><br><span class="line"><span class="comment">    */</span>    </span><br><span class="line">    <span class="comment">// 上述代码在浏览器中会编译成如下：</span></span><br><span class="line">    <span class="built_in">Promise</span>.resolve(fn()).then(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line">getData();</span><br><span class="line"><span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="params">data</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 执行结果： 1 2</span></span><br></pre></td></tr></table></figure>

<h2 id="2-编码问题"><a href="#2-编码问题" class="headerlink" title="2.编码问题"></a>2.编码问题</h2><ul>
<li>ASCII -&gt; ANSI(GB2312) -&gt; GBK -&gt; GB18030 -&gt; Unicode -&gt; UTF-8</li>
<li>base64编码  缺点比以前大</li>
<li>编码问题<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> iconv = <span class="built_in">require</span>(<span class="string">'iconv-lite'</span>); <span class="comment">// node中的编码转化</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">readGBKText</span>(<span class="params">pathname</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> bin = fs.readFileSync(pathname); <span class="comment">// 这里需要读出来二进制</span></span><br><span class="line">    <span class="keyword">return</span> iconv.decode(bin, <span class="string">'gbk'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="3-Buffer方法"><a href="#3-Buffer方法" class="headerlink" title="3.Buffer方法"></a>3.Buffer方法</h2><ul>
<li>分配方法 alloc 、from</li>
<li>slice toString concat isBuffer length(split)</li>
</ul>
<h2 id="4-核心模块-fs-、event、-path、stream"><a href="#4-核心模块-fs-、event、-path、stream" class="headerlink" title="4.核心模块 fs 、event、 path、stream"></a>4.核心模块 fs 、event、 path、stream</h2><p>fs:</p>
<ul>
<li>readFile writeFile</li>
<li>(open read write)</li>
<li>mkdir access <code>stat</code> unlink</li>
<li>createReadStream  createWriteStream (pipe用法)</li>
</ul>
<p>event:</p>
<ul>
<li>on emit off once (newListener)</li>
</ul>
<p>path:</p>
<ul>
<li><p>join  resolve  extname  dirname  <code>__dirname</code> <code>__filename</code></p>
<p>流的类型:</p>
</li>
<li><p>1)可读(on(‘data’)，on(‘end’))   req</p>
</li>
<li><p>2)可写 write.end    res</p>
</li>
<li><p>3)双工  </p>
</li>
<li><p>4)转化流 lib createGzip</p>
</li>
</ul>
<h2 id="5-HTTP-tcp用法"><a href="#5-HTTP-tcp用法" class="headerlink" title="5.HTTP (tcp用法)"></a>5.HTTP (tcp用法)</h2><h3 id="1-一个页面从输入url到页面加载完成显示，这个过程做了什么？"><a href="#1-一个页面从输入url到页面加载完成显示，这个过程做了什么？" class="headerlink" title="1).一个页面从输入url到页面加载完成显示，这个过程做了什么？"></a>1).一个页面从输入url到页面加载完成显示，这个过程做了什么？</h3><ul>
<li>1). 浏览器通过DNS将url地址解析为ip (如果有缓存直接返回缓存,否则递归解析)    </li>
<li>2). 通过DNS解析得到了目标服务器的IP地址后，与服务器建立TCP连接。  <ul>
<li>ip协议： 选择传输路线,负责找到  </li>
<li>tcp协议： 三次握手，分片，可靠传输，重新发送的机制  (tcp)  </li>
</ul>
</li>
<li>3).浏览器通过http协议发送请求 (增加http的报文信息)  </li>
<li>4).服务器接受请求后，查库，读文件，拼接好返回的http响应   </li>
<li>5).浏览器收到html，开始渲染    (浏览器的渲染原理)</li>
<li>6).解析html为dom，解析css为css-tree,最终生成render-tree 阻塞渲染  </li>
<li>7).遍历渲染树开始布局，计算每个节点的位置大小信息   </li>
<li>8).将渲染树每个节点绘制到屏幕  </li>
<li>9).加载js文件,运行js脚本  </li>
<li>10).reflow (样式)与repaint(位置)  </li>
</ul>
<blockquote>
<p>OSI协议分层: </p>
</blockquote>
<ul>
<li>应用层 HTTP,FTP,DNS (与其他计算机进行通讯的一个应用服务，向用户提供应用服务时的通信活动)</li>
<li>传输层 TCP（可靠） UDP 数据传输 (HTTP -&gt; TCP  DNS-&gt;UDP)</li>
<li>网络层 IP 选择传输路线 (通过ip地址和mac地址)(使用ARP协议凭借mac地址进行通信)</li>
<li>链路层 网络连接的硬件部分 </li>
</ul>
<h3 id="2-Http与Https的区别："><a href="#2-Http与Https的区别：" class="headerlink" title="2).Http与Https的区别："></a>2).Http与Https的区别：</h3><p>缺陷：<br>    - 1).Http本身不具备加密的功能,HTTP 报文使用明文方式发送<br>    - 2).无法确认你发送到的服务器就是真正的目标服务器<br>    - 3).无法阻止海量请求下的 DoS 攻击<br>    - 4).内容被篡改</p>
<ul>
<li>HTTPS 是 HTTP 建立在 SSL/TLS 安全协议上的。 （信息加密，完整校验,身份验证）</li>
</ul>
<h3 id="3-URI和URL的区别"><a href="#3-URI和URL的区别" class="headerlink" title="3).URI和URL的区别"></a>3).URI和URL的区别</h3><ul>
<li>URI(Uniform Resource Identifier)是统一资源标识符,在某个规则下能把这个资源独一无二标示出来</li>
<li>URL(Uniform Resource Locator) 统一资源定位符，表示资源的地点</li>
</ul>
<h3 id="4-HTTP1-1版本特性"><a href="#4-HTTP1-1版本特性" class="headerlink" title="4).HTTP1.1版本特性"></a>4).HTTP1.1版本特性</h3><ul>
<li>长链接:建立链接后可以发送多次请求</li>
<li>管线化:不用等待可以直接发送下一个请求</li>
<li>断点续传:206  bytes</li>
</ul>
<h3 id="5-常见的http状态码"><a href="#5-常见的http状态码" class="headerlink" title="5).常见的http状态码"></a>5).常见的http状态码</h3><ul>
<li>200、204、206(Partial Content 响应了部分内容，断点续传)、301、302、304、400(参数错误，比如发个ajax参数不对)、401、403、404、500(服务器宕了)、503(负载匀衡挂了)</li>
</ul>
<h3 id="6-常用的http方法有哪些"><a href="#6-常用的http方法有哪些" class="headerlink" title="6).常用的http方法有哪些"></a>6).常用的http方法有哪些</h3><ul>
<li>GET 获取资源</li>
<li>POST 向服务器端发送数据，传输实体主体</li>
<li>PUT 传输文件</li>
<li>HEAD 获取报文首部</li>
<li>DELETE 删除文件</li>
<li>OPTIONS 询问支持的方法</li>
</ul>
<h3 id="7-Jsonp的原理-不符合规范的"><a href="#7-Jsonp的原理-不符合规范的" class="headerlink" title="7).Jsonp的原理 (不符合规范的)"></a>7).Jsonp的原理 (不符合规范的)</h3><p>新建 server.js、http.html</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// server.js</span></span><br><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line"></span><br><span class="line">http.createServer(<span class="function">(<span class="params">req,res</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="comment">// script标签是支持跨域的</span></span><br><span class="line">    <span class="keyword">if</span>(req.url === <span class="string">'/jsonp'</span>)&#123;</span><br><span class="line">        res.end(<span class="string">`fn(&#123;name: 'jf'&#125;)`</span>); <span class="comment">// 返回一个函数执行，并把参数带过去</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;).listen(<span class="number">3000</span>);</span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--http.html--&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"X-UA-Compatible"</span> <span class="attr">content</span>=<span class="string">"ie=edge"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">        <span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">data</span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="built_in">console</span>.log(<span class="string">"打印接收到的数据："</span>,data); <span class="comment">// &#123;name: "jf"&#125;</span></span></span><br><span class="line">        &#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"http://localhost:3000/jsonp"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="8-页面的性能优化"><a href="#8-页面的性能优化" class="headerlink" title="8).页面的性能优化"></a>8).页面的性能优化</h3><p><img src="https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1562322737439&di=6940a8a49d168d9690f3732794b01a4e&imgtype=0&src=http%3A%2F%2Fimg2018.cnblogs.com%2Fblog%2F1555757%2F201812%2F1555757-20181210173358459-380857182.png" alt="img"></p>
<p><em>如何查看这些属性： 浏览器 =&gt; console.log =&gt; 打印 performance</em></p>
<ul>
<li><p>缓存<br>  强制缓存 &amp; 对比缓存</p>
<blockquote>
<p>from memory cache 和 from disk cache（哪里看？打开百度 =&gt; network =&gt; size）<br>  查找优先级:</p>
</blockquote>
<ul>
<li><p>Service Worker (PWA)  cacheApi 离线缓存 </p>
</li>
<li><p>Memory Cache 网页关闭则失效 （几乎所有的请求资源）</p>
</li>
<li><p>DiskCache</p>
</li>
<li><p>网络请求  </p>
<p>对于大文件来说，大概率是不存储在内存中的,当前系统内存使用率高的话，文件优先存储进硬盘</p>
</li>
</ul>
</li>
<li><p>gzip压缩 重复率越高 压缩越高</p>
</li>
<li><p>本地存储:localStorage，sessionStorage，session，cookie，indexDB，cacheApi</p>
</li>
<li><p>CDN: 内容分发网络,实现负载均衡，并且就近返回内容</p>
</li>
<li><p>defer &amp; async ／ preload &amp; prefetch</p>
<ul>
<li>defer 和 async 在网络读取的过程中都是异步解析</li>
<li>defer是有顺序依赖的（defer按顺序执行），async只要脚本加载完后就会执行( async 谁先加载完谁先执行 )</li>
<li>preload 可以对当前页面所需的脚本、样式等资源进行预加载  vue 路由懒加载</li>
<li>prefetch 加载的资源一般不是用于当前页面的，是未来很可能用到的这样一些资源</li>
</ul>
</li>
</ul>
<h3 id="HTTP相关Header内容"><a href="#HTTP相关Header内容" class="headerlink" title="HTTP相关Header内容"></a>HTTP相关Header内容</h3><ul>
<li>缓存Header <ul>
<li>强:Cache-Control &amp;&amp; Expires<ul>
<li>private 客户端可以缓存</li>
<li>public 客户端和代理服务器都可以缓存</li>
<li>max-age=60 缓存内容将在60秒后失效</li>
<li>no-cache 需要使用对比缓存验证数据，强制向源服务器再次验证，验证通过则走缓存  (没有强制缓存)</li>
<li>no-store 所有内容都不会缓存，强制缓存和对比缓存都不会触发 (不缓存)</li>
</ul>
</li>
<li>对比：Last-Modified &amp; If-Modified-Since  /  ETag &amp; <em>If-None-Match</em></li>
</ul>
</li>
<li>跨域：Access-Control</li>
<li>压缩：Content-Encoding : gzip</li>
<li>范围请求：range</li>
<li>防盗链：referer  (防止盗用链接)</li>
<li>用户内核：user-agent</li>
<li>单主机多域名：host 代理</li>
<li>多语言：accept-language</li>
<li>文件上传：Content-Type:multipart/form-data</li>
<li>文件下载：Content-Description</li>
</ul>
<h2 id="6-KOA"><a href="#6-KOA" class="headerlink" title="6.KOA"></a>6.KOA</h2><h3 id="compose的实现"><a href="#compose的实现" class="headerlink" title="compose的实现"></a>compose的实现</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> app = &#123;</span><br><span class="line">    arr:[],</span><br><span class="line">    use(fn)&#123;</span><br><span class="line">        <span class="keyword">this</span>.arr.push(fn);</span><br><span class="line">    &#125;,</span><br><span class="line">    compose()&#123;</span><br><span class="line">        <span class="keyword">const</span> dispatch = <span class="function">(<span class="params">index</span>)=&gt;</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(index === <span class="keyword">this</span>.arr.length) <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve();</span><br><span class="line">            <span class="keyword">let</span> middle = <span class="keyword">this</span>.arr[index];</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve(middle(<span class="function"><span class="params">()</span>=&gt;</span>dispatch(index+<span class="number">1</span>)));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dispatch(<span class="number">0</span>); <span class="comment">// 这里要返回 且返回的是个promise 因为line15后面是.then()</span></span><br><span class="line">    &#125;,</span><br><span class="line">    run()&#123;</span><br><span class="line">        <span class="keyword">this</span>.compose().then(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'ok'</span>);</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">app.use(<span class="function">(<span class="params">next</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">    next();</span><br><span class="line">&#125;)</span><br><span class="line">app.use(<span class="function">(<span class="params">next</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line">    next();</span><br><span class="line">&#125;)</span><br><span class="line">app.use(<span class="function">(<span class="params">next</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">3</span>);</span><br><span class="line">    next();</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.run(); <span class="comment">// 调用</span></span><br></pre></td></tr></table></figure>

<ul>
<li>reduce</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> app = &#123;</span><br><span class="line">    arr:[],</span><br><span class="line">    use(fn)&#123;</span><br><span class="line">        <span class="keyword">this</span>.arr.push(fn);</span><br><span class="line">    &#125;,</span><br><span class="line">    compose()&#123;</span><br><span class="line">        <span class="comment">// const dispatch = (index)=&gt;&#123;</span></span><br><span class="line">        <span class="comment">//     if(index === this.arr.length) return Promise.resolve();</span></span><br><span class="line">        <span class="comment">//     let middle = this.arr[index];</span></span><br><span class="line">        <span class="comment">//     return Promise.resolve(middle(()=&gt;dispatch(index+1)));</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        <span class="comment">// return dispatch(0); </span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// this.arr.reduce((a,b)=&gt;()) // this.compose() 返回的是个函数</span></span><br><span class="line">        <span class="comment">// this.arr.reduce((a,b)=&gt;()=&gt;Promise.resolve()) // .then 后面接的是.then 返回一个promise</span></span><br><span class="line">        <span class="comment">// this.arr.reduce((a,b)=&gt;()=&gt;Promise.resolve(a(()=&gt;b()))) // Promise.resolve(a(()=&gt;b())) 这里的内容可以和line10对比</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.arr.reduce(<span class="function">(<span class="params">a,b</span>)=&gt;</span><span class="function">(<span class="params">...args</span>)=&gt;</span>&#123; <span class="comment">// 这个 ...args就是外面传的这个空函数</span></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve(a(<span class="function"><span class="params">()</span>=&gt;</span>b(...args)));</span><br><span class="line">        &#125;)(<span class="function"><span class="params">()</span>=&gt;</span>&#123;&#125;) <span class="comment">//这里传一个空函数  line 40最后一个next调的就是一个空函数</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 格式优化</span></span><br><span class="line">        <span class="comment">// return this.arr.reduce((a,b)=&gt;(...args)=&gt;Promise.resolve(a(()=&gt;b(...args))))(()=&gt;&#123;&#125;)</span></span><br><span class="line">    &#125;,</span><br><span class="line">    run()&#123;</span><br><span class="line">        <span class="keyword">this</span>.compose().then(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'ok'</span>);</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">app.use(<span class="function">(<span class="params">next</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">    next();</span><br><span class="line">&#125;)</span><br><span class="line">app.use(<span class="function">(<span class="params">next</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line">    next(); <span class="comment">// 如果将这里注释 打印 1 2 ok</span></span><br><span class="line">&#125;)</span><br><span class="line">app.use(<span class="function">(<span class="params">next</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">3</span>);</span><br><span class="line">    next();</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.run(); <span class="comment">// 调用</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Run Code  1 2 3 ok</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> fn = <span class="keyword">this</span>.arr.reduce(<span class="function">(<span class="params">a, b, index</span>) =&gt;</span> <span class="function">(<span class="params">...args</span>) =&gt;</span></span><br><span class="line">    <span class="built_in">Promise</span>.resolve(a(<span class="function"><span class="params">()</span> =&gt;</span> b(...args)))</span><br><span class="line">)(<span class="function"><span class="params">()</span> =&gt;</span> &#123;&#125;).then(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'ok'</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<ul>
<li>async + await</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">const</span> dispatch = <span class="keyword">async</span> (index) =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span>(index === <span class="keyword">this</span>.arr.length) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.arr[index](<span class="function"><span class="params">()</span>=&gt;</span>dispatch(index+<span class="number">1</span>));</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">return</span> dispatch(<span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<p>async 后面返回的就是promise，不需要再 Promise.resolve()</p>
<h3 id="反柯里化"><a href="#反柯里化" class="headerlink" title="反柯里化"></a>反柯里化</h3><p>反柯里化就是 让某个函数扩大应用的范围</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Object</span>.prototype.toString.call();</span><br><span class="line"><span class="comment">// 这个方法只能在Object原型上用</span></span><br><span class="line"><span class="comment">// 柯里化就是让这个（toString）函数更具体一些，toString具体到Object.prototype上</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 反柯里化就是让这个函数的范围变大一些</span></span><br><span class="line"><span class="built_in">Function</span>.prototype.uncurrying = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 返回的是函数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function">(<span class="params">str</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.call(str);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> toString = <span class="built_in">Object</span>.prototype.toString.uncurrying();</span><br><span class="line"><span class="built_in">console</span>.log(toString(<span class="string">'hello'</span>)); <span class="comment">// 返回的是 [object String]</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.toString(<span class="string">'hello'</span>)); <span class="comment">// [object Object]</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Review</category>
      </categories>
      <tags>
        <tag>Http</tag>
        <tag>Nodejs</tag>
        <tag>Koa</tag>
      </tags>
  </entry>
  <entry>
    <title>webpack 基础篇（一）</title>
    <url>/2019/10/12/Webpack-base/</url>
    <content><![CDATA[<h2 id="1-什么是Webpack？"><a href="#1-什么是Webpack？" class="headerlink" title="1.什么是Webpack？"></a>1.什么是Webpack？</h2><p>webpack 是一个现代 JavaScript 应用程序的静态模块打包器(module bundler),当 webpack 处理应用程序时，它会递归地构建一个依赖关系图(dependency graph)，其中包含应用程序需要的每个模块，然后将所有这些模块打包成一个或多个 bundle<br><img src="http://img.zhufengpeixun.cn/webpack.jpeg" alt></p>
<p>使用Webpack作为前端构建工具：</p>
<ul>
<li>代码转换：TypeScript 编译成 JavaScript、SCSS 编译成 CSS 等。</li>
<li>文件优化：压缩 JavaScript、CSS、HTML 代码，压缩合并图片等。</li>
<li>代码分割：提取多个页面的公共代码、提取首屏不需要执行部分的代码让其异步加载。</li>
<li>模块合并：在采用模块化的项目里会有很多个模块和文件，需要构建功能把模块分类合并成一个文件。</li>
<li>自动刷新：监听本地源代码的变化，自动重新构建、刷新浏览器。</li>
<li>代码校验：在代码被提交到仓库前需要校验代码是否符合规范，以及单元测试是否通过。</li>
<li>自动发布：更新完代码后，自动构建出线上发布代码并传输给发布系统。</li>
</ul>
<p><strong>在<code>webpack</code>应用中有两个核心</strong>:</p>
<ul>
<li>1) 模块转换器，用于把模块原内容按照需求转换成新内容，可以加载非 JS 模块</li>
<li>2) 扩展插件，在 Webpack 构建流程中的特定时机注入扩展逻辑来改变构建结果或做你想要的事情。</li>
</ul>
<h2 id="2-webpack快速上手"><a href="#2-webpack快速上手" class="headerlink" title="2.webpack快速上手"></a>2.webpack快速上手</h2><h3 id="2-1-安装（4-X）"><a href="#2-1-安装（4-X）" class="headerlink" title="2.1 安装（4.X）"></a>2.1 安装（4.X）</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm init -y</span><br><span class="line">npm install webpack webpack-cli --save-dev  (--save-dev表示是一个开发环境)</span><br></pre></td></tr></table></figure>

<p>这里webpack-cli的作用是 可以解析用户传递的参数，将解析好的参数传递给webpack来进行打包。</p>
<h3 id="2-2-初始化项目"><a href="#2-2-初始化项目" class="headerlink" title="2.2 初始化项目"></a>2.2 初始化项目</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">├── src   <span class="comment"># 源码目录</span></span><br><span class="line">│   ├── a-module.js</span><br><span class="line">│   └── index.js</span><br></pre></td></tr></table></figure>

<p>编写 <em>a-module.js</em></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = <span class="string">'hello'</span>;</span><br></pre></td></tr></table></figure>

<p>编写 <em>index.js</em> </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// webpack 默认支持 模块的写法：</span></span><br><span class="line"><span class="comment">// commonjs规范 node     esmodule规范 es6</span></span><br><span class="line"><span class="keyword">let</span> a = <span class="built_in">require</span>(<span class="string">'./a-module'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(a);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这里我们使用<code>CommonJS</code>模块的方式引入，这种方式（在node中可以直接运行）默认在浏览器上是无法运行的，所以我们希望通过 <code>webpack</code> 来进行打包！</p>
</blockquote>
<h3 id="2-3-打包配置"><a href="#2-3-打包配置" class="headerlink" title="2.3 打包配置"></a>2.3 打包配置</h3><blockquote>
<p>这里可以使用<code>npx webpack</code>,<code>npx</code> 是 5.2版本之后<code>npm</code>提供的命令可以执行<code>/module/.bin</code>下的(命令)可执行文件</p>
</blockquote>
<p><img src="http://img.fullstackjavascript.cn/webpack1.png" alt></p>
<p>我们可以发现已经产生了<code>dist</code>目录，此目录为最终打包出的结果。<code>dist/main.js</code>可以在html中直接引用,这里还提示我们默认<code>mode</code> 为<code>production</code><br>npx webpack –mode development | npx webpack –mode production</p>
<blockquote>
<p>也可以配置 script 脚本</p>
</blockquote>
<p><code>webpack</code>默认支持0配置,配置<code>scripts</code>脚本</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">"scripts": &#123;</span><br><span class="line">  "build": "webpack"</span><br><span class="line">&#125;</span><br><span class="line">// 或者</span><br><span class="line">"scripts": &#123;</span><br><span class="line">  "build": "webpack --mode production"</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>npm run</code> 会执行 script中的命令， 执行<code>npm run build</code>,默认会调用 <code>node_modules/.bin</code>下的<code>webpack</code>命令，内部会调用<code>webpack-cli</code>解析用户参数进行打包。默认会以 <code>src/index.js</code> 作为入口文件。</p>
<h3 id="2-4-webpack-config-js"><a href="#2-4-webpack-config-js" class="headerlink" title="2.4 webpack.config.js"></a>2.4 webpack.config.js</h3><p>我们打包时一般不会采用0配置，<code>webpack</code>在打包时默认会查找当前目录下的 <code>webpack.config.js or webpack.file.js</code> 文件。</p>
<p>通过配置文件进行打包<br>新建 webpack.config.js</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// webpack 是基于nodejs（所以可以用node的所有模块） 所以语法规范是commonjs</span></span><br><span class="line"><span class="comment">// 默认导出的是配置对象</span></span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    mode: <span class="string">'development'</span>, <span class="comment">// 当前是开发模式，在这里配置就不需要在script中配置了</span></span><br><span class="line">    <span class="comment">// 入口 出口</span></span><br><span class="line">    entry: path.resolve(__dirname,<span class="string">'./src/index.js'</span>), <span class="comment">// 写路径都采用绝对路径</span></span><br><span class="line">    output:&#123; <span class="comment">// 出口的配置</span></span><br><span class="line">        filename: <span class="string">'bundle.js'</span>,</span><br><span class="line">        path: path.resolve(__dirname,<span class="string">'dist'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-5-配置打包的mode"><a href="#2-5-配置打包的mode" class="headerlink" title="2.5 配置打包的mode"></a>2.5 配置打包的mode</h3><p>我们需要在打包时提供<code>mode</code>属性来区分是开发环境还是生产环境,来实现配置文件的拆分</p>
<p>新建build/ 文件夹</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">├── build</span><br><span class="line">│   ├── webpack.base.js</span><br><span class="line">│   ├── webpack.dev.js</span><br><span class="line">│   └── webpack.prod.js</span><br></pre></td></tr></table></figure>

<p><strong>我们可以通过指定不同的文件来进行打包</strong></p>
<p>配置<code>scripts</code>脚本</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">"scripts": &#123;</span><br><span class="line">  "build": "webpack --config ./build/webpack.prod",</span><br><span class="line">  "dev": "webpack --config ./build/webpack.dev"</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以通过 <code>--config</code> 参数指定,使用哪个配置文件来进行打包 </p>
<p><strong>通过env参数区分</strong></p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">"scripts": &#123;</span><br><span class="line">    "build": "webpack --env.production --config ./build/webpack.base",</span><br><span class="line">    "dev": "webpack --env.development --config ./build/webpack.base"</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>改造<code>webpack.base</code>文件默认导出函数，会将环境变量传入到函数的参数中</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = <span class="function">(<span class="params">env</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(env); <span class="comment">// &#123; development: true &#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>合并配置文件</strong></p>
<p>我们可以判断当前环境是否是开发环境来加载不同的配置,这里我们需要做配置合并<br>安装<code>webpack-merge</code>:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install webpack-merge --save-dev</span><br></pre></td></tr></table></figure>

<p><code>webpack.dev</code>配置</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    mode:<span class="string">'development'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>webpack.prod</code>配置</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    mode:<span class="string">'production'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>webpack.base</code>配置</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"><span class="keyword">const</span> merge = <span class="built_in">require</span>(<span class="string">'webpack-merge'</span>);</span><br><span class="line"><span class="comment">// 开发环境</span></span><br><span class="line"><span class="keyword">const</span> dev = <span class="built_in">require</span>(<span class="string">'./webpack.dev'</span>);</span><br><span class="line"><span class="comment">// 生产环境</span></span><br><span class="line"><span class="keyword">const</span> prod = <span class="built_in">require</span>(<span class="string">'./webpack.prod'</span>);</span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function">(<span class="params">env</span>) =&gt;</span>&#123;</span><br><span class="line">	<span class="keyword">const</span> base = &#123; <span class="comment">// 基础配置</span></span><br><span class="line">		entry:<span class="string">'./src/index.js'</span>,</span><br><span class="line">		output:&#123;</span><br><span class="line">			filename:<span class="string">'bundle.js'</span>,</span><br><span class="line">			path:path.resolve(__dirname,<span class="string">'../dist'</span>)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="keyword">if</span>(env.development)&#123;</span><br><span class="line">        <span class="keyword">return</span> merge(base,dev);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> merge(base,prod)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 函数会返回配置文件，没返回会采用默认配置</span></span><br></pre></td></tr></table></figure>

<p>后续的开发中，我们会将公共的逻辑放到<code>base</code>中,开发和生产对的配置也分别进行存放！</p>
<h2 id="3-webpack-dev-server"><a href="#3-webpack-dev-server" class="headerlink" title="3.webpack-dev-server"></a>3.webpack-dev-server</h2><p>配置开发服务器，它是在内存中打包的，不会产生实体文件，并且自动启动服务</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install webpack-dev-server --save-dev</span><br></pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="code"><pre><span class="line">"scripts": &#123;</span><br><span class="line">    "build": "webpack --env.production --config ./build/webpack.base",</span><br><span class="line">    "dev": "webpack-dev-server --env.development --config ./build/webpack.base"</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过执行<code>npm run dev</code>来启启动开发环境</p>
<p><img src="http://img.fullstackjavascript.cn/webpack2.png" alt></p>
<p>默认会在当前根目录下启动服务</p>
<p><strong>配置开发服务的配置</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>)</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    mode:<span class="string">'development'</span>,</span><br><span class="line">    devServer:&#123;</span><br><span class="line">        <span class="comment">// 更改静态文件目录位置（默认是放在根目录下）</span></span><br><span class="line">        contentBase:path.resolve(__dirname,<span class="string">'../dist'</span>), <span class="comment">// 表示webpack启动服务会在dist目录下</span></span><br><span class="line">        compress:<span class="literal">true</span>, <span class="comment">// 开启gzip  可以提升页面返回的速度</span></span><br><span class="line">        port:<span class="number">3000</span>, <span class="comment">// 更改端口号</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-打包Html插件"><a href="#4-打包Html插件" class="headerlink" title="4.打包Html插件"></a>4.打包Html插件</h2><h3 id="4-1-单入口打包"><a href="#4-1-单入口打包" class="headerlink" title="4.1 单入口打包"></a>4.1 单入口打包</h3><blockquote>
<p>自动产生html，并引入打包后的js文件</p>
</blockquote>
<p>新建 /public/index.html</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"X-UA-Compatible"</span> <span class="attr">content</span>=<span class="string">"ie=edge"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"root"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>配置插件，在打包结束后会将打包的结果自动引进来 并且产生文件到当前的dist/下</p>
<p>编辑<code>webpack.base</code>文件</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"><span class="keyword">const</span> merge = <span class="built_in">require</span>(<span class="string">'webpack-merge'</span>);</span><br><span class="line"><span class="keyword">const</span> dev = <span class="built_in">require</span>(<span class="string">'./webpack.dev'</span>);</span><br><span class="line"><span class="keyword">const</span> prod = <span class="built_in">require</span>(<span class="string">'./webpack.prod'</span>);</span><br><span class="line"><span class="comment">// html插件</span></span><br><span class="line"><span class="keyword">const</span> HtmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">'html-webpack-plugin'</span>);</span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function">(<span class="params">env</span>) =&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> isDev = env.development;</span><br><span class="line">    <span class="keyword">const</span> base = &#123;</span><br><span class="line">        entry:<span class="string">'./src/index.js'</span>,</span><br><span class="line">        output:&#123;</span><br><span class="line">            filename:<span class="string">'bundle.js'</span>,</span><br><span class="line">            path:path.resolve(__dirname,<span class="string">'../dist'</span>)</span><br><span class="line">        &#125;,</span><br><span class="line">        plugins:[</span><br><span class="line">            <span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">                filename:<span class="string">'index.html'</span>, <span class="comment">// 打包出来的文件名</span></span><br><span class="line">                template:path.resolve(__dirname,<span class="string">'../public/index.html'</span>),<span class="comment">// 以这个文件为模板</span></span><br><span class="line">                minify: !isDev &amp;&amp; &#123; <span class="comment">// 压缩</span></span><br><span class="line">                    removeAttributeQuotes: <span class="literal">true</span>, <span class="comment">// 双引号都去掉</span></span><br><span class="line">                    collapseWhitespace: <span class="literal">true</span>, <span class="comment">// dist下产生的html 折叠 显示一行</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(isDev)&#123;</span><br><span class="line">        <span class="keyword">return</span> merge(base,dev);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> merge(base,prod)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>运行 <code>npm run dev</code> 可以看到生成了一个index.html文件，但是是在内存中的看不到，可以访问 <a href="http://localhost:3000/" target="_blank" rel="noopener">http://localhost:3000/</a> 看到有上面的console.log打印 a-module.js中的内容。</p>
</li>
<li><p>运行 <code>npm run build</code> 可以看到dist/下生成了 index.html 、bundle.js，并且 html中自动引入了这个打包后的文件。</p>
</li>
</ul>
<h3 id="4-2-多入口打包"><a href="#4-2-多入口打包" class="headerlink" title="4.2 多入口打包"></a>4.2 多入口打包</h3><p>根据不同入口 生成多个js文件，引入到不同html中</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">── src</span><br><span class="line">    ├── entry-1.js</span><br><span class="line">    └── entry-2.js</span><br></pre></td></tr></table></figure>

<p>多入口需要配置多个entry</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// entry有三种写法 字符串 数组 对象</span></span><br><span class="line">entry:&#123;</span><br><span class="line">    jquery:[<span class="string">'jquery'</span>], <span class="comment">// 打包jquery</span></span><br><span class="line">    entry1:path.resolve(__dirname,<span class="string">'../src/entry-1.js'</span>),</span><br><span class="line">    entry2:path.resolve(__dirname,<span class="string">'../src/entry-2.js'</span>)</span><br><span class="line">&#125;,</span><br><span class="line">output:&#123;</span><br><span class="line">    filename:<span class="string">'[name].js'</span>, <span class="comment">// 这里也要改成动态的名字，多出口，生成jquery.js， entry1.js，entry2.js</span></span><br><span class="line">    path:path.resolve(__dirname,<span class="string">'../dist'</span>)</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<p>产生多个Html文件</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">    filename:<span class="string">'index.html'</span>, </span><br><span class="line">    template:path.resolve(__dirname,<span class="string">'../public/template.html'</span>),</span><br><span class="line">    hash:<span class="literal">true</span>, </span><br><span class="line">    minify:&#123;</span><br><span class="line">        removeAttributeQuotes:<span class="literal">true</span></span><br><span class="line">    &#125;,</span><br><span class="line">    chunks:[<span class="string">'jquery'</span>,<span class="string">'entry1'</span>], <span class="comment">// 引入的代码块chunk 有jquery,entry</span></span><br><span class="line">&#125;),</span><br><span class="line"><span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">    filename:<span class="string">'login.html'</span>,</span><br><span class="line">    template:path.resolve(__dirname,<span class="string">'../public/template.html'</span>),</span><br><span class="line">    hash:<span class="literal">true</span>,</span><br><span class="line">    minify:&#123;</span><br><span class="line">        removeAttributeQuotes:<span class="literal">true</span></span><br><span class="line">    &#125;,</span><br><span class="line">    inject:<span class="literal">false</span>, <span class="comment">// inject 为false表示不注入js文件</span></span><br><span class="line">    chunksSortMode:<span class="string">'manual'</span>, <span class="comment">// 代码块顺序：手动配置</span></span><br><span class="line">    chunks:[<span class="string">'entry2'</span>,<span class="string">'jquery'</span>] <span class="comment">// 这样打包生成的页面中引入的模块的顺序就是这个数组里写的顺序</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>以上的方式不是很优雅，每次都需要手动添加<code>HtmlPlugin</code>应该动态产生<code>html</code>文件，像这样:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> htmlPlugins = [</span><br><span class="line">  &#123;</span><br><span class="line">    entry: <span class="string">"entry1"</span>,</span><br><span class="line">    html: <span class="string">"index.html"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    entry: <span class="string">"entry2"</span>,</span><br><span class="line">    html: <span class="string">"login.html"</span></span><br><span class="line">  &#125;</span><br><span class="line">].map(</span><br><span class="line">  item =&gt;</span><br><span class="line">    <span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">      filename: item.html,</span><br><span class="line">      template: path.resolve(__dirname, <span class="string">"../public/template.html"</span>),</span><br><span class="line">      hash: <span class="literal">true</span>,</span><br><span class="line">      minify: &#123;</span><br><span class="line">        removeAttributeQuotes: <span class="literal">true</span></span><br><span class="line">      &#125;,</span><br><span class="line">      chunks: [<span class="string">"jquery"</span>, item.entry]</span><br><span class="line">    &#125;)</span><br><span class="line">);</span><br><span class="line">plugins: [...htmlPlugins]</span><br></pre></td></tr></table></figure>

<h2 id="5-清空打包结果"><a href="#5-清空打包结果" class="headerlink" title="5.清空打包结果"></a>5.清空打包结果</h2><p>可以使用<code>clean-webpack-plugin</code>手动清除某个文件夹内容:</p>
<p><strong>安装</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install --save-dev clean-webpack-plugin</span><br></pre></td></tr></table></figure>

<p>放到 webpack.prod.js 中</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; CleanWebpackPlugin &#125; = <span class="built_in">require</span>(<span class="string">'clean-webpack-plugin'</span>);</span><br><span class="line"><span class="comment">// 每次打包之前 先清空dist目录下的文件</span></span><br><span class="line"><span class="keyword">new</span> CleanWebpackPlugin()</span><br></pre></td></tr></table></figure>

<p>这样就可以清空指定的目录了,我们可以看到<code>webpack</code>插件的基本用法就是 <code>new Plugin</code>并且放到<code>plugins</code>中</p>
]]></content>
      <categories>
        <category>Webpack</category>
      </categories>
      <tags>
        <tag>Webpack</tag>
      </tags>
  </entry>
  <entry>
    <title>Nodejs-Koa（二）</title>
    <url>/2019/10/12/Nodejs-Koa2/</url>
    <content><![CDATA[<h2 id="回顾"><a href="#回顾" class="headerlink" title="回顾"></a>回顾</h2><p>npm install koa</p>
<ul>
<li>application 核心功能创建一个应用</li>
<li>request  koa自己封装的文件 目的是扩展req</li>
<li>response  koa自己封装的文件 目的是扩展res</li>
<li>context   上下文 整合req和res  核心功能就是代理， 集成了原生的req、res<a id="more"></a>

</li>
</ul>
<h2 id="中间件"><a href="#中间件" class="headerlink" title="中间件"></a>中间件</h2><ul>
<li>koa-bodyparser</li>
<li>koa-static</li>
<li>koa-router</li>
</ul>
<h2 id="koa-bodyparser"><a href="#koa-bodyparser" class="headerlink" title="koa-bodyparser"></a>koa-bodyparser</h2><h3 id="应用-一"><a href="#应用-一" class="headerlink" title="应用 一"></a>应用 一</h3><p>写web服务 核心就是接收用户请求的数据 来解析，返回数据 </p>
<h4 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h4><p>1) 有一个表单，当我访问 /form的时候显示表单<br>2) 当我点击 按钮时能提交</p>
<h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><p>新建form.html</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--form.html--&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"X-UA-Compatible"</span> <span class="attr">content</span>=<span class="string">"ie=edge"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">"/login"</span> <span class="attr">method</span>=<span class="string">"POST"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"username"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"password"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">button</span>&gt;</span>提交<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>新建 1.koa.js</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1.koa.js</span></span><br><span class="line"><span class="keyword">const</span> Koa = <span class="built_in">require</span>(<span class="string">'koa'</span>);</span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> Koa();</span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 中间件的特点 可以组合</span></span><br><span class="line">app.use(<span class="keyword">async</span>(ctx,next)=&gt;&#123;</span><br><span class="line">    <span class="comment">// 写代码以后都用ctx 不用req这些</span></span><br><span class="line">    <span class="keyword">if</span>(ctx.path === <span class="string">'/form'</span> &amp;&amp; ctx.method === <span class="string">'GET'</span>)&#123;</span><br><span class="line">        <span class="comment">// 实现文件下载 指定下载   这样运行之后会下载名字为FileName.txt的文件</span></span><br><span class="line">        <span class="comment">// ctx.set('Content-Disposition', "attachment;filename=FileName.txt");</span></span><br><span class="line">        ctx.set(<span class="string">'Content-Type'</span>, <span class="string">'text/html;charset=utf-8'</span>);</span><br><span class="line">        <span class="comment">// 将文件读取返回</span></span><br><span class="line">        ctx.body = fs.createReadStream(path.resolve(__dirname,<span class="string">'form.html'</span>));</span><br><span class="line">        <span class="comment">// 运行 nodemon 1.koa.js  浏览器打开  http://localhost:3000/form</span></span><br><span class="line">        <span class="comment">// koa这里默认不设置line16会直接下载了form.html文件 ，而line15是可以设置下载及下载文件的名称</span></span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">await</span> next(); <span class="comment">// await next  next()函数执行完成后，没有等待下一个中间件执行完成</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">app.use(<span class="keyword">async</span> (ctx, next)=&gt;&#123;</span><br><span class="line">    <span class="comment">// ***********  1</span></span><br><span class="line">    <span class="keyword">if</span>(ctx.path === <span class="string">'/login'</span> &amp;&amp; ctx.method === <span class="string">'POST'</span>)&#123;</span><br><span class="line">        <span class="keyword">let</span> arr = [];</span><br><span class="line">        ctx.req.on(<span class="string">'data'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">chunk</span>)</span>&#123;</span><br><span class="line">            arr.push(chunk);</span><br><span class="line">        &#125;)</span><br><span class="line">        ctx.req.on(<span class="string">'end'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">let</span> result = Buffer.concat(arr).toString();</span><br><span class="line">            <span class="built_in">console</span>.log(result); <span class="comment">// username=1&amp;password=2</span></span><br><span class="line">            ctx.body = result;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ***********  1 end</span></span><br><span class="line">    <span class="comment">// 1part 这样执行 命令行能够打印出 username=1&amp;password=2   但是服务器没有返回数据给浏览器，因为见line19文字</span></span><br><span class="line">    <span class="comment">// 这里面line19 是等待next()这个promise完成，即等待的是</span></span><br><span class="line">    <span class="comment">// 下面这个line40-line52</span></span><br><span class="line">    <span class="comment">//******************  2</span></span><br><span class="line">    <span class="keyword">async</span> (ctx, next)=&gt;&#123;</span><br><span class="line">        <span class="keyword">if</span>(ctx.path === <span class="string">'/login'</span> &amp;&amp; ctx.method === <span class="string">'POST'</span>)&#123;</span><br><span class="line">            <span class="keyword">let</span> arr = [];</span><br><span class="line">            ctx.req.on(<span class="string">'data'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">chunk</span>)</span>&#123;</span><br><span class="line">                arr.push(chunk);</span><br><span class="line">            &#125;)</span><br><span class="line">            ctx.req.on(<span class="string">'end'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">                <span class="keyword">let</span> result = Buffer.concat(arr).toString();</span><br><span class="line">                <span class="built_in">console</span>.log(result);</span><br><span class="line">                ctx.body = result;</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//******************  2 end</span></span><br><span class="line">   <span class="comment">// 2part 这个函数  而这个函数里面on('data'),on('end')是异步的，相当于最后这个函数返回的是 return undefined，而异步的还没执行完，所以对应ctx.body也是没有值的</span></span><br><span class="line">&#125;)</span><br><span class="line">app.listen(<span class="number">3000</span>); <span class="comment">// 监听3000端口</span></span><br></pre></td></tr></table></figure>

<p>改进如下:<br>koa 所有异步都封装成 promise</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">app.use(<span class="keyword">async</span> (ctx, next)=&gt;&#123;</span><br><span class="line">    <span class="keyword">if</span>(ctx.path === <span class="string">'/login'</span> &amp;&amp; ctx.method === <span class="string">'POST'</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>)=&gt;</span>&#123;</span><br><span class="line">            <span class="keyword">let</span> arr = [];</span><br><span class="line">            ctx.req.on(<span class="string">'data'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">chunk</span>)</span>&#123;</span><br><span class="line">                arr.push(chunk);</span><br><span class="line">            &#125;)</span><br><span class="line">            ctx.req.on(<span class="string">'end'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">                <span class="keyword">let</span> result = Buffer.concat(arr).toString();</span><br><span class="line">                <span class="built_in">console</span>.log(result);</span><br><span class="line">                ctx.body = result;</span><br><span class="line">                resolve();</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="comment">// 运行 可以看到浏览器输出 username=1&amp;password=2</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h5 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h5><blockquote>
<p>koa-bodyparser</p>
</blockquote>
<p> 统一处理请求体   安装第三方包 koa-bodyparser<br> <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"> <span class="comment">// 1.koa.js</span></span><br><span class="line"> <span class="keyword">const</span> Koa = <span class="built_in">require</span>(<span class="string">'koa'</span>);</span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> Koa();</span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"><span class="keyword">const</span> bodyparser = <span class="built_in">require</span>(<span class="string">'koa-bodyparser'</span>); <span class="comment">//  它是一个函数</span></span><br><span class="line"></span><br><span class="line">app.use(bodyparser()); <span class="comment">// 添加这一行</span></span><br><span class="line"></span><br><span class="line">app.use(<span class="keyword">async</span>(ctx,next)=&gt;&#123;</span><br><span class="line">    <span class="keyword">if</span>(ctx.path === <span class="string">'/form'</span> &amp;&amp; ctx.method === <span class="string">'GET'</span>)&#123;</span><br><span class="line">        ctx.set(<span class="string">'Content-Type'</span>, <span class="string">'text/html;charset=utf-8'</span>);</span><br><span class="line">        ctx.body = fs.createReadStream(path.resolve(__dirname,<span class="string">'form.html'</span>));</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">await</span> next();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.use(<span class="keyword">async</span> (ctx, next)=&gt;&#123;</span><br><span class="line">    <span class="keyword">if</span>(ctx.path === <span class="string">'/login'</span> &amp;&amp; ctx.method === <span class="string">'POST'</span>)&#123;</span><br><span class="line">        <span class="comment">// 统一处理请求体</span></span><br><span class="line">        ctx.body = ctx.request.body;</span><br><span class="line">        <span class="comment">// 运行可以看到 服务器端将接收到的值返回给客户端</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">app.listen(<span class="number">3000</span>);</span><br></pre></td></tr></table></figure></p>
<h5 id="手写-bodyparser"><a href="#手写-bodyparser" class="headerlink" title="手写 bodyparser"></a>手写 bodyparser</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1.koa.js</span></span><br><span class="line"><span class="keyword">const</span> Koa = <span class="built_in">require</span>(<span class="string">'koa'</span>);</span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> Koa();</span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"><span class="comment">// const bodyparser = require('koa-bodyparser');</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bodyparser</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">// app.use里面是async函数，现在放置bodyparser()函数，表示bodyparser()执行之后返回的是async，所以如下return async</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">async</span> (ctx, next)=&gt;&#123;</span><br><span class="line">        <span class="keyword">await</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">            <span class="keyword">let</span> arr = [];</span><br><span class="line">            ctx.req.on(<span class="string">'data'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">chunk</span>)</span>&#123;</span><br><span class="line">                arr.push(chunk);</span><br><span class="line">            &#125;)</span><br><span class="line">            ctx.req.on(<span class="string">'end'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">                <span class="keyword">let</span> result = Buffer.concat(arr).toString();</span><br><span class="line">                <span class="built_in">console</span>.log(result);</span><br><span class="line">                <span class="comment">// ctx.body = result;</span></span><br><span class="line">                ctx.request.body = result;<span class="comment">// 这里相比于原来的改一下</span></span><br><span class="line">                resolve();</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="keyword">await</span> next(); <span class="comment">// 再走下面的中间件逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">app.use(bodyparser()); <span class="comment">// 添加这一行</span></span><br><span class="line"></span><br><span class="line">app.use(<span class="keyword">async</span>(ctx,next)=&gt;&#123;</span><br><span class="line">    <span class="keyword">if</span>(ctx.path === <span class="string">'/form'</span> &amp;&amp; ctx.method === <span class="string">'GET'</span>)&#123;</span><br><span class="line">        ctx.set(<span class="string">'Content-Type'</span>, <span class="string">'text/html;charset=utf-8'</span>);</span><br><span class="line">        ctx.body = fs.createReadStream(path.resolve(__dirname,<span class="string">'form.html'</span>));</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">await</span> next();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.use(<span class="keyword">async</span> (ctx, next)=&gt;&#123;</span><br><span class="line">    <span class="keyword">if</span>(ctx.path === <span class="string">'/login'</span> &amp;&amp; ctx.method === <span class="string">'POST'</span>)&#123;</span><br><span class="line">        <span class="comment">// 统一处理请求体</span></span><br><span class="line">        ctx.body = ctx.request.body;</span><br><span class="line">        <span class="comment">// 运行可以看到 服务器端将接收到的值返回给客户端</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 错误处理</span></span><br><span class="line">app.on(<span class="string">'error'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123; <span class="comment">// catch方法</span></span><br><span class="line"></span><br><span class="line">&#125;)</span><br><span class="line">app.listen(<span class="number">3000</span>);</span><br><span class="line"><span class="comment">// 梳理</span></span><br><span class="line"><span class="comment">// 中间件的执行顺序是从上往下  所以这里会先执行line27 将值拿到 再执行下面的</span></span><br></pre></td></tr></table></figure>

<h3 id="应用-二"><a href="#应用-二" class="headerlink" title="应用 二"></a>应用 二</h3><p>新建 form-bodyparser.html， 新增了上传文件类型</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--from-bodyparser.html--&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"X-UA-Compatible"</span> <span class="attr">content</span>=<span class="string">"ie=edge"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">"/login"</span> <span class="attr">method</span>=<span class="string">"POST"</span> <span class="attr">enctype</span>=<span class="string">"multipart/form-data"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"username"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"password"</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--添加图片、文件--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"file"</span> <span class="attr">name</span>=<span class="string">"avatar"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">button</span>&gt;</span>提交<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>上传图片，提交。</p>
<ul>
<li>上传图片   这里因为 1.koa-bodyparser.js line56 打印数据，所以命令行即服务端打印出了图片的二进制数据，因为是二进制 并且这个文件下载了</li>
<li>新建一个 1.txt文件  上传txt文件   可以看到浏览器显示的如图的是form-data格式  现在来自己解析下  通过分隔符将内容分成5分</li>
</ul>
<p>新建 1.txt</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hello word</span><br></pre></td></tr></table></figure>

<p><img src="https://jiafei2333.github.io/html/images/koa-middleware-2.png" alt></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1.koa-bodyparser.js</span></span><br><span class="line"><span class="keyword">const</span> Koa = <span class="built_in">require</span>(<span class="string">'koa'</span>);</span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> Koa();</span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"><span class="keyword">const</span> uuid = <span class="built_in">require</span>(<span class="string">'uuid'</span>);</span><br><span class="line"><span class="comment">// const bodyparser = require('koa-bodyparser');</span></span><br><span class="line">Buffer.prototype.split = <span class="function"><span class="keyword">function</span>(<span class="params">sep</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> len = Buffer.from(sep).length; <span class="comment">// 分割符的长度</span></span><br><span class="line">    <span class="keyword">let</span> offset = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> result = [];</span><br><span class="line">    <span class="keyword">let</span> current;</span><br><span class="line">    <span class="comment">// 把找到的位置赋给current  看一下是否为-1</span></span><br><span class="line">    <span class="keyword">while</span>((current = <span class="keyword">this</span>.indexOf(sep,offset))!==<span class="number">-1</span>)&#123;</span><br><span class="line">        result.push(<span class="keyword">this</span>.slice(offset,current)); <span class="comment">// 把每次的记过push到数组中</span></span><br><span class="line">        offset = current + len <span class="comment">// 增加查找偏移量</span></span><br><span class="line">    &#125;</span><br><span class="line">    result.push(<span class="keyword">this</span>.slice(offset)); <span class="comment">// 最后一段追加进去</span></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bodyparser</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">async</span> (ctx, next)=&gt;&#123;</span><br><span class="line">        <span class="keyword">await</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">            <span class="keyword">let</span> arr = [];</span><br><span class="line">            ctx.req.on(<span class="string">'data'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">chunk</span>)</span>&#123;</span><br><span class="line">                arr.push(chunk);</span><br><span class="line">            &#125;)</span><br><span class="line">            ctx.req.on(<span class="string">'end'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">                <span class="comment">// 如果当前提交过来的数据不是正常json，表单格式，我们需要自己解析</span></span><br><span class="line">                <span class="keyword">let</span> type = ctx.get(<span class="string">'content-type'</span>);</span><br><span class="line">                <span class="keyword">let</span> obj = &#123;&#125;;</span><br><span class="line">                <span class="keyword">if</span>(type.includes(<span class="string">'multipart/form-data'</span>))&#123;</span><br><span class="line">                    <span class="comment">// let result = Buffer.concat(arr).toString();</span></span><br><span class="line">                    <span class="comment">// 这里不能toString 因为提交的数据可能是二进制的，那么如图hello word的位置就会是一堆乱码，如果，根据分隔符将内容分成5分，如图我们要取123部分</span></span><br><span class="line">                    <span class="keyword">let</span> buff = Buffer.concat(arr);</span><br><span class="line">                    <span class="keyword">let</span> boundary = type.split(<span class="string">"="</span>)[<span class="number">1</span>];</span><br><span class="line">                    boundary = <span class="string">'--'</span> + boundary;</span><br><span class="line">                    <span class="keyword">let</span> lines = buff.split(boundary).slice(<span class="number">1</span>,<span class="number">-1</span>);</span><br><span class="line">                    <span class="comment">// 如图①②③，头 和 体之间由2个换行回车分割， 这个是规定的</span></span><br><span class="line">                    lines.forEach(<span class="function">(<span class="params">line</span>) =&gt;</span> &#123;</span><br><span class="line">                        <span class="keyword">let</span> [head,content] = line.split(<span class="string">'\r\n\r\n'</span>);</span><br><span class="line">                        head = head.toString();</span><br><span class="line">                        <span class="keyword">let</span> key = head.match(<span class="regexp">/name="(.+?)"/</span>)[<span class="number">1</span>]; <span class="comment">// ?非贪婪模式</span></span><br><span class="line">                        <span class="keyword">if</span>(head.includes(<span class="string">'filename'</span>))&#123; <span class="comment">// 文件  把它放到upload里面</span></span><br><span class="line">                            <span class="comment">// 产生随机名  第三方库uuid</span></span><br><span class="line">                            <span class="keyword">let</span> filename = uuid.v4();</span><br><span class="line">                            fs.writeFileSync(path.resolve(__dirname,<span class="string">"upload"</span>,filename),content.slice(<span class="number">0</span>,<span class="number">-2</span>),<span class="string">'utf8'</span>);</span><br><span class="line">                            obj[key] = filename;</span><br><span class="line">                            <span class="comment">// 到这里可以看到上传的文件都存储在了./upload/下  如图 upload</span></span><br><span class="line">                        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                            <span class="comment">// 这里像 1  2  hello word后面还有一个\r\n 所以最后2位不取</span></span><br><span class="line">                            obj[key] = content.slice(<span class="number">0</span>,<span class="number">-2</span>).toString();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;)</span><br><span class="line">                    <span class="built_in">console</span>.log(obj);</span><br><span class="line">                    ctx.request.body = obj;</span><br><span class="line">                    resolve();</span><br><span class="line">                    </span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    resolve();</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="keyword">await</span> next(); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">app.use(bodyparser());</span><br><span class="line"></span><br><span class="line">app.use(<span class="keyword">async</span>(ctx,next)=&gt;&#123;</span><br><span class="line">    <span class="keyword">if</span>(ctx.path === <span class="string">'/form-bodyparser'</span> &amp;&amp; ctx.method === <span class="string">'GET'</span>)&#123;</span><br><span class="line">        ctx.set(<span class="string">'Content-Type'</span>, <span class="string">'text/html;charset=utf-8'</span>);</span><br><span class="line">        ctx.body = fs.createReadStream(path.resolve(__dirname,<span class="string">'form-bodyparser.html'</span>));</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">await</span> next();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.use(<span class="keyword">async</span> (ctx, next)=&gt;&#123;</span><br><span class="line">    <span class="keyword">if</span>(ctx.path === <span class="string">'/login'</span> &amp;&amp; ctx.method === <span class="string">'POST'</span>)&#123;</span><br><span class="line">        ctx.body = ctx.request.body;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 错误处理</span></span><br><span class="line">app.on(<span class="string">'error'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123; <span class="comment">// catch方法</span></span><br><span class="line"></span><br><span class="line">&#125;)</span><br><span class="line">app.listen(<span class="number">3000</span>);</span><br></pre></td></tr></table></figure>

<p><img src="https://jiafei2333.github.io/html/images/koa-middleware-3.png" alt title="upload"></p>
<p>上传的文件都被放在 /upload/ 文件夹下</p>
<h2 id="koa-static"><a href="#koa-static" class="headerlink" title="koa-static"></a>koa-static</h2><h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><p>静态文件中间件</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--form-bodyparser.html--&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"X-UA-Compatible"</span> <span class="attr">content</span>=<span class="string">"ie=edge"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"./upload/bd3fe091-6bef-4403-b2ed-04c63adfb768.png"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">"/login"</span> <span class="attr">method</span>=<span class="string">"POST"</span> <span class="attr">enctype</span>=<span class="string">"multipart/form-data"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"username"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"password"</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--添加图片--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"file"</span> <span class="attr">name</span>=<span class="string">"avatar"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">button</span>&gt;</span>提交<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>如果 页面中有引用图片 如form-bodyparser.html line11 但是页面中没有显示</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 2.static.js</span></span><br><span class="line"><span class="keyword">const</span> Koa = <span class="built_in">require</span>(<span class="string">'koa'</span>);</span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> Koa();</span><br><span class="line"><span class="keyword">const</span> &#123;createWriteStream, createReadStream&#125; = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>).promises;</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"><span class="keyword">const</span> uuid = <span class="built_in">require</span>(<span class="string">'uuid'</span>);</span><br><span class="line"><span class="keyword">const</span> mime = <span class="built_in">require</span>(<span class="string">'mime'</span>);</span><br><span class="line"><span class="comment">// const static = require('koa-static');</span></span><br><span class="line"><span class="comment">// const bodyparser = require('koa-bodyparser');</span></span><br><span class="line">Buffer.prototype.split = <span class="function"><span class="keyword">function</span>(<span class="params">sep</span>)</span>&#123;</span><br><span class="line">    .....</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bodyparser</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    .....</span><br><span class="line">&#125;</span><br><span class="line">app.use(bodyparser());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 静态文件中间件    koa-static</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">static</span>(<span class="params">dirname</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">async</span> (ctx,next)=&gt;&#123;</span><br><span class="line">        <span class="comment">// 这里先明确 当前这个async方法如果处理的了就不用调next()，处理不了再调next()</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> filePath = path.join(dirname, ctx.path);</span><br><span class="line">            <span class="keyword">let</span> statObj = <span class="keyword">await</span> fs.stat(filePath);</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'静态文件路径1'</span>, filePath);</span><br><span class="line">            <span class="comment">// /Users/jiafei/Desktop/Architecture-Course/20.koa/upload/bd3fe091-6bef-4403-b2ed-04c63adfb768.png</span></span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'静态文件路径2'</span>, dirname);</span><br><span class="line">            <span class="comment">// /Users/jiafei/Desktop/Architecture-Course/20.koa</span></span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'静态文件路径3'</span>, ctx.path);</span><br><span class="line">            <span class="comment">// /upload/bd3fe091-6bef-4403-b2ed-04c63adfb768.png</span></span><br><span class="line">            <span class="keyword">if</span>(statObj.isDirectory())&#123;</span><br><span class="line">                filePath = path.join(filePath, <span class="string">'index.html'</span>);</span><br><span class="line">                <span class="keyword">await</span> fs.access(filePath);</span><br><span class="line">            &#125;</span><br><span class="line">            ctx.set(<span class="string">'Content-Type'</span>,mime.getType(filePath) + <span class="string">';charset=utf-8'</span>);</span><br><span class="line">            ctx.body = createReadStream(filePath);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">            <span class="keyword">await</span> next();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;  </span><br><span class="line">&#125; <span class="comment">// 这样页面上就能显示图片了</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里把它当做插件来用，中间件都是函数，好处是可以传参，根据用户访问的路径，去对应的目录下查找，查找到返回即可，找不到交给下一个中间件,如下：</span></span><br><span class="line">app.use(<span class="keyword">static</span>(__dirname));</span><br><span class="line">app.use(<span class="keyword">static</span>(path.resolve(__dirname,<span class="string">'upload'</span>)));</span><br><span class="line"></span><br><span class="line">app.use(<span class="keyword">async</span>(ctx,next)=&gt;&#123;</span><br><span class="line">    <span class="keyword">if</span>(ctx.path === <span class="string">'/form-bodyparser'</span> &amp;&amp; ctx.method === <span class="string">'GET'</span>)&#123;</span><br><span class="line">        ctx.set(<span class="string">'Content-Type'</span>, <span class="string">'text/html;charset=utf-8'</span>);</span><br><span class="line">        ctx.body = createReadStream(path.resolve(__dirname,<span class="string">'form-bodyparser.html'</span>));</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">await</span> next();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.use(<span class="keyword">async</span> (ctx, next)=&gt;&#123;</span><br><span class="line">    <span class="keyword">if</span>(ctx.path === <span class="string">'/login'</span> &amp;&amp; ctx.method === <span class="string">'POST'</span>)&#123;</span><br><span class="line">        ctx.body = ctx.request.body;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 错误处理</span></span><br><span class="line">app.on(<span class="string">'error'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123; <span class="comment">// catch方法</span></span><br><span class="line">    <span class="built_in">console</span>.log(err);</span><br><span class="line">&#125;)</span><br><span class="line">app.listen(<span class="number">3000</span>);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// 如果 页面中有引用图片 如form-bodyparser.html line10 但是页面中没有显示</span></span><br><span class="line"><span class="comment">app.use(async(ctx,next)=&gt;&#123;</span></span><br><span class="line"><span class="comment">    ctx.path === '/upload/xxxxx'</span></span><br><span class="line"><span class="comment">&#125;)</span></span><br><span class="line"><span class="comment">// 这是就需要再写一个app.use....来判断upload下的xxx，或者有其他的文件再写ctx.path===xxx来判断，一直重复做这个功能，并且这样也不好扩展，希望把这些功能统一处理，可以放到最上面，写一个中间件，中间件能够处理的话就不用下面处理了   如上 static()</span></span><br></pre></td></tr></table></figure>

<h2 id="koa-router"><a href="#koa-router" class="headerlink" title="koa-router"></a>koa-router</h2><h3 id="应用-1"><a href="#应用-1" class="headerlink" title="应用"></a>应用</h3><h4 id="1】"><a href="#1】" class="headerlink" title="1】"></a>1】</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Koa = <span class="built_in">require</span>(<span class="string">'koa'</span>);</span><br><span class="line"><span class="keyword">const</span> bodyparser = <span class="built_in">require</span>(<span class="string">'koa-bodyparser'</span>);</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">static</span> = <span class="built_in">require</span>(<span class="string">'koa-static'</span>);</span><br><span class="line"><span class="keyword">const</span> Router = <span class="built_in">require</span>(<span class="string">'koa-router'</span>);</span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> app = <span class="keyword">new</span> Koa();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果处理了静态文件，就不用处理请求体了,所以顺序先line11再line12</span></span><br><span class="line">app.use(<span class="keyword">static</span>(__dirname));</span><br><span class="line">app.use(bodyparser());</span><br><span class="line"></span><br><span class="line"><span class="comment">// app.use((ctx,next)=&gt;&#123;</span></span><br><span class="line"><span class="comment">//     if(...) 将一系列的路径判断用下面路由的方式匹配</span></span><br><span class="line"><span class="comment">// &#125;)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> router = <span class="keyword">new</span> Router();</span><br><span class="line"><span class="comment">// 路由匹配 会匹配方法和路径</span></span><br><span class="line">router.get(<span class="string">'/form'</span>, <span class="keyword">async</span>(ctx,next)=&gt;&#123;</span><br><span class="line">    ctx.set(<span class="string">'Content-Type'</span>, <span class="string">'text/html'</span>);</span><br><span class="line">    ctx.body = fs.createReadStream(path.resolve(__dirname,<span class="string">'form.html'</span>));</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">router.post(<span class="string">'/login'</span>, <span class="keyword">async</span>(ctx,next)=&gt;&#123;</span><br><span class="line">    ctx.body = ctx.request.body;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 挂载</span></span><br><span class="line">app.use(router.routes());</span><br><span class="line">app.listen(<span class="number">3000</span>);</span><br></pre></td></tr></table></figure>

<h4 id="2】"><a href="#2】" class="headerlink" title="2】"></a>2】</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Koa = <span class="built_in">require</span>(<span class="string">'koa'</span>);</span><br><span class="line"><span class="keyword">const</span> bodyparser = <span class="built_in">require</span>(<span class="string">'koa-bodyparser'</span>);</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">static</span> = <span class="built_in">require</span>(<span class="string">'koa-static'</span>);</span><br><span class="line"><span class="keyword">const</span> Router = <span class="built_in">require</span>(<span class="string">'koa-router'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> app = <span class="keyword">new</span> Koa();</span><br><span class="line"></span><br><span class="line">app.use(<span class="keyword">static</span>(__dirname));</span><br><span class="line">app.use(bodyparser());</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> router = <span class="keyword">new</span> Router();</span><br><span class="line"></span><br><span class="line">router.get(<span class="string">'/'</span>, <span class="keyword">async</span>(ctx,next)=&gt;&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">    next();</span><br><span class="line">&#125;)</span><br><span class="line">router.get(<span class="string">'/'</span>, <span class="keyword">async</span>(ctx,next)=&gt;&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line">&#125;)</span><br><span class="line">router.get(<span class="string">'/user'</span>, <span class="keyword">async</span>(ctx,next)=&gt;&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">3</span>);</span><br><span class="line">    next();</span><br><span class="line">&#125;)</span><br><span class="line">router.get(<span class="string">'/user'</span>, <span class="keyword">async</span>(ctx,next)=&gt;&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">4</span>);</span><br><span class="line">    next();</span><br><span class="line">&#125;)</span><br><span class="line">app.use(router.routes());</span><br><span class="line"></span><br><span class="line">app.use(<span class="keyword">async</span>(ctx,next)=&gt;&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">5</span>);</span><br><span class="line">&#125;)</span><br><span class="line">app.listen(<span class="number">3000</span>);</span><br></pre></td></tr></table></figure>

<p>浏览器访问 <a href="http://localhost:3000/" target="_blank" rel="noopener">http://localhost:3000/</a>   服务端打印 1 2<br>浏览器访问 <a href="http://localhost:3000/user" target="_blank" rel="noopener">http://localhost:3000/user</a>   服务端打印 3 4 5</p>
<h4 id="匹配问题"><a href="#匹配问题" class="headerlink" title="匹配问题"></a>匹配问题</h4><ul>
<li>默认路由是严格匹配 <ul>
<li>1、路径相同  </li>
<li>2、写成正则的方式 //a/b+/</li>
<li>3、/a/:name 路径参数  这个name表示占位符 必须要有值</li>
</ul>
</li>
</ul>
<h5 id="1-路径严格相同："><a href="#1-路径严格相同：" class="headerlink" title="1) 路径严格相同："></a>1) 路径严格相同：</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Koa = <span class="built_in">require</span>(<span class="string">'koa'</span>);</span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> Koa();</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Router = <span class="built_in">require</span>(<span class="string">'koa-router'</span>);</span><br><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> Router();</span><br><span class="line"></span><br><span class="line">router.get(<span class="string">'/'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">ctx</span>) </span>&#123;</span><br><span class="line">    ctx.body = <span class="string">'hello'</span>;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app</span><br><span class="line">    .use(router.routes())</span><br><span class="line">    .use(router.allowedMethods()) <span class="comment">// 表示当前这个路由可以允许哪些方法   405</span></span><br><span class="line"></span><br><span class="line">app.listen(<span class="number">3000</span>);</span><br></pre></td></tr></table></figure>

<p>运行 可以看到浏览器输出 hello<br>如果把line7换成post</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Koa = <span class="built_in">require</span>(<span class="string">'koa'</span>);</span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> Koa();</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Router = <span class="built_in">require</span>(<span class="string">'koa-router'</span>);</span><br><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> Router();</span><br><span class="line"></span><br><span class="line">router.post(<span class="string">'/'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">ctx</span>) </span>&#123;</span><br><span class="line">    ctx.body = <span class="string">'hello'</span>;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app</span><br><span class="line">    .use(router.routes())</span><br><span class="line">    .use(router.allowedMethods()) <span class="comment">// 表示当前这个路由可以允许哪些方法   405</span></span><br><span class="line"></span><br><span class="line">app.listen(<span class="number">3000</span>);</span><br></pre></td></tr></table></figure>

<p>浏览器运行 <a href="http://localhost:3000/" target="_blank" rel="noopener">http://localhost:3000/</a> 如图：</p>
<p><img src="https://jiafei2333.github.io/html/images/koa-router.png" alt></p>
<p>当前只运行 POST 访问</p>
<h5 id="2-正则匹配："><a href="#2-正则匹配：" class="headerlink" title="2) 正则匹配："></a>2) 正则匹配：</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1）路径严格相同 如下line9 如果写的是/a/b  浏览器访问/a就访问不到</span></span><br><span class="line"><span class="comment">// 2）放正则,能匹配上也行  如下line10  浏览器访问 /a/123</span></span><br><span class="line"><span class="keyword">const</span> Koa = <span class="built_in">require</span>(<span class="string">'koa'</span>);</span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> Koa();</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Router = <span class="built_in">require</span>(<span class="string">'koa-router'</span>);</span><br><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> Router();</span><br><span class="line"></span><br><span class="line"><span class="comment">// router.get('/a/b', function (ctx) &#123;</span></span><br><span class="line">router.get(<span class="regexp">/\/a\/\d+/</span>, <span class="function"><span class="keyword">function</span> (<span class="params">ctx</span>) </span>&#123;</span><br><span class="line">    ctx.body = <span class="string">'hello'</span>;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app</span><br><span class="line">    .use(router.routes())</span><br><span class="line">    .use(router.allowedMethods())</span><br><span class="line"></span><br><span class="line">app.listen(<span class="number">3000</span>);</span><br></pre></td></tr></table></figure>

<h5 id="3-路径参数"><a href="#3-路径参数" class="headerlink" title="3) 路径参数:"></a>3) 路径参数:</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Koa = <span class="built_in">require</span>(<span class="string">'koa'</span>);</span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> Koa();</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Router = <span class="built_in">require</span>(<span class="string">'koa-router'</span>);</span><br><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> Router();</span><br><span class="line"></span><br><span class="line">router.get(<span class="string">'/a/:name/:id'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">ctx,next</span>) </span>&#123; <span class="comment">// /a/1/id/2   =&gt; &#123;name:1,id:2&#125;</span></span><br><span class="line">    ctx.body = ctx.params;</span><br><span class="line">    <span class="comment">// next();</span></span><br><span class="line">&#125;)</span><br><span class="line">router.get(<span class="regexp">/\/a\/\d+/</span>, <span class="function"><span class="keyword">function</span> (<span class="params">ctx</span>) </span>&#123;</span><br><span class="line">    ctx.body = <span class="string">'hello'</span>;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app</span><br><span class="line">    .use(router.routes())</span><br><span class="line">    .use(router.allowedMethods())</span><br><span class="line"></span><br><span class="line">app.listen(<span class="number">3000</span>);</span><br></pre></td></tr></table></figure>

<p>运行  <a href="http://localhost:3000/a/1/2" target="_blank" rel="noopener">http://localhost:3000/a/1/2</a>   浏览器输出 {“name”:”1”,”id”:”2”}<br>如果把line9注释打开  浏览器输出  hello  ,如果把正则改成 //ab/\d+/  正则这个匹配不上 还是输出上一个结果 </p>
<h5 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h5><p> 可以给一个默认的路由前缀如line5 浏览器 <a href="http://localhost:3000/a/1/2" target="_blank" rel="noopener">http://localhost:3000/a/1/2</a>  也能够正常访问到 并且输出{“name”:”1”,”id”:”2”}</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Koa = <span class="built_in">require</span>(<span class="string">'koa'</span>);</span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> Koa();</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Router = <span class="built_in">require</span>(<span class="string">'koa-router'</span>);</span><br><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> Router(&#123;<span class="attr">prefix</span>:<span class="string">'/a'</span>&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果这时访问首页</span></span><br><span class="line">router.get(<span class="string">'/'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">ctx,next</span>) </span>&#123;</span><br><span class="line">    ctx.body = <span class="string">'home'</span>;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// http://localhost:3000/a 可以输出home  但是访问必须带/a 路由现在已经限制死了，必须带/a前缀 解决： 如下part</span></span><br><span class="line"></span><br><span class="line">app</span><br><span class="line">    .use(router.routes())</span><br><span class="line">    .use(router.allowedMethods())</span><br><span class="line"></span><br><span class="line">app.listen(<span class="number">3000</span>);</span><br></pre></td></tr></table></figure>

<p>解决：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 描述：有个大路由(一级路由)  下面可以挂载2个小路由 (二级路由(/a /b))</span></span><br><span class="line"><span class="keyword">const</span> Koa = <span class="built_in">require</span>(<span class="string">'koa'</span>);</span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> Koa();</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Router = <span class="built_in">require</span>(<span class="string">'koa-router'</span>);</span><br><span class="line"><span class="keyword">const</span> parent = <span class="keyword">new</span> Router();</span><br><span class="line"><span class="keyword">const</span> child1 = <span class="keyword">new</span> Router();</span><br><span class="line"><span class="keyword">const</span> child2 = <span class="keyword">new</span> Router();</span><br><span class="line"></span><br><span class="line">parent.get(<span class="string">'/'</span>,<span class="function"><span class="keyword">function</span> (<span class="params">ctx,next</span>) </span>&#123;</span><br><span class="line">    ctx.body = <span class="string">'home'</span>;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">child1.get(<span class="string">'/'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">ctx,next</span>) </span>&#123;</span><br><span class="line">    ctx.body = <span class="string">'/a'</span>;</span><br><span class="line">&#125;)</span><br><span class="line">child2.get(<span class="string">'/'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">ctx,next</span>) </span>&#123;</span><br><span class="line">    ctx.body = <span class="string">'/b'</span>;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">parent.use(<span class="string">'/a'</span>,child1.routes());</span><br><span class="line">parent.use(<span class="string">'/b'</span>,child2.routes());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">app</span><br><span class="line">    .use(parent.routes())</span><br><span class="line">    .use(parent.allowedMethods())</span><br><span class="line"></span><br><span class="line">app.listen(<span class="number">3000</span>);</span><br></pre></td></tr></table></figure>

<p>以上用法一般情况下不用自己建 koa2里面提供了自带的模板</p>
<p><code>npm install koa-generator -g</code></p>
<p>里面会生成2个 koa、koa2， koa里面是基于generatore语法的，现在基本不用了，现在用koa2<br>查看命令行用法 koa2 –help<br>生成项目 koa2 -e(代表ejs) my-project 生成项目   </p>
]]></content>
      <categories>
        <category>Nodejs</category>
      </categories>
      <tags>
        <tag>Nodejs</tag>
        <tag>Koa</tag>
        <tag>中间件</tag>
      </tags>
  </entry>
  <entry>
    <title>Nodejs-Koa（一）</title>
    <url>/2019/10/10/Nodejs-Koa/</url>
    <content><![CDATA[<h1 id="Koa"><a href="#Koa" class="headerlink" title="Koa"></a>Koa</h1><p>koa官网 <a href="http://koajs.cn" target="_blank" rel="noopener">http://koajs.cn</a></p>
<h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">npm init -y</span><br><span class="line">npm install koa</span><br></pre></td></tr></table></figure>

<blockquote>
<p>不管看什么源码 第一步 node_modules/koa/package.json 找package.json文件，找里面的main  这里是  “main”: “lib/application.js”,  然后再去lib找 application.js</p>
</blockquote>
<a id="more"></a>

<h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1.helloword.js</span></span><br><span class="line"><span class="keyword">const</span> Koa = <span class="built_in">require</span>(<span class="string">'koa'</span>);</span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> Koa();</span><br><span class="line"></span><br><span class="line"><span class="comment">// node有原生的 req res(原生)</span></span><br><span class="line"><span class="comment">// request response (koa自己封装的) 又增加了很多的方法</span></span><br><span class="line"><span class="comment">// ctx代理了 req res request response </span></span><br><span class="line">app.use(<span class="function"><span class="params">ctx</span> =&gt;</span> &#123; <span class="comment">// ctx代表上下文</span></span><br><span class="line">    <span class="comment">// console.log(ctx.request.path);// /    // 现在就不用记是request、response的方法直接如下：</span></span><br><span class="line">    <span class="built_in">console</span>.log(ctx.path); <span class="comment">// /</span></span><br><span class="line">    <span class="comment">// 本来这里结束可以用res.end();但是官网上说尽量避免使用node属性 所以现在如下：</span></span><br><span class="line">    <span class="comment">// ctx.body = &#123;name: 'jf'&#125;; // 运行 浏览器输出 &#123;"name":"jf"&#125;</span></span><br><span class="line">    <span class="comment">// 当然也可以还是用之前的</span></span><br><span class="line">    ctx.res.end(<span class="string">'hello'</span>); <span class="comment">// 运行 浏览器输出 hello</span></span><br><span class="line">&#125;);</span><br><span class="line">app.listen(<span class="number">3000</span>);</span><br><span class="line"><span class="comment">// 运行 nodemon 1.helloword.js   浏览器访问 http://localhost:3000/?a=1</span></span><br></pre></td></tr></table></figure>

<p>Context 上下文 <a href="http://koajs.cn/#-context-" target="_blank" rel="noopener">http://koajs.cn/#-context-</a></p>
<h1 id="手写Koa原理"><a href="#手写Koa原理" class="headerlink" title="手写Koa原理"></a>手写Koa原理</h1><p>新建文件夹koa   koa/application.js</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 2.server.js</span></span><br><span class="line"><span class="keyword">const</span> Koa = <span class="built_in">require</span>(<span class="string">'./koa/application'</span>); <span class="comment">// 核心逻辑，这里对照原生koa/lib/下的文件，新建context.js|request.js|response.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> Koa();</span><br><span class="line">app.use(<span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">    res.end(<span class="string">'hello word'</span>);</span><br><span class="line">&#125;)</span><br><span class="line">app.listen(<span class="number">4000</span>);</span><br></pre></td></tr></table></figure>

<p>application.js</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ./koa/application.js</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 需要导出一个Koa类</span></span><br><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Application</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如上面 `2.server.js` line1-8 有2个方法use、listen</span></span><br><span class="line">    use(fn)&#123; <span class="comment">// 注册方法</span></span><br><span class="line">        <span class="keyword">this</span>.fn = fn;</span><br><span class="line">    &#125;</span><br><span class="line">    handleRequest(req, res)&#123;</span><br><span class="line">        <span class="keyword">this</span>.fn(req,res);</span><br><span class="line">    &#125;</span><br><span class="line">    listen(...args)&#123; <span class="comment">// 监听端口</span></span><br><span class="line">        <span class="keyword">let</span> server = http.createServer(<span class="keyword">this</span>.handleRequest.bind(<span class="keyword">this</span>));</span><br><span class="line">        server.listen(...args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">module</span>.exports = Application;</span><br><span class="line"><span class="comment">// 运行 nodemon 2.reserver.js  , 浏览器运行localhost:4000</span></span><br><span class="line"><span class="comment">// 可以看到浏览器打印出hello word</span></span><br></pre></td></tr></table></figure>

<p> 功能上基本类似 但是 <code>2.server.js</code> line5这里不是req、res 而是ctx 如下:<br>新建 context.js &nbsp;&nbsp; request.js &nbsp;&nbsp; response.js</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// context.js</span></span><br><span class="line"><span class="keyword">let</span> context = &#123;&#125;;</span><br><span class="line"><span class="built_in">module</span>.exports = context;</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// request.js</span></span><br><span class="line"><span class="keyword">let</span> request = &#123;&#125;;</span><br><span class="line"><span class="built_in">module</span>.exports = request;</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// response.js</span></span><br><span class="line"><span class="keyword">let</span> response = &#123;&#125;;</span><br><span class="line"><span class="built_in">module</span>.exports = response;</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 2.server.js</span></span><br><span class="line"><span class="keyword">const</span> Koa = <span class="built_in">require</span>(<span class="string">'./koa/application'</span>); </span><br><span class="line"><span class="comment">//const Koa = require('koa');</span></span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> Koa();</span><br><span class="line"></span><br><span class="line">app.use(<span class="function"><span class="params">ctx</span> =&gt;</span> &#123; <span class="comment">// 这里修改成ctx</span></span><br><span class="line">    <span class="comment">// res.end('hello word');</span></span><br><span class="line">	<span class="comment">// 原生****************************************</span></span><br><span class="line">    <span class="comment">// 原生的写法 line3打开注释</span></span><br><span class="line">    <span class="comment">// console.log(ctx.req.url); //  / </span></span><br><span class="line">    <span class="comment">// console.log(ctx.request.req.url); //  /</span></span><br><span class="line">    <span class="comment">// //line10、11调用的是原生的、line13、14调用的是自己封装的</span></span><br><span class="line">    <span class="comment">// console.log(ctx.request.url); //  /</span></span><br><span class="line">    <span class="comment">// console.log(ctx.url);</span></span><br><span class="line">	<span class="comment">// end ***************************************</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 引用自己的写的Koa</span></span><br><span class="line">    <span class="built_in">console</span>.log(ctx.req.url); <span class="comment">//  / 这个req是原生的</span></span><br><span class="line">    <span class="built_in">console</span>.log(ctx.request.req.url); <span class="comment">//  </span></span><br><span class="line">    <span class="built_in">console</span>.log(ctx.request.url); <span class="comment">// 这里必须要把req放到request上，才可以在request上拿到req的属性</span></span><br><span class="line">    <span class="built_in">console</span>.log(ctx.url);<span class="comment">// 它的原理非常像vue ctx.url =&gt; ctx.request.url  代理</span></span><br><span class="line">    <span class="built_in">console</span>.log(ctx.path);</span><br><span class="line">&#125;)</span><br><span class="line">app.listen(<span class="number">4000</span>);</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ./koa/application.js</span></span><br><span class="line"><span class="comment">// ctx需要整合req res</span></span><br><span class="line"><span class="comment">// 封装request和response对象 把他放到ctx上</span></span><br><span class="line"><span class="comment">// 现在分别初始化创建这个三个文件里的对象</span></span><br><span class="line"><span class="keyword">let</span> context = <span class="built_in">require</span>(<span class="string">'./context'</span>);</span><br><span class="line"><span class="keyword">let</span> request = <span class="built_in">require</span>(<span class="string">'./request'</span>);</span><br><span class="line"><span class="keyword">let</span> response = <span class="built_in">require</span>(<span class="string">'./response'</span>);</span><br><span class="line"><span class="comment">// 这些属性可能在后序的逻辑中都会用到，全局的话放在constructor中</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Application</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>()&#123;        </span><br><span class="line">        <span class="keyword">this</span>.context = context;</span><br><span class="line">        <span class="keyword">this</span>.request = request;</span><br><span class="line">        <span class="keyword">this</span>.response = response;</span><br><span class="line">        <span class="comment">// 看下源码 这里需要修改下</span></span><br><span class="line">    &#125;</span><br><span class="line">    use(fn)&#123; <span class="comment">// 注册方法</span></span><br><span class="line">        <span class="keyword">this</span>.fn = fn;</span><br><span class="line">    &#125;</span><br><span class="line">    createContext(req, res)&#123;</span><br><span class="line">		<span class="comment">// 表示context继承this.context且不会破坏原有的对象，方便扩展</span></span><br><span class="line">        <span class="keyword">let</span> context = <span class="built_in">Object</span>.create(<span class="keyword">this</span>.context); <span class="comment">// 每次都创建全新的上下文</span></span><br><span class="line">        context.request = <span class="built_in">Object</span>.create(<span class="keyword">this</span>.request);</span><br><span class="line">        context.response = <span class="built_in">Object</span>.create(<span class="keyword">this</span>.response);</span><br><span class="line">        <span class="comment">// 我在koa自己的封装的对象上增加 req和res属性</span></span><br><span class="line">        context.req = context.request.req = req;</span><br><span class="line">        context.res = context.response.res = res;</span><br><span class="line">        <span class="comment">// 上面对应 `2.server.js` line 18、19</span></span><br><span class="line">        <span class="comment">// `2.server.js` line20见request.js</span></span><br><span class="line">        <span class="keyword">return</span> context;</span><br><span class="line">    &#125;</span><br><span class="line">    handleRequest(req, res)&#123;</span><br><span class="line">        <span class="comment">// 创建上下文</span></span><br><span class="line">        <span class="keyword">let</span> ctx = <span class="keyword">this</span>.createContext(req, res);</span><br><span class="line">        <span class="keyword">this</span>.fn(ctx);</span><br><span class="line">        <span class="comment">// this.fn(req,res);</span></span><br><span class="line">    &#125;</span><br><span class="line">    listen(...args)&#123; <span class="comment">// 监听端口</span></span><br><span class="line">        <span class="keyword">let</span> server = http.createServer(<span class="keyword">this</span>.handleRequest.bind(<span class="keyword">this</span>));</span><br><span class="line">        server.listen(...args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">module</span>.exports = Application;</span><br></pre></td></tr></table></figure>

<p>request.js</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// request.js   是扩展request属性</span></span><br><span class="line"><span class="keyword">let</span> url = <span class="built_in">require</span>(<span class="string">'url'</span>);</span><br><span class="line"><span class="comment">// request.js 是扩展request属性，所以这里不能像context一样用代理，可以从context的'return this[property][key];' 这行看出它值的获取是基于request的值 即当前文档</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> request = &#123; <span class="comment">// 这里对应2.server.js line20</span></span><br><span class="line">    <span class="keyword">get</span> url()&#123; <span class="comment">// 属性访问器 可以帮助我们处理复杂逻辑</span></span><br><span class="line">        <span class="comment">// console(this); // 这里谁调用它就是指谁 这里是ctx.request,所以this等价于ctx.request</span></span><br><span class="line">        <span class="comment">// return '/';</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.req.url;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="keyword">get</span> method()&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.req.method</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="keyword">get</span> path()&#123;</span><br><span class="line">        <span class="keyword">return</span> url.parse(<span class="keyword">this</span>.req.url).pathname</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">module</span>.exports = request;</span><br></pre></td></tr></table></figure>

<p>context.js</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// context.js  代理功能</span></span><br><span class="line"><span class="keyword">let</span> context = &#123; </span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//实现代理功能  这里也可以用proxy写</span></span><br><span class="line">context.__defineGetter__(<span class="string">'url'</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 这个context是我们自己创建的</span></span><br><span class="line">    <span class="comment">// let ctx = Object.create(context);</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.request.url; <span class="comment">// 谁调的this指谁，这里是2.server.jsline21,里面ctx调的，所以指的是ctx</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">module</span>.exports = context;</span><br></pre></td></tr></table></figure>

<p>现在 <code>2.server.js</code> line22又增加了一个path属性，也需要代理， 统一封装，如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// context.js</span></span><br><span class="line"><span class="keyword">let</span> context = &#123; </span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//  context.js是代理的功能</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">defineGetter</span>(<span class="params">property,key</span>)</span>&#123;</span><br><span class="line">    context.__defineGetter__(key,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="comment">// 这个context是我们自己创建的</span></span><br><span class="line">        <span class="comment">// let ctx = Object.create(context)</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>[property][key];</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line">defineGetter(<span class="string">'request'</span>,<span class="string">'url'</span>);</span><br><span class="line">defineGetter(<span class="string">'request'</span>,<span class="string">'method'</span>);</span><br><span class="line">defineGetter(<span class="string">'request'</span>,<span class="string">'path'</span>);</span><br><span class="line"><span class="comment">// 分析：给line6的context做了一个代理属性，属性key，line9真正是从request取，当前从ctx取url 其实是ctx.request的url，line9的this，谁调的就是指谁，2.server.jsline21、22是ctx调的，那就是指ctx</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = context;</span><br></pre></td></tr></table></figure>

<p>下一部分 2.server.js</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 2.server.js</span></span><br><span class="line"><span class="keyword">const</span> Koa = <span class="built_in">require</span>(<span class="string">'./koa/application'</span>);</span><br><span class="line"><span class="comment">// const Koa = require('koa');</span></span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> Koa();</span><br><span class="line"></span><br><span class="line">app.use(<span class="function"><span class="params">ctx</span> =&gt;</span> &#123; <span class="comment">// 这里修改成ctx</span></span><br><span class="line">    <span class="comment">// res.end('hello word');</span></span><br><span class="line">    <span class="comment">// 原生的写法 line17打开注释</span></span><br><span class="line">    <span class="comment">// console.log(ctx.req.url); //  / </span></span><br><span class="line">    <span class="comment">// console.log(ctx.request.req.url); //  /</span></span><br><span class="line">    <span class="comment">// //line24、25调用的是原生的、line27、28调用的是自己封装的</span></span><br><span class="line">    <span class="comment">// console.log(ctx.request.url); //  /</span></span><br><span class="line">    <span class="comment">// console.log(ctx.url);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当前的</span></span><br><span class="line">    <span class="comment">// console.log(ctx.req.url); //  / 这个req是原生的</span></span><br><span class="line">    <span class="comment">// console.log(ctx.request.req.url); //  </span></span><br><span class="line">    <span class="comment">// console.log(ctx.request.url); // 这里必须要把req放到request上，才可以在request上拿到req的属性</span></span><br><span class="line">    <span class="comment">// console.log(ctx.url);// 它的原理非常像vue ctx.url =&gt; ctx.request.url  代理</span></span><br><span class="line">    <span class="comment">// console.log(ctx.path);</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 下一部分****************</span></span><br><span class="line">    <span class="comment">// 用原生</span></span><br><span class="line">    <span class="comment">// ctx.response.body = 'hello word';</span></span><br><span class="line">    <span class="comment">// console.log(ctx.body);</span></span><br><span class="line">    <span class="comment">//或者</span></span><br><span class="line">    <span class="comment">// ctx.body = 'hello word';</span></span><br><span class="line">    <span class="comment">// console.log(ctx.response.body);</span></span><br><span class="line">    <span class="comment">// 也是一样的 </span></span><br><span class="line">    <span class="comment">// 现在用自己的写 看response.js文件</span></span><br><span class="line">    <span class="comment">// 自己的</span></span><br><span class="line">    ctx.response.body = <span class="string">'hello word'</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(ctx.body);</span><br><span class="line">    <span class="comment">// 反过来</span></span><br><span class="line">    ctx.body = <span class="string">'hello word'</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(ctx.response.body);</span><br><span class="line">&#125;)</span><br><span class="line">app.listen(<span class="number">4000</span>);</span><br></pre></td></tr></table></figure>

<p>response.js</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// response.js</span></span><br><span class="line"><span class="keyword">let</span> response = &#123;</span><br><span class="line">    _body: <span class="string">''</span>,</span><br><span class="line">    <span class="keyword">get</span> body()&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>._body;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="keyword">set</span> body(newValue)&#123;</span><br><span class="line">        <span class="keyword">this</span>._body = newValue;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">module</span>.exports = response;</span><br></pre></td></tr></table></figure>

<p>context.js</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// context.js</span></span><br><span class="line"><span class="keyword">let</span> context = &#123; </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  context.js是代理的功能</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">defineGetter</span>(<span class="params">property,key</span>)</span>&#123;</span><br><span class="line">    context.__defineGetter__(key,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>[property][key];</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line">defineGetter(<span class="string">'request'</span>,<span class="string">'url'</span>);</span><br><span class="line">defineGetter(<span class="string">'request'</span>,<span class="string">'method'</span>);</span><br><span class="line">defineGetter(<span class="string">'request'</span>,<span class="string">'path'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.server.js line33、34</span></span><br><span class="line">defineGetter(<span class="string">'response'</span>,<span class="string">'body'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.server.js line36、37</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">defineSetter</span>(<span class="params">property,key</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 这里是__defineSetter__(key,  给key即（body）设置属性的时候添加的代理</span></span><br><span class="line">    context.__defineSetter__(key,<span class="function"><span class="keyword">function</span>(<span class="params">newValue</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">this</span>[property][key] = newValue;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line">defineSetter(<span class="string">'response'</span>,<span class="string">'body'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = context;</span><br></pre></td></tr></table></figure>

<h1 id="中间件"><a href="#中间件" class="headerlink" title="中间件"></a>中间件</h1><blockquote>
<p>Koa 应用程序是一个包含一组中间件函数的对象，它是按照类似堆栈的方式组织和执行的。</p>
</blockquote>
<h2 id="next"><a href="#next" class="headerlink" title="next"></a>next</h2><p>3.helloword.js</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 3.helloword.js</span></span><br><span class="line"><span class="keyword">const</span> Koa = <span class="built_in">require</span>(<span class="string">'koa'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> Koa();</span><br><span class="line"><span class="comment">// next</span></span><br><span class="line">app.use(<span class="function">(<span class="params">ctx,next</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">    next();</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">4</span>);</span><br><span class="line">&#125;);</span><br><span class="line">app.use(<span class="function">(<span class="params">ctx,next</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line">    next();</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">5</span>);</span><br><span class="line">&#125;);</span><br><span class="line">app.use(<span class="function">(<span class="params">ctx,next</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">3</span>);</span><br><span class="line">    next();</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">6</span>);</span><br><span class="line">&#125;);</span><br><span class="line">app.listen(<span class="number">3000</span>);</span><br><span class="line"><span class="comment">// 执行结果： 1 2 3 6 5 4</span></span><br></pre></td></tr></table></figure>

<p>组合成了一个大的函数 相当于如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 3.helloword.js</span></span><br><span class="line">app.use(<span class="function">(<span class="params">ctx,next</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">    (ctx,next) =&gt; &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line">        (<span class="function">(<span class="params">ctx,next</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="number">3</span>);</span><br><span class="line">            next();</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="number">6</span>);</span><br><span class="line">        &#125;();</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="number">5</span>);</span><br><span class="line">    &#125;();</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">4</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>如图：</p>
<p><img src="https://jiafei2333.github.io/html/images/koa-middleware.png" alt></p>
<p>这个叫中间件  我可以在执行某个过程中 之前增加某些逻辑<br>中间件 use方法 它可以决定是否向下执行（调next就向下走）<br>这里可以使用async+await方法</p>
<h4 id="1】"><a href="#1】" class="headerlink" title="1】"></a>1】</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 3.helloword.js</span></span><br><span class="line"><span class="keyword">const</span> Koa = <span class="built_in">require</span>(<span class="string">'koa'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> Koa();</span><br><span class="line"><span class="keyword">const</span> logger = <span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>)=&gt;</span>&#123;</span><br><span class="line">        setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">          <span class="built_in">console</span>.log(<span class="string">'logger'</span>);  </span><br><span class="line">          resolve();</span><br><span class="line">        &#125;, <span class="number">1000</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line">app.use(<span class="keyword">async</span> (ctx,next) =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">await</span> logger();</span><br><span class="line">    next();</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">4</span>);</span><br><span class="line">&#125;);</span><br><span class="line">app.use(<span class="function">(<span class="params">ctx,next</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line">    next();</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">5</span>);</span><br><span class="line">&#125;);</span><br><span class="line">app.use(<span class="function">(<span class="params">ctx,next</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">3</span>);</span><br><span class="line">    next();</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">6</span>);</span><br><span class="line">&#125;);</span><br><span class="line">app.listen(<span class="number">3000</span>);</span><br><span class="line"><span class="comment">// 执行结果：1 过一秒打印logger 23654</span></span><br></pre></td></tr></table></figure>

<h4 id="2】"><a href="#2】" class="headerlink" title="2】"></a>2】</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 3.helloword.js</span></span><br><span class="line"><span class="keyword">const</span> Koa = <span class="built_in">require</span>(<span class="string">'koa'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> Koa();</span><br><span class="line"><span class="keyword">const</span> logger = <span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>)=&gt;</span>&#123;</span><br><span class="line">        setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">          <span class="built_in">console</span>.log(<span class="string">'logger'</span>);  </span><br><span class="line">          resolve();</span><br><span class="line">        &#125;, <span class="number">1000</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line">app.use(<span class="function">(<span class="params">ctx,next</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">    next(); <span class="comment">// 当前执行next的时候 没有等待next执行完, 但是外层的已经执行完了所以会继续执行 =&gt;4</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">4</span>);</span><br><span class="line">&#125;);</span><br><span class="line">app.use(<span class="keyword">async</span> (ctx,next) =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">await</span> logger();</span><br><span class="line">    next();</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">5</span>);</span><br><span class="line">&#125;);</span><br><span class="line">app.use(<span class="function">(<span class="params">ctx,next</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">3</span>);</span><br><span class="line">    next();</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">6</span>);</span><br><span class="line">&#125;);</span><br><span class="line">app.listen(<span class="number">3000</span>);</span><br><span class="line"><span class="comment">// 执行结果： 124 logger365</span></span><br></pre></td></tr></table></figure>

<p>分析： 1 ， line14的next() 就是line17-22</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">async (ctx,next) =&gt; &#123;</span><br><span class="line">    console.log(2);</span><br><span class="line">    await logger();</span><br><span class="line">    next();</span><br><span class="line">    console.log(5);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个方法 =&gt;2， next()没有等待执行完 所以 =&gt;4  logger =&gt;3=&gt;6=&gt;5</p>
<h4 id="3】"><a href="#3】" class="headerlink" title="3】"></a>3】</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 3.helloword.js</span></span><br><span class="line"><span class="keyword">const</span> Koa = <span class="built_in">require</span>(<span class="string">'koa'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> Koa();</span><br><span class="line"><span class="keyword">const</span> logger = <span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>)=&gt;</span>&#123;</span><br><span class="line">        setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">          <span class="built_in">console</span>.log(<span class="string">'logger'</span>);  </span><br><span class="line">          resolve();</span><br><span class="line">        &#125;, <span class="number">1000</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line">app.use(<span class="function">(<span class="params">ctx,next</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">    ctx.body = <span class="string">'hello'</span>;</span><br><span class="line">    next();</span><br><span class="line">    ctx.body = <span class="string">'hello4'</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">4</span>);</span><br><span class="line">&#125;);</span><br><span class="line">app.use(<span class="keyword">async</span> (ctx,next) =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line">    ctx.body = <span class="string">'hello1'</span>;</span><br><span class="line">    <span class="keyword">await</span> logger();</span><br><span class="line">    next();</span><br><span class="line">    ctx.body = <span class="string">'hello5'</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">5</span>);</span><br><span class="line">&#125;);</span><br><span class="line">app.use(<span class="function">(<span class="params">ctx,next</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">3</span>);</span><br><span class="line">    ctx.body = <span class="string">'hello2'</span>;</span><br><span class="line">    next();</span><br><span class="line">    ctx.body = <span class="string">'hello5'</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">6</span>);</span><br><span class="line">&#125;);</span><br><span class="line">app.listen(<span class="number">3000</span>);</span><br><span class="line"><span class="comment">// 运行 nodemon 3.helloword.js</span></span><br><span class="line"><span class="comment">// 浏览器运行 http://localhost:3000</span></span><br></pre></td></tr></table></figure>

<p>浏览器获取到服务端返回的 ‘hello4’ 因为这里line16 next()方法外层已经执行完了，所以服务器端返回</p>
<h4 id="4】"><a href="#4】" class="headerlink" title="4】"></a>4】</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 3.helloword.js</span></span><br><span class="line"><span class="keyword">const</span> Koa = <span class="built_in">require</span>(<span class="string">'koa'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> Koa();</span><br><span class="line"><span class="keyword">const</span> logger = <span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>)=&gt;</span>&#123;</span><br><span class="line">        setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">          <span class="built_in">console</span>.log(<span class="string">'logger'</span>);  </span><br><span class="line">          resolve();</span><br><span class="line">        &#125;, <span class="number">1000</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line">app.use(<span class="keyword">async</span> (ctx,next) =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">    ctx.body = <span class="string">'hello'</span>;</span><br><span class="line">    <span class="keyword">await</span> next(); <span class="comment">// ****这里加了 await</span></span><br><span class="line">    ctx.body = <span class="string">'hello4'</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">4</span>);</span><br><span class="line">&#125;);</span><br><span class="line">app.use(<span class="keyword">async</span> (ctx,next) =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line">    ctx.body = <span class="string">'hello1'</span>;</span><br><span class="line">    <span class="keyword">await</span> logger();</span><br><span class="line">    next();</span><br><span class="line">    ctx.body = <span class="string">'hello5'</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">5</span>);</span><br><span class="line">&#125;);</span><br><span class="line">app.use(<span class="function">(<span class="params">ctx,next</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">3</span>);</span><br><span class="line">    ctx.body = <span class="string">'hello2'</span>;</span><br><span class="line">    next();</span><br><span class="line">    ctx.body = <span class="string">'hello5'</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">6</span>);</span><br><span class="line">&#125;);</span><br><span class="line">app.listen(<span class="number">3000</span>);</span><br></pre></td></tr></table></figure>

<p>这样就会等待 next() 这个函数完全执行完再返回 hello4<br>执行: 浏览器会过1秒之后再返回</p>
<h4 id="5】"><a href="#5】" class="headerlink" title="5】"></a>5】</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 3.helloword.js</span></span><br><span class="line"><span class="keyword">const</span> Koa = <span class="built_in">require</span>(<span class="string">'koa'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> Koa();</span><br><span class="line"><span class="keyword">const</span> logger = <span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>)=&gt;</span>&#123;</span><br><span class="line">        setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">          <span class="built_in">console</span>.log(<span class="string">'logger'</span>);  </span><br><span class="line">          resolve();</span><br><span class="line">        &#125;, <span class="number">1000</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line">app.use(<span class="keyword">async</span> (ctx,next) =&gt; &#123;</span><br><span class="line">    ctx.body = <span class="string">'hello'</span>;</span><br><span class="line">    <span class="comment">// await next();</span></span><br><span class="line">    <span class="keyword">return</span> next(); <span class="comment">// 也可以这样写 这里next()返回一个promise, 会等待promise执行完，和await的区别是await后面还是执行代码，return不行</span></span><br><span class="line">    <span class="comment">// 如果上面是写的await  这里还可以有其他的todo...</span></span><br><span class="line">&#125;);</span><br><span class="line">app.use(<span class="keyword">async</span> (ctx,next) =&gt; &#123;</span><br><span class="line">    <span class="keyword">await</span> logger();</span><br><span class="line">    <span class="comment">// ctx.body = '500';</span></span><br><span class="line">    <span class="keyword">return</span> next(); <span class="comment">// 这里如上 也可以用return</span></span><br><span class="line">&#125;);</span><br><span class="line">app.use(<span class="keyword">async</span> (ctx,next) =&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> next();  <span class="comment">// 这里是最后一个next()前面可以不用加，但是不一定是最后一个，所以都加上</span></span><br><span class="line">&#125;);</span><br><span class="line">app.listen(<span class="number">3000</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 现在上面的方法是等所有都执行完再返回  所以当line21注释打开的话，服务端返回的是500</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>在使用koas时如果遇到next 前面就可以加 return 或者await<br>koa里面有个compose方法 会将所有方法组合成一个大的promise 如果没有加如上的return 或者async await 代码可能没有执行完就返回了</p>
</blockquote>
<h4 id="6】"><a href="#6】" class="headerlink" title="6】"></a>6】</h4><p>计算执行的时间</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 3.helloword.js</span></span><br><span class="line"><span class="keyword">const</span> Koa = <span class="built_in">require</span>(<span class="string">'koa'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> Koa();</span><br><span class="line"><span class="keyword">const</span> logger = <span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>)=&gt;</span>&#123;</span><br><span class="line">        setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">          <span class="built_in">console</span>.log(<span class="string">'logger'</span>);  </span><br><span class="line">          resolve();</span><br><span class="line">        &#125;, <span class="number">1000</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line">app.use(<span class="keyword">async</span> (ctx,next) =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.time(<span class="string">'start'</span>); <span class="comment">// *** </span></span><br><span class="line">    ctx.body = <span class="string">'hello'</span>;</span><br><span class="line">    <span class="keyword">await</span> next(); </span><br><span class="line">    <span class="built_in">console</span>.timeEnd(<span class="string">'start'</span>); <span class="comment">// ***</span></span><br><span class="line">&#125;);</span><br><span class="line">app.use(<span class="keyword">async</span> (ctx,next) =&gt; &#123;</span><br><span class="line">    <span class="keyword">await</span> logger();</span><br><span class="line">    <span class="keyword">return</span> next();</span><br><span class="line">&#125;);</span><br><span class="line">app.use(<span class="keyword">async</span> (ctx,next) =&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> next();</span><br><span class="line">&#125;);</span><br><span class="line">app.listen(<span class="number">3000</span>);</span><br><span class="line"><span class="comment">// 执行 可以看到命令行打印出时间  start: 1007.369ms</span></span><br></pre></td></tr></table></figure>

<h2 id="完善"><a href="#完善" class="headerlink" title="完善"></a>完善</h2><p>现在看 ./koa/application   方法整合<br>手写compose方法</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 4.helloword.js  引入自己的application.js</span></span><br><span class="line"><span class="keyword">const</span> Koa = <span class="built_in">require</span>(<span class="string">'./koa/application'</span>);</span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> Koa();</span><br><span class="line"><span class="keyword">const</span> logger = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"logger"</span>);</span><br><span class="line">        resolve();</span><br><span class="line">      &#125;, <span class="number">1000</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;;</span><br><span class="line">app.use(<span class="keyword">async</span> (ctx, next) =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">await</span> next();</span><br><span class="line">&#125;);</span><br><span class="line">app.use(<span class="keyword">async</span> (ctx, next) =&gt; &#123;</span><br><span class="line">    <span class="comment">// 上下文</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">await</span> logger();</span><br><span class="line">    <span class="keyword">return</span> next();</span><br><span class="line">&#125;);</span><br><span class="line">app.use(<span class="keyword">async</span> (ctx, next) =&gt; &#123;</span><br><span class="line"><span class="comment">// 上下文</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">3</span>);</span><br><span class="line">    <span class="keyword">await</span> next();</span><br><span class="line">    <span class="comment">// 如果返回的是个文件</span></span><br><span class="line">    ctx.body = fs.createReadStream(<span class="string">'2.server.js'</span>);</span><br><span class="line">    <span class="comment">// 如果返回的是个对象</span></span><br><span class="line">    ctx.body = &#123;<span class="attr">name</span>: <span class="string">'jf'</span>&#125;;</span><br><span class="line">&#125;);</span><br><span class="line">app.on(<span class="string">'error'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123; <span class="comment">// 当任何一个中间件出错的时候都能捕获</span></span><br><span class="line">	<span class="built_in">console</span>.log(err);</span><br><span class="line">&#125;)</span><br><span class="line">app.listen(<span class="number">3000</span>);</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// application.js</span></span><br><span class="line"><span class="keyword">let</span> context = <span class="built_in">require</span>(<span class="string">'./context'</span>);</span><br><span class="line"><span class="keyword">let</span> request = <span class="built_in">require</span>(<span class="string">'./request'</span>);</span><br><span class="line"><span class="keyword">let</span> response = <span class="built_in">require</span>(<span class="string">'./response'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line"><span class="keyword">const</span> Events = <span class="built_in">require</span>(<span class="string">'events'</span>);</span><br><span class="line"><span class="keyword">const</span> Stream = <span class="built_in">require</span>(<span class="string">'stream'</span>);</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Application</span> <span class="keyword">extends</span> <span class="title">Events</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>()&#123;</span><br><span class="line">		<span class="keyword">super</span>(); <span class="comment">// ***这个不要忘记了</span></span><br><span class="line">        <span class="keyword">this</span>.context = context;</span><br><span class="line">        <span class="keyword">this</span>.request = request;</span><br><span class="line">        <span class="keyword">this</span>.response = response;</span><br><span class="line">        <span class="keyword">this</span>.middleware = [];</span><br><span class="line">    &#125;</span><br><span class="line">    use(fn)&#123;</span><br><span class="line">        <span class="comment">// this.fn = fn;</span></span><br><span class="line">        <span class="keyword">this</span>.middleware.push(fn);</span><br><span class="line">    &#125;</span><br><span class="line">    createContext(req, res)&#123;</span><br><span class="line">        <span class="keyword">let</span> context = <span class="built_in">Object</span>.create(<span class="keyword">this</span>.context);</span><br><span class="line">        context.request = <span class="built_in">Object</span>.create(<span class="keyword">this</span>.request);</span><br><span class="line">        context.response = <span class="built_in">Object</span>.create(<span class="keyword">this</span>.response);</span><br><span class="line">        context.req = context.request.req = req;</span><br><span class="line">        context.res = context.response.res = res;</span><br><span class="line">        <span class="keyword">return</span> context;</span><br><span class="line">    &#125;</span><br><span class="line">    compose(ctx)&#123; <span class="comment">// 返回的是个promise   这里看下源码 koa/lib/application</span></span><br><span class="line">        <span class="comment">// [fn, fn, fn]</span></span><br><span class="line">        <span class="keyword">let</span> dispatch = <span class="function">(<span class="params">index</span>) =&gt;</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(index === <span class="keyword">this</span>.middleware.length) <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve();</span><br><span class="line">            <span class="keyword">let</span> middle = <span class="keyword">this</span>.middleware[index];</span><br><span class="line">            <span class="comment">// 拿出第一个中间件让其执行，执行的时候传递ctx，next方法，有可能这个方法是个普通函数，那么就把他变成一个promise</span></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve(middle(ctx, ()=&gt;dispatch(index+<span class="number">1</span>)));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dispatch(<span class="number">0</span>);</span><br><span class="line">        <span class="comment">// 这里写完之后 新建4.helloword.js 引入当前文件验证  1 2 logger 3</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    handleRequest(req, res)&#123;</span><br><span class="line">        <span class="keyword">let</span> ctx = <span class="keyword">this</span>.createContext(req, res);</span><br><span class="line">        <span class="comment">// this.fn(ctx);</span></span><br><span class="line">        <span class="keyword">this</span>.compose(ctx).then(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">            <span class="keyword">let</span> _body = ctx.body;</span><br><span class="line">            <span class="keyword">if</span>(_body <span class="keyword">instanceof</span> Stream)&#123;</span><br><span class="line">                <span class="keyword">return</span> _body.pipe(res);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="keyword">typeof</span> _body === <span class="string">'object'</span>)&#123; <span class="comment">//如果是对象 </span></span><br><span class="line">                <span class="keyword">return</span> res.end(<span class="built_in">JSON</span>.stringify(_body));</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123; <span class="comment">// 普通字符串</span></span><br><span class="line">                <span class="keyword">return</span> res.end(_body);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).catch(<span class="function"><span class="params">err</span>=&gt;</span>&#123; <span class="comment">// 这里捕获错误 触发 `4.helloword.js`</span></span><br><span class="line">            <span class="comment">// 继承events</span></span><br><span class="line">            <span class="keyword">this</span>.emit(<span class="string">'error'</span>,err);</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    listen(...args)&#123;</span><br><span class="line">        <span class="keyword">let</span> server = http.createServer(<span class="keyword">this</span>.handleRequest.bind(<span class="keyword">this</span>));</span><br><span class="line">        server.listen(...args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">module</span>.exports = Application;</span><br><span class="line"><span class="comment">// 1) compose方法 如何用async+await来重写</span></span><br><span class="line"><span class="comment">// 2) compose next方法如何 避免多次调用（连着写多个next()）</span></span><br><span class="line"><span class="comment">// 3) ctx.body 没有赋值 如何处理</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Nodejs</category>
      </categories>
      <tags>
        <tag>Nodejs</tag>
        <tag>Koa</tag>
        <tag>中间件</tag>
      </tags>
  </entry>
  <entry>
    <title>MongoDB</title>
    <url>/2019/10/09/MongoDB/</url>
    <content><![CDATA[<h1 id="MongoDB"><a href="#MongoDB" class="headerlink" title="MongoDB"></a>MongoDB</h1><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><h3 id="windows"><a href="#windows" class="headerlink" title="windows"></a>windows</h3><ul>
<li>mongodb 64位绿色版 链接: <a href="https://pan.baidu.com/s/1lhoXDNTqB48tX0d8RowimQ" target="_blank" rel="noopener">https://pan.baidu.com/s/1lhoXDNTqB48tX0d8RowimQ</a> 提取码: dk5w</li>
<li>mongodb 32位安装版 链接: <a href="https://pan.baidu.com/s/1dfejjDrZnMzXL_NPa6W1fw" target="_blank" rel="noopener">https://pan.baidu.com/s/1dfejjDrZnMzXL_NPa6W1fw</a> 提取码: wy6s</li>
<li>可视化工具 <a href="https://robomongo.org/" target="_blank" rel="noopener">Robomongo</a> 链接： <a href="https://download-test.robomongo.org/windows/robo3t-1.3.1-windows-x86_64-7419c406.zip" target="_blank" rel="noopener">https://download-test.robomongo.org/windows/robo3t-1.3.1-windows-x86_64-7419c406.zip</a></li>
</ul>
<a id="more"></a>

<h3 id="mac"><a href="#mac" class="headerlink" title="mac"></a>mac</h3><ul>
<li>直接 brew install mongodb 安装时报这个错  Error: mongodb: unknown version :mountain_lion</li>
</ul>
<p>可以如下操作：</p>
<ul>
<li>brew uninstall mongodb</li>
<li>brew tap mongodb/brew</li>
<li>brew install mongodb-community</li>
</ul>
<p><img src="https://jiafei2333.github.io/html/images/mongodb-1.png" alt></p>
<h2 id="启动与连接"><a href="#启动与连接" class="headerlink" title="启动与连接"></a>启动与连接</h2><h3 id="windows（以64位为例）"><a href="#windows（以64位为例）" class="headerlink" title="windows（以64位为例）"></a>windows（以64位为例）</h3><ul>
<li><p>将mondodb 64位绿色版下载，放到D盘/mongodb（自定义）下 </p>
</li>
<li><p>找到mongodb安装目录 D:\mongodb\MongoDB\bin (mongod.exe 服务端、mongo.exe 客户端)</p>
</li>
<li><p>在当前文件夹下打开命令行 输入 mongod（这个代表启动当前的mongod.exe），完整如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// ./data 表示数据存在data下</span><br><span class="line">mongod --dbpath=./data</span><br></pre></td></tr></table></figure>
</li>
<li><p>命令行最后  waiting for connections on port 27017 证明服务器启动成功</p>
</li>
<li><p>新开一个命令行 （客户端窗口）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mongo</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>连接成功，如下图：<br><img src="https://jiafei2333.github.io/html/images/mongodb-2.png" alt></p>
<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><ul>
<li>数据库 MongoDB的单个实例可以容纳多个独立的数据库，比如一个学生管理系统就可以对应一个数据库实例</li>
<li>集合 数据库是由集合组成的,一个集合用来表示一个实体,如学生集合</li>
<li>文档 集合是由文档组成的，一个文档表示一条记录,比如一位同学张三就是一个文档<br><img src="https://jiafei2333.github.io/html/images/mongodb-3.png" alt></li>
</ul>
<h2 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h2><p><img src="https://jiafei2333.github.io/html/images/mongodb-4.png" alt></p>
<h2 id="Mongoose"><a href="#Mongoose" class="headerlink" title="Mongoose"></a>Mongoose</h2><h3 id="基本概念-1"><a href="#基本概念-1" class="headerlink" title="基本概念"></a>基本概念</h3><ul>
<li>Mongoose是MongoDB的一个对象模型工具</li>
<li>同时它也是针对MongoDB操作的一个对象模型库,封装了MongoDB对文档的的一些增删改查等常用方法</li>
<li>让NodeJS操作Mongodb数据库变得更加灵活简单</li>
<li>Mongoose因为封装了MongoDB对文档操作的常用方法，可以高效处理mongodb,还提供了类似Schema的功能，如hook、plugin、virtual、populate等机制。</li>
<li>官网 <a href="https://mongoosejs.com/" target="_blank" rel="noopener">mongoosejs</a></li>
</ul>
<h3 id="使用mongoose"><a href="#使用mongoose" class="headerlink" title="使用mongoose"></a>使用mongoose</h3><h4 id="安装mongoose"><a href="#安装mongoose" class="headerlink" title="安装mongoose"></a>安装mongoose</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install mongoose</span><br></pre></td></tr></table></figure>

<h4 id="使用mongoose-1"><a href="#使用mongoose-1" class="headerlink" title="使用mongoose"></a>使用mongoose</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// connection.js</span></span><br><span class="line"><span class="comment">//引入mongoose模块</span></span><br><span class="line"><span class="keyword">let</span> mongoose = <span class="built_in">require</span>(<span class="string">'mongoose'</span>);</span><br><span class="line"><span class="comment">//创建对数据库的连接</span></span><br><span class="line"><span class="keyword">let</span> conn = mongoose.createConnection(</span><br><span class="line">    <span class="string">'mongodb://127.0.0.1:27017/cms'</span>,</span><br><span class="line">    &#123;</span><br><span class="line">        useNewUrlParser: <span class="literal">true</span>, <span class="comment">//使用新的url解析器</span></span><br><span class="line">        useUnifiedTopology: <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">);</span><br><span class="line">conn.on(<span class="string">'open'</span>,()=&gt;&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'当mongoose成功连接数据库之后会打印这个日志'</span>)</span><br><span class="line">&#125;);</span><br><span class="line">conn.on(<span class="string">'error'</span>,(error)=&gt;&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'如果说连接失败了，会把失败的原因传递给'</span>,error)</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">module</span>.exports = conn;</span><br></pre></td></tr></table></figure>

<p>运行： node connection.js， 连接成功</p>
<h4 id="使用客户端-Robo-3T"><a href="#使用客户端-Robo-3T" class="headerlink" title="使用客户端 Robo 3T"></a>使用客户端 Robo 3T</h4><p>新建 连接<br><img src="https://jiafei2333.github.io/html/images/mongodb-5.png" alt></p>
<h4 id="Schema"><a href="#Schema" class="headerlink" title="Schema"></a>Schema</h4><ul>
<li>Schema是数据库集合的模型骨架</li>
<li>定义了集合中的字段的名称和类型以及默认值等信息</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义schema</span></span><br><span class="line"><span class="keyword">var</span> personSchema = <span class="keyword">new</span> Schema(&#123;</span><br><span class="line">      name:<span class="built_in">String</span>, <span class="comment">//姓名</span></span><br><span class="line">      binary:Buffer,<span class="comment">//二进制</span></span><br><span class="line">      living:<span class="built_in">Boolean</span>,<span class="comment">//是否活着</span></span><br><span class="line">      birthday:<span class="built_in">Date</span>,<span class="comment">//生日</span></span><br><span class="line">      age:<span class="built_in">Number</span>,<span class="comment">//年龄</span></span><br><span class="line">      _id:Schema.Types.ObjectId,  <span class="comment">//主键</span></span><br><span class="line">      _fk:Schema.Types.ObjectId,  <span class="comment">//外键</span></span><br><span class="line">      array:[],<span class="comment">//数组</span></span><br><span class="line">      arrOfString:[<span class="built_in">String</span>],<span class="comment">//字符串数组</span></span><br><span class="line">      arrOfNumber:[<span class="built_in">Number</span>],<span class="comment">//数字数组</span></span><br><span class="line">      arrOfDate:[<span class="built_in">Date</span>],<span class="comment">//日期数组</span></span><br><span class="line">      arrOfBuffer:[Buffer],<span class="comment">//Buffer数组</span></span><br><span class="line">      arrOfBoolean:[<span class="built_in">Boolean</span>],<span class="comment">//布尔值数组</span></span><br><span class="line">      arrOfObjectId:[Schema.Types.ObjectId]<span class="comment">//对象ID数组</span></span><br><span class="line">      nested:&#123; <span class="attr">name</span>:<span class="built_in">String</span>&#125; <span class="comment">//内嵌文档</span></span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> p = <span class="keyword">new</span> Person();</span><br><span class="line">    p.name= <span class="string">'zfpx'</span>;</span><br><span class="line">    p.age = <span class="number">25</span>;</span><br><span class="line">    p.birthday = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">    p.married = <span class="literal">false</span>;</span><br><span class="line">    p.mixed= &#123;<span class="attr">any</span>:&#123;<span class="attr">other</span>:<span class="string">'other'</span>&#125;&#125;;</span><br><span class="line">    p._otherId = <span class="keyword">new</span> mongoose.Types.ObjectId;</span><br><span class="line">    p.hobby.push(<span class="string">'smoking'</span>);</span><br><span class="line">    p.ofString.push(<span class="string">'string'</span>);</span><br><span class="line">    p.ofNumber.pop(<span class="number">3</span>);</span><br><span class="line">    p.ofDates.addToSet(<span class="keyword">new</span> <span class="built_in">Date</span>);</span><br><span class="line">    p.ofBuffer.pop();</span><br><span class="line">    p.ofMixed = [<span class="string">'anything'</span>,<span class="number">3</span>,&#123;<span class="attr">name</span>:<span class="string">'zfpx'</span>&#125;];</span><br><span class="line">    p.nested.name = <span class="string">'zfpx'</span>;</span><br></pre></td></tr></table></figure>

<h5 id="使用schema"><a href="#使用schema" class="headerlink" title="使用schema"></a>使用schema</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> mongoose = <span class="built_in">require</span>(<span class="string">'mongoose'</span>);</span><br><span class="line"><span class="keyword">let</span> connection = <span class="built_in">require</span>(<span class="string">'./connection'</span>);</span><br><span class="line"><span class="comment">//定义Schema 对应的是集合,或者说是集合中的文档</span></span><br><span class="line"><span class="keyword">let</span> UserSchema = <span class="keyword">new</span> mongoose.Schema(&#123;</span><br><span class="line">    name:<span class="built_in">String</span>,</span><br><span class="line">    age:<span class="built_in">Number</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//Schema是与数据无关的，并不能直接操作数据库</span></span><br></pre></td></tr></table></figure>

<h4 id="Model"><a href="#Model" class="headerlink" title="Model"></a>Model</h4><p>Model是由通过Schema构造而成 除了具有Schema定义的数据库骨架以外，还可以操作数据库 如何通过Schema来创建Model呢，如下:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> mongoose = <span class="built_in">require</span>(<span class="string">'mongoose'</span>);</span><br><span class="line"><span class="keyword">let</span> connection = <span class="built_in">require</span>(<span class="string">'./connection'</span>);</span><br><span class="line"><span class="keyword">let</span> UserSchema = <span class="keyword">new</span> mongoose.Schema(&#123;</span><br><span class="line">    name:<span class="built_in">String</span>,</span><br><span class="line">    age:<span class="built_in">Number</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//Model 模型 User是模型 的名字，以后可以通过这个名字来引用这个模型 </span></span><br><span class="line"><span class="comment">//传二个参数表示定义模型 ，传一个参数表示引用或者说获取 这个模型   xxx.val('yyy')</span></span><br><span class="line"><span class="comment">//默认情况下，集合的名字是由Model的名字决定的  User-&gt;小写user-&gt;复数users</span></span><br><span class="line"><span class="keyword">let</span> UserModel = connection.model(<span class="string">'User'</span>,UserSchema);</span><br><span class="line"><span class="keyword">let</span> UserModel2 = connection.model(<span class="string">'User'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(UserModel === UserModel2); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 自己定义集合的名字</span></span><br><span class="line"><span class="keyword">let</span> UserSchema = <span class="keyword">new</span> mongoose.Schema(&#123;</span><br><span class="line">    name:<span class="built_in">String</span>,</span><br><span class="line">    age:<span class="built_in">Number</span></span><br><span class="line">&#125;,&#123;<span class="attr">collection</span>:<span class="string">'user'</span>&#125;); <span class="comment">//这样就会创建一个user的集合</span></span><br></pre></td></tr></table></figure>

<p><img src="https://jiafei2333.github.io/html/images/mongodb-6.png" alt></p>
<p>通过模型往数据库里面写数据</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> mongoose = <span class="built_in">require</span>(<span class="string">'mongoose'</span>);</span><br><span class="line"><span class="keyword">let</span> connection = <span class="built_in">require</span>(<span class="string">'./connection'</span>);</span><br><span class="line"><span class="keyword">let</span> UserSchema = <span class="keyword">new</span> mongoose.Schema(&#123;</span><br><span class="line">    name:<span class="built_in">String</span>,</span><br><span class="line">    age:<span class="built_in">Number</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">let</span> UserModel = connection.model(<span class="string">'User'</span>,UserSchema);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 插入数据</span></span><br><span class="line">UserModel.create(&#123;<span class="attr">name</span>:<span class="string">'jf1'</span>,<span class="attr">age</span>:<span class="number">10</span>&#125;,(err,doc)=&gt;&#123;</span><br><span class="line">  <span class="comment">//err是错误对象 doc是保存成功后的文档对象</span></span><br><span class="line">  <span class="built_in">console</span>.log(err);</span><br><span class="line">  <span class="built_in">console</span>.log(doc);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// create方法返回的是promise，所以也可以用then</span></span><br><span class="line">UserModel.create(&#123;<span class="attr">name</span>:<span class="string">'jf'</span>,<span class="attr">age</span>:<span class="number">10</span>&#125;).then(<span class="function"><span class="params">result</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(result);</span><br><span class="line">&#125;,error=&gt;&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(error);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h4 id="Entity简述"><a href="#Entity简述" class="headerlink" title="Entity简述"></a>Entity简述</h4><ul>
<li>通过Model创建的实体，它也可以操作数据库</li>
<li>使用Model创建Entity，如下示例：</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"> <span class="comment">// 一个实体就代表一个文档对象</span></span><br><span class="line"> <span class="keyword">let</span> user1 = <span class="keyword">new</span> UserModel(&#123;</span><br><span class="line">     name:<span class="string">'jf1'</span>,</span><br><span class="line">     age:<span class="number">10</span></span><br><span class="line"> &#125;);</span><br><span class="line"><span class="comment">// 保存到数据库 它也返回promise</span></span><br><span class="line">user1.save().then(<span class="function"><span class="params">doc</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(doc);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>模型是一个总的概念，它代表整个集合，操作对象是整个集合<br> 实体是一个单个的概念，它代表单个文档。只能操作自己</p>
</blockquote>
<h4 id="ObjectId"><a href="#ObjectId" class="headerlink" title="ObjectId"></a>ObjectId</h4><ul>
<li>存储在mongodb集合中的每个文档都有一个默认的主键_id</li>
<li>这个主键名称是固定的，它可以是mongodb支持的任何数据类型，默认是ObjectId 该类型的值由系统自己生成，从某种意义上几乎不会重复</li>
<li>ObjectId使用12字节的存储空间，是一个由24个16进制数字组成的字符串（每个字节可以存储两个16进制数字）</li>
</ul>
<p><code>5d9c8817a62ce21e04dc4e57</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> _id = <span class="string">'5d9c8817 a62ce2 1e04 dc4e57'</span>;</span><br><span class="line"><span class="keyword">let</span> ts = <span class="string">'5d9c8817'</span>; <span class="comment">// 时间戳</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">parseInt</span>(ts,<span class="string">'16'</span>)); <span class="comment">// 1570539543</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">new</span> <span class="built_in">Date</span>(<span class="built_in">parseInt</span>(ts,<span class="string">'16'</span>)*<span class="number">1000</span>)); <span class="comment">// 2019-10-08T12:59:03.000Z</span></span><br><span class="line"><span class="keyword">let</span> host = <span class="string">'a62ce2'</span>;<span class="comment">//表示当前主机 一般是主机名hash值</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> pid = <span class="string">'1e04'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">parseInt</span>(pid,<span class="string">'16'</span>));<span class="comment">//7684 十进制数 代表当前的进程ID</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> seq = <span class="string">'dc4e57'</span>; <span class="comment">// 由一个随机数开始的计数器生成的值</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">parseInt</span>(seq,<span class="string">'16'</span>));<span class="comment">//14437975</span></span><br></pre></td></tr></table></figure>

<h4 id="基本操作-1"><a href="#基本操作-1" class="headerlink" title="基本操作"></a>基本操作</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> mongoose = <span class="built_in">require</span>(<span class="string">'mongoose'</span>);</span><br><span class="line"><span class="keyword">let</span> connection = <span class="built_in">require</span>(<span class="string">'./connection'</span>);</span><br><span class="line"><span class="comment">//定义Schema 对应的是集合,或者说是集合中的文档</span></span><br><span class="line"><span class="keyword">let</span> UserSchema = <span class="keyword">new</span> mongoose.Schema(&#123;</span><br><span class="line">    name:<span class="built_in">String</span>,</span><br><span class="line">    age:<span class="built_in">Number</span></span><br><span class="line">&#125;,&#123;<span class="attr">collection</span>:<span class="string">'user'</span>&#125;); <span class="comment">// user集合</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> UserModel = connection.model(<span class="string">'User'</span>,UserSchema);</span><br><span class="line">(<span class="keyword">async</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="comment">// 添加</span></span><br><span class="line">    <span class="keyword">let</span> result = <span class="keyword">await</span> UserModel.create(&#123;<span class="attr">name</span>:<span class="string">'jf'</span>,<span class="attr">age</span>:<span class="number">10</span>&#125;);</span><br><span class="line">	<span class="comment">// 查询全部</span></span><br><span class="line">    <span class="keyword">let</span> docs = <span class="keyword">await</span> UserModel.find();</span><br><span class="line">	<span class="comment">// 查询条件 name=jf</span></span><br><span class="line">	<span class="comment">// let docs = await UserModel.find(&#123;name:'jf'&#125;);</span></span><br><span class="line">    <span class="built_in">console</span>.log(result); <span class="comment">//  &#123; _id: 5d9ed2ab55d44e2c5cffe99f, name: 'jf', age: 10, __v: 0 &#125;</span></span><br><span class="line">	<span class="built_in">console</span>.log(docs); <span class="comment">// [&#123;&#125;,&#123;&#125;...]</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 更新 </span></span><br><span class="line">	<span class="comment">// 第1个参数是条件 第2个参数是更新后的值</span></span><br><span class="line">    <span class="comment">// updateOne 如果找到了多条匹配记录，则只更新第一条</span></span><br><span class="line">    <span class="comment">// updateMany 如果找到了多条记录，则更新所有匹配的记录</span></span><br><span class="line">    <span class="keyword">let</span> result = <span class="keyword">await</span> UserModel.updateMany(&#123;<span class="attr">name</span>:<span class="string">'jf'</span>&#125;,&#123;<span class="attr">age</span>:<span class="number">20</span>&#125;);</span><br><span class="line">    <span class="comment">// n表示匹配的条件 nModified表示实际发生更新操作的条数</span></span><br><span class="line">    <span class="built_in">console</span>.log(result);<span class="comment">//&#123; ok: 1, nModified: 0, n: 1 &#125;</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 删除</span></span><br><span class="line">	<span class="comment">// deleteOne 删除第一条，后面不再匹配了，更不会删除了</span></span><br><span class="line">	<span class="comment">// deleteMany 删除所有的匹配的条数</span></span><br><span class="line">	<span class="keyword">let</span> result = <span class="keyword">await</span> UserModel.deleteMany(&#123;<span class="attr">name</span>:<span class="string">'jf'</span>&#125;);</span><br><span class="line">	<span class="built_in">console</span>.log(result); <span class="comment">// &#123; n: 4, ok: 1, deletedCount: 4 &#125;</span></span><br><span class="line">	process.exit(<span class="number">0</span>); <span class="comment">// 退出</span></span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>

<h5 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> mongoose = <span class="built_in">require</span>(<span class="string">'mongoose'</span>);</span><br><span class="line"><span class="keyword">let</span> connection = <span class="built_in">require</span>(<span class="string">'./connection'</span>);</span><br><span class="line"><span class="comment">//定义Schema 对应的是集合,或者说是集合中的文档</span></span><br><span class="line"><span class="keyword">let</span> UserSchema = <span class="keyword">new</span> mongoose.Schema(&#123;</span><br><span class="line">    name:<span class="built_in">String</span>,</span><br><span class="line">    age:<span class="built_in">Number</span></span><br><span class="line">&#125;,&#123;<span class="attr">collection</span>:<span class="string">'user'</span>&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> UserModel = connection.model(<span class="string">'User'</span>,UserSchema);</span><br><span class="line">(<span class="keyword">async</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"> 	<span class="comment">// 首先插入数据</span></span><br><span class="line">	 <span class="keyword">let</span> users = [];</span><br><span class="line">	 <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++)&#123;</span><br><span class="line">		users.push(&#123;<span class="attr">name</span>:<span class="string">`jf<span class="subst">$&#123;i&#125;</span>`</span>, <span class="attr">age</span>: i&#125;);</span><br><span class="line">	 &#125;</span><br><span class="line">	 <span class="keyword">await</span> UserModel.create(users);</span><br><span class="line"></span><br><span class="line">	 <span class="comment">//按属性过滤</span></span><br><span class="line">	 <span class="keyword">let</span> docs = <span class="keyword">await</span> UserModel.find(&#123;<span class="attr">name</span>:<span class="string">'jf'</span>&#125;);</span><br><span class="line">	 <span class="built_in">console</span>.log(docs);</span><br><span class="line"></span><br><span class="line">	 <span class="comment">//查找一条</span></span><br><span class="line">	 <span class="keyword">let</span> docs = <span class="keyword">await</span> UserModel.findOne(&#123;&#125;);</span><br><span class="line">	 <span class="built_in">console</span>.log(docs);</span><br><span class="line"></span><br><span class="line">	 <span class="comment">//findById</span></span><br><span class="line">	 <span class="keyword">let</span> doc = <span class="keyword">await</span> UserModel.findById(<span class="string">"5d9ed808eff86c33200fdbb7"</span>);</span><br><span class="line">	 <span class="built_in">console</span>.log(doc);</span><br><span class="line"></span><br><span class="line">	 <span class="comment">// 大于 gt greater than小于 lt less than 大于等于 ge greater equal 小于等于 le  less equal 不等于 ne not equal</span></span><br><span class="line">	 <span class="keyword">let</span> docs = <span class="keyword">await</span> UserModel.find(&#123;<span class="string">"age"</span>:&#123;<span class="string">"$ne"</span>:<span class="number">5</span>&#125;&#125;);</span><br><span class="line">	 <span class="built_in">console</span>.log(docs);</span><br><span class="line"></span><br><span class="line">	docs = <span class="keyword">await</span> UserModel.find(&#123;<span class="string">"age"</span>:&#123;<span class="string">"$in"</span>:[<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>]&#125;&#125;);</span><br><span class="line">	 <span class="built_in">console</span>.log(docs);</span><br><span class="line"></span><br><span class="line">	 <span class="comment">//大于7或者 小于3</span></span><br><span class="line">	 <span class="comment">//docs = await UserModel.find(&#123;'$or':[&#123;name:'zhufeng1'&#125;,&#123;age:5&#125;]&#125;);</span></span><br><span class="line">	 docs = <span class="keyword">await</span> UserModel.find(&#123;<span class="string">"$or"</span>:[&#123;<span class="attr">age</span>:&#123;<span class="attr">$lt</span>:<span class="number">3</span>&#125;&#125;,&#123;<span class="attr">age</span>:&#123;<span class="attr">$gt</span>:<span class="number">7</span>&#125;&#125;]&#125;);</span><br><span class="line">	 <span class="built_in">console</span>.log(docs);</span><br><span class="line"></span><br><span class="line">	 <span class="comment">//每页3条，查询第2页 1 2 3 4 5 6 7 8 9 10</span></span><br><span class="line">	 <span class="keyword">let</span> pageSize = <span class="number">3</span>;</span><br><span class="line">	 <span class="keyword">let</span> pageNumber =<span class="number">2</span>; </span><br><span class="line">	 <span class="comment">//sort指定排序的字段和升序还是降序 1 升序   -1 降序</span></span><br><span class="line">	 <span class="comment">//skip指定跳过几条，忽略 掉几条</span></span><br><span class="line">	 <span class="comment">//limit限定返回的最大条数</span></span><br><span class="line">	 <span class="comment">// exec() 执行</span></span><br><span class="line">	 <span class="keyword">let</span> docs = <span class="keyword">await</span> UserModel.find(&#123;&#125;).sort(&#123;<span class="attr">age</span>:<span class="number">1</span>&#125;).skip((pageNumber<span class="number">-1</span>)*pageSize).limit(pageSize).exec();</span><br><span class="line">	 <span class="built_in">console</span>.log(docs);<span class="comment">//4 5 6</span></span><br><span class="line">	 process.exit(<span class="number">0</span>);</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>

<h5 id="populate"><a href="#populate" class="headerlink" title="populate"></a>populate</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> mongoose = <span class="built_in">require</span>(<span class="string">'mongoose'</span>);</span><br><span class="line"><span class="keyword">let</span> connection = <span class="built_in">require</span>(<span class="string">'./connection'</span>);</span><br><span class="line"><span class="keyword">let</span> UserSchema = <span class="keyword">new</span> mongoose.Schema(&#123;</span><br><span class="line">    name:<span class="built_in">String</span>,</span><br><span class="line">    age:<span class="built_in">Number</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">let</span> User = connection.model(<span class="string">'User'</span>,UserSchema);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> ScoreSchema = <span class="keyword">new</span> mongoose.Schema(&#123;</span><br><span class="line">    <span class="comment">//uid是一个外键，类型是ObjectId类型，引用的是User模型   nosql 不是sql  not only sql</span></span><br><span class="line">    uid:&#123;<span class="attr">type</span>:mongoose.Schema.Types.ObjectId,<span class="attr">ref</span>:<span class="string">'User'</span>&#125;,</span><br><span class="line">    grade:<span class="built_in">Number</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">let</span> Score = connection.model(<span class="string">'Score'</span>,ScoreSchema);</span><br><span class="line"></span><br><span class="line">(<span class="keyword">async</span> <span class="function"><span class="keyword">function</span>(<span class="params">scoreId</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">let</span> user = <span class="keyword">await</span>  User.create(&#123;<span class="attr">name</span>:<span class="string">'jf'</span>&#125;);<span class="comment">//先创建主表</span></span><br><span class="line">  <span class="built_in">console</span>.log(user); <span class="comment">// &#123; _id: 5d9edda206d5b83260cd0564, name: 'jf', __v: 0 &#125;</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">let</span> score = <span class="keyword">await</span> Score.create(&#123;<span class="attr">uid</span>:user._id,<span class="attr">grade</span>:<span class="number">100</span>&#125;);</span><br><span class="line">  <span class="built_in">console</span>.log(score); <span class="comment">// &#123; _id: 5d9edda306d5b83260cd0565, uid: 5d9edda206d5b83260cd0564, grade: 100, __v: 0 &#125;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 通过scores集合中的_id, 拿到对应的外键uid，再通过uid拿到集合users中的name</span></span><br><span class="line">  <span class="keyword">let</span> score = <span class="keyword">await</span> Score.findById(scoreId);</span><br><span class="line">  <span class="built_in">console</span>.log(score); <span class="comment">// &#123; _id: 5d9edda306d5b83260cd0565, uid: 5d9edda206d5b83260cd0564, grade: 100, __v: 0 &#125;</span></span><br><span class="line">  <span class="keyword">let</span> user = <span class="keyword">await</span> User.findById(score.uid);</span><br><span class="line">  <span class="built_in">console</span>.log(user); <span class="comment">// &#123; _id: 5d9edda206d5b83260cd0564, name: 'jf', __v: 0 &#125;</span></span><br><span class="line">  <span class="comment">// 这样要查询2次 才能拿到用户的 name</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 使用populate</span></span><br><span class="line">  <span class="comment">// populate就是填充的意思，就是把一个外键字段从一个ObjectId变成一个对象</span></span><br><span class="line">  <span class="keyword">let</span> score2 = <span class="keyword">await</span> Score.findById(scoreId).populate(<span class="string">'uid'</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(score2); </span><br><span class="line">  <span class="comment">// &#123; _id: 5d9edda306d5b83260cd0565, uid: &#123; _id: 5d9edda206d5b83260cd0564, name: 'jf', __v: 0 &#125;, grade: 100, __v: 0 &#125;</span></span><br><span class="line">&#125;)(<span class="string">'5d9edda306d5b83260cd0565'</span>);</span><br></pre></td></tr></table></figure>

<p>mongodb用的非常多，像爱奇艺里面的视频，再次打开，播放记录，也是放到mongodb里面的。</p>
<p>参考资料：<a href="http://www.zhufengpeixun.cn/ahead/html/29.mongodb-5.html" target="_blank" rel="noopener">http://www.zhufengpeixun.cn/ahead/html/29.mongodb-5.html</a></p>
]]></content>
      <categories>
        <category>MongoDB</category>
      </categories>
      <tags>
        <tag>MongoDB</tag>
      </tags>
  </entry>
  <entry>
    <title>Nodejs http （三）</title>
    <url>/2019/10/09/Node-http-3/</url>
    <content><![CDATA[<h3 id="ajax跨域解决方案"><a href="#ajax跨域解决方案" class="headerlink" title="ajax跨域解决方案"></a>ajax跨域解决方案</h3><ol>
<li>jsonp&nbsp;&nbsp;&nbsp;&nbsp; 2. cors&nbsp;&nbsp; 3. iframe&nbsp;&nbsp;  4. websocket&nbsp;&nbsp; 5. window.name&nbsp;&nbsp; 6. nginx</li>
</ol>
<a id="more"></a>

<p>新建index.html</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"X-UA-Compatible"</span> <span class="attr">content</span>=<span class="string">"ie=edge"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 跨域  域名、协议、端口号 其中任何一个不满足都是跨域--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">        <span class="comment">// axios 是基于 xhr 来实现 支持promise， axios自带拦截器</span></span></span><br><span class="line"><span class="javascript">        <span class="comment">// fetch 不是基于xhr的，发请求就只有一个fetch请求，并且api很底层，不能终止fetch,因为它是一个promise</span></span></span><br><span class="line"></span><br><span class="line"><span class="javascript">        fetch(<span class="string">'http://localhost:3000/api'</span>,&#123;</span></span><br><span class="line"><span class="javascript">            method: <span class="string">'get'</span>,</span></span><br><span class="line"><span class="javascript">        &#125;).then(<span class="function"><span class="params">res</span>=&gt;</span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">return</span> res.json(); </span></span><br><span class="line"><span class="javascript">	<span class="comment">// res.json表示将1.core.js服务器返回的结果转化成json； return res.json() 返回的是一个promise 走下面这个then</span></span></span><br><span class="line"><span class="javascript">        &#125;).then(<span class="function"><span class="params">json</span>=&gt;</span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="built_in">console</span>.log(<span class="string">'打印：'</span>, json);</span></span><br><span class="line">        &#125;)</span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>1.core.js</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line"></span><br><span class="line">http.createServer(<span class="function">(<span class="params">req,res</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(req.url === <span class="string">'/api'</span>)&#123;</span><br><span class="line">        res.end(<span class="built_in">JSON</span>.stringify(&#123;<span class="attr">name</span>: <span class="string">'jf'</span>&#125;));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).listen(<span class="number">3000</span>);</span><br><span class="line"><span class="comment">// 当前为服务器端 启动服务 nodemon 1.core.js</span></span><br><span class="line"><span class="comment">// 客户端 Open with Live Serve index.html  如下图报跨域错误</span></span><br></pre></td></tr></table></figure>

<p><img src="https://jiafei2333.github.io/html/images/access-control-1.png" alt></p>
<h4 id="配置简单跨域设置"><a href="#配置简单跨域设置" class="headerlink" title="配置简单跨域设置"></a>配置简单跨域设置</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1.core.js</span></span><br><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line">http.createServer(<span class="function">(<span class="params">req,res</span>)=&gt;</span>&#123;</span><br><span class="line">    res.setHeader(<span class="string">'Access-Control-Allow-Origin'</span>,<span class="string">'*'</span>);</span><br><span class="line">    <span class="keyword">if</span>(req.url === <span class="string">'/api'</span>)&#123;</span><br><span class="line">        res.end(<span class="built_in">JSON</span>.stringify(&#123;<span class="attr">name</span>: <span class="string">'jf'</span>&#125;));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).listen(<span class="number">3000</span>);</span><br><span class="line"><span class="comment">// 浏览器访问index.html  打印： &#123;name: "jf"&#125;</span></span><br></pre></td></tr></table></figure>

<h4 id="OPTIONS请求"><a href="#OPTIONS请求" class="headerlink" title="OPTIONS请求"></a>OPTIONS请求</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--index.html--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="comment">// 如果用户发送了OPTIONS请求，就是试探能不能访问服务器</span></span></span><br><span class="line"><span class="javascript">    fetch(<span class="string">'http://localhost:3000/api'</span>,&#123;</span></span><br><span class="line"><span class="javascript">        method: <span class="string">'get'</span>,</span></span><br><span class="line">        headers:&#123;</span><br><span class="line"><span class="javascript">            token: <span class="string">'xxxx...'</span>, <span class="comment">// 自定义header</span></span></span><br><span class="line">        &#125;</span><br><span class="line"><span class="javascript">    &#125;).then(<span class="function"><span class="params">res</span>=&gt;</span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">return</span> res.json(); </span></span><br><span class="line"><span class="javascript">    &#125;).then(<span class="function"><span class="params">json</span>=&gt;</span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="string">'打印：'</span>, json);</span></span><br><span class="line">    &#125;)</span><br><span class="line"><span class="javascript">    <span class="comment">// 自定义header加上任何请求(get、post...),都是复杂请求 运行</span></span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="https://jiafei2333.github.io/html/images/access-control-2.png" alt></p>
<p>允许访问，但是header需要设置一下，如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1.core.js</span></span><br><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line">http.createServer(<span class="function">(<span class="params">req,res</span>)=&gt;</span>&#123;</span><br><span class="line">    res.setHeader(<span class="string">'Access-Control-Allow-Origin'</span>,<span class="string">'*'</span>);</span><br><span class="line">    <span class="comment">// 如果发送的是其他header 需要这里进行设置允许</span></span><br><span class="line">    res.setHeader(<span class="string">'Access-Control-Allow-Headers'</span>, <span class="string">'token,...'</span>);</span><br><span class="line">    <span class="keyword">if</span>(req.method === <span class="string">'OPTIONS'</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> res.end();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(req.url === <span class="string">'/api'</span>)&#123;</span><br><span class="line">        res.end(<span class="built_in">JSON</span>.stringify(&#123;<span class="attr">name</span>: <span class="string">'jf'</span>&#125;));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).listen(<span class="number">3000</span>);</span><br></pre></td></tr></table></figure>

<p>设置了header里面的token之后</p>
<p><img src="https://jiafei2333.github.io/html/images/access-control-5.png" alt></p>
<p>第一次是OPTIONS，发送了一个试探请求</p>
<p><img src="https://jiafei2333.github.io/html/images/access-control-3.png" alt></p>
<p>第二次是GET，能够获取到res返回的值</p>
<p><img src="https://jiafei2333.github.io/html/images/access-control-4.png" alt></p>
<hr>
<h4 id="发送复杂请求"><a href="#发送复杂请求" class="headerlink" title="发送复杂请求"></a>发送复杂请求</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--index.html--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    fetch(<span class="string">'http://localhost:3000/api'</span>,&#123;</span></span><br><span class="line"><span class="javascript">        method: <span class="string">'delete'</span>, <span class="comment">// 发送的是复杂请求</span></span></span><br><span class="line">        headers:&#123;</span><br><span class="line"><span class="javascript">            token: <span class="string">'xxxx'</span>,</span></span><br><span class="line">        &#125;</span><br><span class="line"><span class="javascript">    &#125;).then(<span class="function"><span class="params">res</span>=&gt;</span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">return</span> res.json(); </span></span><br><span class="line"><span class="javascript">    &#125;).then(<span class="function"><span class="params">json</span>=&gt;</span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="string">'打印：'</span>, json);</span></span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1.core.js</span></span><br><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line">http.createServer(<span class="function">(<span class="params">req,res</span>)=&gt;</span>&#123;</span><br><span class="line">    res.setHeader(<span class="string">'Access-Control-Allow-Origin'</span>,<span class="string">'*'</span>);</span><br><span class="line">    res.setHeader(<span class="string">'Access-Control-Allow-Headers'</span>, <span class="string">'token,xxx'</span>);</span><br><span class="line">    <span class="comment">// 我允许哪个方法来访问我 默认是支持get、post的</span></span><br><span class="line">    res.setHeader(<span class="string">'Access-Control-Allow-Methods'</span>, <span class="string">'PUT,DELETE'</span>);</span><br><span class="line">    <span class="comment">// 30分钟 发一次options  prefight 这个叫预检请求</span></span><br><span class="line">    res.setHeader(<span class="string">'Access-Control-Max-Age'</span>, <span class="string">'1800'</span>);</span><br><span class="line">    <span class="keyword">if</span>(req.method === <span class="string">'OPTIONS'</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> res.end();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(req.url === <span class="string">'/api'</span>)&#123;</span><br><span class="line">        res.end(<span class="built_in">JSON</span>.stringify(&#123;<span class="attr">name</span>: <span class="string">'jf'</span>&#125;));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).listen(<span class="number">3000</span>);</span><br></pre></td></tr></table></figure>

<h4 id="设置Cookie"><a href="#设置Cookie" class="headerlink" title="设置Cookie"></a>设置Cookie</h4><blockquote>
<p>http 无状态的 没法记住状态 一般会借助cookie 通过服务器设置cookie 每次请求的时候会带上cookie</p>
</blockquote>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--index.html--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="comment">// 设置cookie</span></span></span><br><span class="line"><span class="javascript">    <span class="comment">// 默认情况下 cookie是不允许跨域设置的</span></span></span><br><span class="line"><span class="javascript">    fetch(<span class="string">'http://localhost:3000/api'</span>,&#123;</span></span><br><span class="line"><span class="javascript">        method: <span class="string">'delete'</span>,</span></span><br><span class="line">        headers:&#123;</span><br><span class="line"><span class="javascript">            token: <span class="string">'xxxx'</span>,</span></span><br><span class="line">        &#125;,</span><br><span class="line"><span class="javascript">        credentials: <span class="string">'include'</span>, <span class="comment">// 这里可以查看mdn fetch默认不会携带或接受cookie</span></span></span><br><span class="line"><span class="javascript">    &#125;).then(<span class="function"><span class="params">res</span>=&gt;</span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">return</span> res.json(); </span></span><br><span class="line"><span class="javascript">    &#125;).then(<span class="function"><span class="params">json</span>=&gt;</span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="string">'打印：'</span>, json);</span></span><br><span class="line">    &#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="https://jiafei2333.github.io/html/images/access-control-6.png" alt></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1.core.js</span></span><br><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line">http.createServer(<span class="function">(<span class="params">req,res</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res.headers);</span><br><span class="line">    <span class="comment">// res.setHeader('Access-Control-Allow-Origin','*');</span></span><br><span class="line">    <span class="comment">// 指访问的源 谁访问我就是指谁 不能写* 但是表示所有人都可以访问我</span></span><br><span class="line">    res.setHeader(<span class="string">'Access-Control-Allow-Origin'</span>,req.headers.origin);</span><br><span class="line">    res.setHeader(<span class="string">'Access-Control-Allow-Headers'</span>, <span class="string">'token,xxx'</span>);</span><br><span class="line">    res.setHeader(<span class="string">'Access-Control-Allow-Methods'</span>, <span class="string">'PUT,DELETE'</span>);</span><br><span class="line">    res.setHeader(<span class="string">'Access-Control-Max-Age'</span>, <span class="string">'1800'</span>);</span><br><span class="line">    <span class="comment">// 允许客户端携带凭证</span></span><br><span class="line">    res.setHeader(<span class="string">'Access-Control-Allow-Credentials'</span>, <span class="literal">true</span>);</span><br><span class="line">    <span class="keyword">if</span>(req.method === <span class="string">'OPTIONS'</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> res.end();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(req.url === <span class="string">'/api'</span>)&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'headers:'</span>, req.headers.cookie);  <span class="comment">// name=jf</span></span><br><span class="line">        res.setHeader(<span class="string">'Set-Cookie'</span>, <span class="string">'name=jf'</span>);</span><br><span class="line">        res.end(<span class="built_in">JSON</span>.stringify(&#123;<span class="attr">name</span>: <span class="string">'jf'</span>&#125;));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).listen(<span class="number">3000</span>);</span><br><span class="line"><span class="comment">// 图这里不能写*    1这里不能写*(line5) + 2服务器允许客户端携带凭着(line12) 这2点设置</span></span><br><span class="line"><span class="comment">// 服务端设置之后每次客户端请求以后都会带上  就可以知道是否登陆过</span></span><br></pre></td></tr></table></figure>

<p><img src="https://jiafei2333.github.io/html/images/access-control-7.png" alt></p>
<p> 以上为ajax跨域相关的头设置</p>
<h3 id="反向代理"><a href="#反向代理" class="headerlink" title="反向代理"></a>反向代理</h3><p>nginx 反向代理 就是针对用户是透明的<br>webpack proxy 反向 代理接口 我访问的还是以前的接口 主要的功能就是缓存 cdn 也是一个反向代理，感觉用户访问的是主机，其实访问的是各个子代理站点 （缓存+反向代理）</p>
<p><img src="https://jiafei2333.github.io/html/images/proxy-cache-cdn.png" alt title="CDN"></p>
<h4 id="webpack-它是如何实现反向代理的，核心就是创建代理服务器"><a href="#webpack-它是如何实现反向代理的，核心就是创建代理服务器" class="headerlink" title="webpack 它是如何实现反向代理的，核心就是创建代理服务器"></a>webpack 它是如何实现反向代理的，核心就是创建代理服务器</h4><p>从 2.proxy.js 服务器 去请求 5000.js 服务器，通过访问2.proxy网站去请求5000.js, 2.proxy相当于中间层</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 2.proxy.js</span></span><br><span class="line"><span class="keyword">let</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line"><span class="keyword">let</span> httpProxy = <span class="built_in">require</span>(<span class="string">'http-proxy'</span>); <span class="comment">// 用法可以看npmjs上的http-proxy</span></span><br><span class="line"><span class="keyword">var</span> proxy = httpProxy.createProxyServer(); <span class="comment">// 开启了一个服务</span></span><br><span class="line"></span><br><span class="line">http.createServer(<span class="function">(<span class="params">req,res</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="comment">// http-proxy   npmjs =&gt; 搜索=&gt; http-proxy , 安装npm install http-proxy --save </span></span><br><span class="line">    <span class="comment">// 这里进行服务的转发</span></span><br><span class="line">    proxy.web(req,res,&#123;</span><br><span class="line">        target: <span class="string">'http://localhost:5000'</span></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;).listen(<span class="number">3000</span>);</span><br></pre></td></tr></table></figure>

<p>新建5000.js</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 5000.js</span></span><br><span class="line"><span class="keyword">let</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line"></span><br><span class="line">http.createServer(<span class="function">(<span class="params">req,res</span>)=&gt;</span>&#123;</span><br><span class="line">    res.end(<span class="string">'I am 5000 port'</span>);</span><br><span class="line">&#125;).listen(<span class="number">5000</span>);</span><br></pre></td></tr></table></figure>

<p>开启服务: 1、node 5000.js 2、nodemon 2.proxy , 访问端口 3、localhost:3000，浏览器打印出I am 5000 port</p>
<h5 id="能干什么？"><a href="#能干什么？" class="headerlink" title="能干什么？"></a>能干什么？</h5><p>现在希望一个服务器上可以部署多个网站 nginx<br>如果我现在要部署2个网站<br><a href="http://www.jf1.cn" target="_blank" rel="noopener">www.jf1.cn</a>  那么默认访问这个端口是80<br><a href="http://www.jf2.cn" target="_blank" rel="noopener">www.jf2.cn</a>  那么默认访问这个端口也是80<br>中间会有一个代理机 proxy 如果是<a href="http://www.jf1.cn" target="_blank" rel="noopener">www.jf1.cn</a> 会到3000端口上 ， <a href="http://www.jf2.cn会到3001端口上" target="_blank" rel="noopener">www.jf2.cn会到3001端口上</a> 感觉访问的是80 其实被分配到了其他的端口上。<br>实行：拿到当前访问的域名，根据域名来访问</p>
<p>根据host不同返回不同的网站，主要依靠的就是反向代理</p>
<blockquote>
<p>反向是针对浏览器透明  正向是针对服务器透明</p>
</blockquote>
<h3 id="302临时重定向"><a href="#302临时重定向" class="headerlink" title="302临时重定向"></a>302临时重定向</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 根据内核跳转页面 302 临时重定向</span></span><br><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 手机端 移动页面</span></span><br><span class="line"><span class="comment">// pc端</span></span><br><span class="line">http.createServer(<span class="function">(<span class="params">req,res</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="comment">// 如果是手机端 跳转到百度 , 如果是pc端 跳转到知乎</span></span><br><span class="line">    <span class="comment">// 浏览器pc端模式：User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_13_6) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/76.0.3809.132 Safari/537.36</span></span><br><span class="line">    <span class="comment">// 浏览器手机端模式：User-Agent: Mozilla/5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) AppleWebKit/604.1.38 (KHTML, like Gecko) Version/11.0 Mobile/15A372 Safari/604.1</span></span><br><span class="line">    <span class="keyword">let</span> userAgent = req.headers[<span class="string">'user-agent'</span>];</span><br><span class="line">    <span class="keyword">if</span>(userAgent.includes(<span class="string">'iPhone'</span>))&#123;</span><br><span class="line">        res.statusCode = <span class="number">302</span>;</span><br><span class="line">        res.setHeader(<span class="string">'Location'</span>, <span class="string">'http://www.baidu.com'</span>);</span><br><span class="line">        res.end(); <span class="comment">// 结束当前服务 这样才会跳转到设置的这个网站</span></span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        res.statusCode = <span class="number">302</span>;</span><br><span class="line">        res.setHeader(<span class="string">'Location'</span>, <span class="string">'http://www.zhihu.com'</span>);</span><br><span class="line">        res.end(); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 这就是常见的服务器重定向   redirect</span></span><br><span class="line">&#125;).listen(<span class="number">3000</span>);</span><br></pre></td></tr></table></figure>

<p>运行  nodemon 4.agent.js  浏览器访问 localhost:3000</p>
<h3 id="多语言"><a href="#多语言" class="headerlink" title="多语言"></a>多语言</h3><p>根据客户端所支持的语言返回对应的结果<br>Accept-Language: zh-CN,zh;q=0.9,en;q=0.8<br>客户端可以自行配置语言 不同的语言组成不同的网站</p>
<p><img src="https://jiafei2333.github.io/html/images/accept-language.png" alt></p>
]]></content>
      <categories>
        <category>Nodejs</category>
      </categories>
      <tags>
        <tag>Nodejs</tag>
        <tag>HTTP</tag>
        <tag>反向代理</tag>
        <tag>ajax 跨域</tag>
      </tags>
  </entry>
  <entry>
    <title>Nodejs http （二）</title>
    <url>/2019/09/30/Node-http-2/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>全局安装 <code>http-server</code>  npm install http-server -g<br>http-server      以当前文件夹为根目录的服务被启动</p>
<a id="more"></a>
<p><img src="https://jiafei2333.github.io/html/images/http-server.png" alt title="http-server 图1"></p>
<h1 id="Server服务"><a href="#Server服务" class="headerlink" title="Server服务"></a>Server服务</h1><p>现在手写下这个服务<br>这里要做的功能是仿 http-server  启动服务 浏览器能够访问当前文件夹下的启动的这个服务</p>
<h2 id="基本步骤："><a href="#基本步骤：" class="headerlink" title="基本步骤："></a>基本步骤：</h2><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>npm init -y<br>有一个执行命令的脚本 用于解析用户的参数 新建bin/www文件  便于记忆 有病的环境</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// bin/www</span></span><br><span class="line">#！ /usr/bin/env node</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'create server'</span>);</span><br></pre></td></tr></table></figure>

<h3 id="配脚本"><a href="#配脚本" class="headerlink" title="配脚本"></a>配脚本</h3><p><code>package.json</code>文件添加如下配置：</p>
<p><img src="https://jiafei2333.github.io/html/images/http-server-package.png" alt></p>
<h3 id="映射到全局"><a href="#映射到全局" class="headerlink" title="映射到全局"></a>映射到全局</h3><p>iTerm  cd到当前目录17.http/  <code>npm link</code></p>
<p><img src="https://jiafei2333.github.io/html/images/npm-link.png" alt></p>
<p>可以看到全局命令下有个server命令，执行它就会执行bin/www</p>
<p><img src="https://jiafei2333.github.io/html/images/server.png" alt></p>
<h3 id="拓展功能"><a href="#拓展功能" class="headerlink" title="拓展功能"></a>拓展功能</h3><h4 id="help"><a href="#help" class="headerlink" title="- -help"></a>- -help</h4><p>基本上写一个命令行工具都会有这样一个功能  server - -help<br>这里会用到这个比较流行的工具 <code>commander</code><br><code>npm install commander</code> 解析命令行参数的，只要写工具，必备的包。<br>先可以参考下http-server的- -help</p>
<p><img src="https://jiafei2333.github.io/html/images/http-server--help.png" alt></p>
<h4 id="p"><a href="#p" class="headerlink" title="-p"></a>-p</h4><p>-p 改端口号(默认是8080)    <code>http-server -p 3000</code> 这样开启的端口就是3000<br>现在实现跟上面一样的功能   <code>server -p 3000</code><br>现在需要用commander去解析命令行工具   现在去www文件</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// www</span></span><br><span class="line"><span class="meta">#! /usr/bin/env node</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> commander  = <span class="built_in">require</span>(<span class="string">'commander'</span>);</span><br><span class="line"><span class="comment">// 这个是commonjs规范</span></span><br><span class="line"><span class="comment">// 有时候会这样引入</span></span><br><span class="line"><span class="keyword">import</span> commander <span class="keyword">from</span> <span class="string">'commander'</span>; </span><br><span class="line"><span class="comment">// 这里运行一下 server 会报错 因为这是es6语法，node中不支持   这时候需要把es6转成es5  核心就要用到babel包</span></span><br></pre></td></tr></table></figure>

<h4 id="babel-es6-gt-es5"><a href="#babel-es6-gt-es5" class="headerlink" title="babel  es6 =&gt; es5"></a>babel  es6 =&gt; es5</h4><p>安装 <code>npm install  @babel/cli  @babel/core   @babel/preset-env --save-dev</code></p>
<blockquote>
<p>@babel/cli (在命令行里面调它，它默认会调用 @babel/core)<br>@babel/core  (babel的核心文件，找配置文件.babelrc，它会根据配置文件去调  @babel/preset-env 这个包)<br>@babel/preset-env  (它的功能就是把es6=&gt;es5)</p>
</blockquote>
<p>新建 <code>.babelrc</code>文件</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">"presets"</span>: [</span><br><span class="line">        [<span class="string">"@babel/preset-env"</span>,&#123;</span><br><span class="line">            <span class="string">"targets"</span>:&#123;</span><br><span class="line">                <span class="string">"node"</span>:<span class="string">"current"</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;]</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// line4-6意思是需要把es6编译到什么地步，这里需要编译到node版本，当前版本， import 编译成 require</span></span><br></pre></td></tr></table></figure>

<p>下面这个文件的作用只做require &nbsp;&nbsp;&nbsp;&nbsp; 解析参数的功能放到 /src/main.js</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// www</span></span><br><span class="line"><span class="meta">#! /usr/bin/env node</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// require('../src/main'); // 这里引得是源代码 es6写的，但是最终需要引的是打包出来的es5，所以变成如下</span></span><br><span class="line"><span class="built_in">require</span>(<span class="string">'../dist/main'</span>);</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// main.js</span></span><br><span class="line"><span class="keyword">import</span> commander <span class="keyword">from</span> <span class="string">'commander'</span>; <span class="comment">// 在这里执行解析参数的功能</span></span><br><span class="line"><span class="built_in">console</span>.log(commander);</span><br></pre></td></tr></table></figure>

<p>好 现在来解析<br>可以用 npx babel –help 查看参数  这里npx 会走node_modules/.bin/babel<br>转化 <code>npx babel src -d dist</code>  解析src文件夹下的内容 放到dist文件夹下 </p>
<p>现在 server  就能够获取到编译好的代码   但是每次main.js改动都需要手动执行  现如下<br><code>npx babel src -d dist --watch</code> 加一个监控 可以自动编译   这样在node环境就可以用es6语法来写这个功能了</p>
<p>小调整  用npx可能给别人用不太好  package.json增加line11、12  </p>
<p><img src="https://jiafei2333.github.io/html/images/babel.png" alt></p>
<p><code>npm run babel:watch</code> &nbsp;&nbsp;&nbsp;&nbsp;    <code>npm run babel</code></p>
<h4 id="解析参数"><a href="#解析参数" class="headerlink" title="解析参数"></a>解析参数</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// main.js</span></span><br><span class="line"><span class="keyword">import</span> pragram <span class="keyword">from</span> <span class="string">'commander'</span>;</span><br><span class="line"></span><br><span class="line">pragram</span><br><span class="line">    .option(<span class="string">'-p, --port &lt;val&gt;'</span>, <span class="string">'set http-server port'</span>)</span><br><span class="line">    .parse(process.argv);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> config = &#123;</span><br><span class="line">    port: <span class="number">8080</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Object</span>.assign(config, pragram);  </span><br><span class="line"><span class="built_in">console</span>.log(pragram.port, config.port);</span><br></pre></td></tr></table></figure>

<p>执行 server –help<br>设置option参数可以 执行 npm commander 参考<br>执行 server -p 3000   打印 3000 3000</p>
<h5 id="通过解析的参数启动一个服务"><a href="#通过解析的参数启动一个服务" class="headerlink" title="通过解析的参数启动一个服务"></a>通过解析的参数启动一个服务</h5><p>获取当前文件夹下的内容（文件夹、文件），拼接成模板显示出来，如图：</p>
<p><img src="https://jiafei2333.github.io/html/images/server-dirList.gif" alt></p>
<p>新建server.js</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// main.js</span></span><br><span class="line"><span class="keyword">import</span> Server <span class="keyword">from</span> <span class="string">'./server'</span>;</span><br><span class="line"><span class="keyword">let</span> server = <span class="keyword">new</span> Server(config);</span><br><span class="line">server.start();</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// server.js</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Server</span></span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(config)&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(config);</span><br><span class="line">    &#125;</span><br><span class="line">    start()&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Server;</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// server.js</span></span><br><span class="line"><span class="keyword">import</span> http <span class="keyword">from</span> <span class="string">'http'</span>;</span><br><span class="line"><span class="keyword">import</span> fs, &#123; readFileSync &#125; <span class="keyword">from</span> <span class="string">'fs'</span>;</span><br><span class="line"><span class="keyword">import</span> path <span class="keyword">from</span> <span class="string">'path'</span>;</span><br><span class="line"><span class="keyword">import</span> util <span class="keyword">from</span> <span class="string">'util'</span>;</span><br><span class="line"><span class="keyword">import</span> url <span class="keyword">from</span> <span class="string">'url'</span>;</span><br><span class="line"><span class="keyword">import</span> zlib  <span class="keyword">from</span> <span class="string">'zlib'</span>;</span><br><span class="line"><span class="keyword">import</span> crypto <span class="keyword">from</span> <span class="string">'crypto'</span>;</span><br><span class="line"><span class="keyword">let</span> &#123; readFile,writeFile,readdir,stat &#125;  = fs.promises</span><br><span class="line"><span class="comment">// 第三方 </span></span><br><span class="line"><span class="keyword">import</span> mime <span class="keyword">from</span> <span class="string">'mime'</span>;</span><br><span class="line"><span class="keyword">import</span> chalk <span class="keyword">from</span> <span class="string">'chalk'</span>; <span class="comment">// 变颜色</span></span><br><span class="line"><span class="keyword">import</span> ejs <span class="keyword">from</span> <span class="string">'ejs'</span>;</span><br><span class="line"><span class="comment">// npm i mime chalk ejs</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> template = fs.readFileSync(path.resolve(__dirname,<span class="string">'../template.html'</span>),<span class="string">'utf8'</span>);</span><br><span class="line"><span class="comment">// console.log(template);</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Server</span></span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(config)&#123;</span><br><span class="line">        <span class="keyword">this</span>.port = config.port;</span><br><span class="line">        <span class="keyword">this</span>.template = template; <span class="comment">// 将template属性放到实例上 可以保证属性永远可以通过this来获取，不被参数覆盖掉</span></span><br><span class="line">        <span class="comment">// console.log(config);</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">async</span> handleRequest(req,res)&#123;</span><br><span class="line">        <span class="keyword">let</span> &#123;pathname&#125; = url.parse(req.url, <span class="literal">true</span>);</span><br><span class="line">        <span class="comment">// 解析中文路径</span></span><br><span class="line">        pathname = <span class="built_in">decodeURIComponent</span>(pathname); </span><br><span class="line">		<span class="comment">// 如果是中文路径 浏览器会把中文转化成十六进制  decodeURIComponent('你好')；  可以先把这行注释了看看能否访问'你好' 文件夹</span></span><br><span class="line">        <span class="comment">// let filePath = path.join(__dirname, pathname);</span></span><br><span class="line">        <span class="comment">// 这里面启动server时 引用的是dist下的main __dirname 打印 /Users/jiafei/Desktop/Architecture-Course/17.http/dist  ，__dirname指当前执行文件的路径，到时候打包到dist文件下， 而这个服务是启动当前文件执行的目录 应该就是17.http目录</span></span><br><span class="line">        <span class="keyword">let</span> filePath = path.join(process.cwd(), pathname);  <span class="comment">// 找到当前执行命令的目录</span></span><br><span class="line">        <span class="comment">// 找到当前执行命令的目录,并执行，而不是当前文件所在的文件夹目录</span></span><br><span class="line">        <span class="comment">// console.log(filePath); // /Users/jiafei/Desktop/Architecture-Course/17.http/</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> statObj = <span class="keyword">await</span> stat(filePath);</span><br><span class="line">            <span class="keyword">if</span>(statObj.isDirectory())&#123;</span><br><span class="line">                <span class="comment">// console.log('是目录');</span></span><br><span class="line">                <span class="comment">// 我需要判断是不是目录</span></span><br><span class="line">                <span class="comment">// 如果是目录 需要读取目录下的文件</span></span><br><span class="line">                <span class="keyword">let</span> dirs = <span class="keyword">await</span> readdir(filePath);</span><br><span class="line">                <span class="built_in">console</span>.log(dirs);</span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                [ '.babelrc',</span></span><br><span class="line"><span class="comment">                    '1.md',</span></span><br><span class="line"><span class="comment">                    'bin',</span></span><br><span class="line"><span class="comment">                    'dist',</span></span><br><span class="line"><span class="comment">                    'http-1.md',</span></span><br><span class="line"><span class="comment">                    'http-2.md',</span></span><br><span class="line"><span class="comment">                    'http-3.md',</span></span><br><span class="line"><span class="comment">                    'node_modules',</span></span><br><span class="line"><span class="comment">                    'package-lock.json',</span></span><br><span class="line"><span class="comment">                    'package.json',</span></span><br><span class="line"><span class="comment">                    'src' ]</span></span><br><span class="line"><span class="comment">                */</span></span><br><span class="line">               <span class="comment">// 现在需要将这些列表数据渲染成一个页面展示给前端  这里用到ejs 新建template.html 这里将静态资源放在了跟目录下</span></span><br><span class="line">                <span class="comment">// 我需要访问文件的时候 增加他当前的路径，如果是/ 就不增加了，否则将路径拼在文件前面</span></span><br><span class="line">                <span class="keyword">let</span> templateStr = ejs.render(<span class="keyword">this</span>.template,&#123;</span><br><span class="line">                    dirs,</span><br><span class="line">                    path:pathname === <span class="string">'/'</span>?<span class="string">''</span>:pathname</span><br><span class="line">                &#125;); <span class="comment">// 返回的是渲染好的字符串</span></span><br><span class="line">                res.setHeader(<span class="string">'Content-Type'</span>,<span class="string">'text/html;charset=utf-8'</span>)</span><br><span class="line">                res.end(templateStr);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">this</span>.sendFile(filePath,req,res,statObj); <span class="comment">// 浏览器请求  localhost:8080/http-1.md</span></span><br><span class="line">            &#125;</span><br><span class="line">        </span><br><span class="line">        &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">            <span class="keyword">this</span>.sendError(error,req,res);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    sendFile(filePath,req,res,statObj)&#123; <span class="comment">// 创建流返回去就好了</span></span><br><span class="line">        <span class="keyword">let</span> t = <span class="built_in">require</span>(<span class="string">"mime"</span>).getType(filePath);</span><br><span class="line">        res.setHeader(<span class="string">"Content-Type"</span>, t + <span class="string">";charset=utf-8"</span>);</span><br><span class="line">        fs.createReadStream(filePath).pipe(res);</span><br><span class="line">    &#125;</span><br><span class="line">    sendError(error,req,res)&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(e);</span><br><span class="line">        res.statusCode = <span class="number">404</span>;</span><br><span class="line">        res.end(<span class="string">'Not Found'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    start()&#123;</span><br><span class="line">        <span class="keyword">let</span> server = http.createServer(<span class="keyword">this</span>.handleRequest.bind(<span class="keyword">this</span>));</span><br><span class="line">        server.listen(<span class="keyword">this</span>.port, ()=&gt;&#123;</span><br><span class="line">            <span class="comment">// 这一块的参数展现形式包括颜色  参考http-server 图1</span></span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;chalk.yellow(<span class="string">'Starting up http-server, serving'</span>)&#125;</span> <span class="subst">$&#123;chalk.blue(<span class="string">'./'</span>)&#125;</span></span></span><br><span class="line"><span class="string">            Available on:</span></span><br><span class="line"><span class="string">              http://127.0.0.1:<span class="subst">$&#123;chalk.red(<span class="string">'8080'</span>)&#125;</span></span></span><br><span class="line"><span class="string">              http://192.168.0.100::<span class="subst">$&#123;chalk.yellow(<span class="string">'8080'</span>)&#125;</span></span></span><br><span class="line"><span class="string">            Hit CTRL-C to stop the server`</span>);</span><br><span class="line">            <span class="comment">// 现在已经启动了这服务 现在需要能够访问   =&gt; handleRequest()</span></span><br><span class="line"></span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Server;</span><br></pre></td></tr></table></figure>

<p>新建 template.html</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"X-UA-Compatible"</span> <span class="attr">content</span>=<span class="string">"ie=edge"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">%dirs.forEach(dir=</span>&gt;</span>&#123;%&gt;</span><br><span class="line">            <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"&lt;%=path%&gt;/&lt;%=dir%&gt;"</span>&gt;</span><span class="tag">&lt;<span class="name">%=dir%</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">%&#125;)%</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="http优化策略"><a href="#http优化策略" class="headerlink" title="http优化策略"></a>http优化策略</h2><h3 id="1-压缩"><a href="#1-压缩" class="headerlink" title="1) 压缩"></a>1) 压缩</h3><p>客户端说我支持：Accept-Encoding: gzip, deflate, br（这里node支持前2种）</p>
<p><img src="https://jiafei2333.github.io/html/images/gzip-req.png" alt></p>
<p>服务器：Content-Encoding: gzip</p>
<p><img src="https://jiafei2333.github.io/html/images/gzip-res.png" alt></p>
<h4 id="怎么实现"><a href="#怎么实现" class="headerlink" title="怎么实现"></a>怎么实现</h4><h5 id="转化流"><a href="#转化流" class="headerlink" title="转化流"></a>转化流</h5><blockquote>
<p>流：可读流(源码里面自己实现了一个_read) &nbsp;&nbsp;可写流(源码里自己实现了一个_write) &nbsp;&nbsp;双工流_read _write<br>转化流：压缩就是靠这个转化流实现的</p>
</blockquote>
<p>现在自己构建一个转化流</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123;Transform&#125; = <span class="built_in">require</span>(<span class="string">'stream'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自己写个流MyTransform 继承 Transform 再去实现某些方法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyTransform</span> <span class="keyword">extends</span> <span class="title">Transform</span></span>&#123;</span><br><span class="line">    _transform()&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> myTransform = <span class="keyword">new</span> MyTransform(); <span class="comment">// 创建一个转化流</span></span><br></pre></td></tr></table></figure>

<p>延伸 插入一个知识点</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 标准输出</span></span><br><span class="line"><span class="number">1.</span> process.stdout.write(<span class="string">'ok'</span>); <span class="comment">// 可写流 write('ok')  意思就是往控制台里输出 ok 命令行 node 1.stream.js 运行下</span></span><br><span class="line"></span><br><span class="line"><span class="number">2.</span> process.stdin.on(<span class="string">'data'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">    process.stdout.write(data);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 描述 将读到的内容data 再写出去  命令行 node 1.stream.js 运行下  输入 123 回车 123</span></span><br><span class="line"><span class="comment">// 分析：</span></span><br><span class="line"><span class="comment">// process.stdin 可读流     process.stdout 可写流  如何将可读流的数据导到可写流中</span></span><br><span class="line"><span class="number">3.</span> process.stdin.pipe(process.stdout); <span class="comment">// 再执行</span></span><br></pre></td></tr></table></figure>

<p>补gif图<br>进阶 如果输入 abc 能够输出ABC<br>中间做一步转化 把读取到的内容先放到一个流里面转化完 再把它写出来</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123;Transform&#125; = <span class="built_in">require</span>(<span class="string">'stream'</span>);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyTransform</span> <span class="keyword">extends</span> <span class="title">Transform</span></span>&#123;</span><br><span class="line">    <span class="comment">// _transform 这个方法是源码内部的 和上面的_write _read一样</span></span><br><span class="line">    _transform(chunk,encoding,callback)&#123; <span class="comment">// 和可写流一样</span></span><br><span class="line">        chunk = chunk.toString().toUpperCase(); </span><br><span class="line">        <span class="comment">// 再写到读流里</span></span><br><span class="line">        <span class="keyword">this</span>.push(chunk);</span><br><span class="line">        callback(); <span class="comment">// 清空缓存 不加的话只能转化一次 再写入就放到缓存里了  这里可以运行试下</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> myTransform = <span class="keyword">new</span> MyTransform(); </span><br><span class="line">process.stdin.pipe(myTransform).pipe(process.stdout);</span><br></pre></td></tr></table></figure>

<p>补gif图</p>
<h5 id="压缩-gzip"><a href="#压缩-gzip" class="headerlink" title="压缩 gzip"></a>压缩 gzip</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> zlib = <span class="built_in">require</span>(<span class="string">'zlib'</span>);</span><br><span class="line"><span class="comment">// 新建一个1.txt      文件内容里面重复的越多，压缩的越小</span></span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"></span><br><span class="line">zlib.gzip(fs.readFileSync(path.resolve(__dirname,<span class="string">'1.txt'</span>)), <span class="function"><span class="keyword">function</span>(<span class="params">err,data</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 整个压缩完之后再写</span></span><br><span class="line">    <span class="built_in">console</span>.log(data,<span class="string">'---'</span>)</span><br><span class="line">    fs.writeFileSync(path.resolve(__dirname,<span class="string">'1.txt.gz'</span>),data);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 这里可以看到7k压缩成了145字节</span></span><br><span class="line"><span class="comment">// 上面这种方法是整个读取之后 =&gt; 整个压缩 =&gt; 整个写入</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> zlib = <span class="built_in">require</span>(<span class="string">'zlib'</span>);</span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line">fs.createReadStream(path.resolve(__dirname,<span class="string">'1.txt'</span>)).pipe(zlib.createGzip()).pipe(fs.createWriteStream(path.resolve(__dirname,<span class="string">'2.XTX.GZ'</span>)));</span><br><span class="line"><span class="comment">// 读取一点 转换一点 写一点  分段 比上面那个的性能好</span></span><br></pre></td></tr></table></figure>

<p>1.txt</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1111111111111111111....</span><br></pre></td></tr></table></figure>

<p>压缩是可解压的  大致会压缩成 这里有1百万个1 把重复的替换掉 变得更小</p>
<h4 id="怎么应用"><a href="#怎么应用" class="headerlink" title="怎么应用"></a>怎么应用</h4><p>开始写压缩流程<br>客户端说我支持：Accept-Encoding: gzip, deflate, br  先将服务启动起来  server<br>访问http-1.md    <a href="http://127.0.0.1:8080/http-1.md" target="_blank" rel="noopener">http://127.0.0.1:8080/http-1.md</a> 现在是4.5k 没有压缩</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 如果文件很大 在服务器上压缩会有性能问题</span></span><br><span class="line">gzip(filePath,req,res,statObj)&#123; <span class="comment">// 现在压缩从4.5k =&gt; 2.6k</span></span><br><span class="line">    <span class="comment">// 查看一下当前是否支持压缩</span></span><br><span class="line">    <span class="keyword">let</span> encoding = req.headers[<span class="string">'accept-encoding'</span>];</span><br><span class="line">    <span class="keyword">if</span>(encoding)&#123;  <span class="comment">// 查看一下是否支持gzip 、 deflate</span></span><br><span class="line">        <span class="keyword">if</span>(encoding.match(<span class="regexp">/gzip/</span>))&#123; </span><br><span class="line">            res.setHeader(<span class="string">"Content-Encoding"</span>, <span class="string">'gzip'</span>); <span class="comment">// 告诉浏览器是用什么压缩的</span></span><br><span class="line">            <span class="keyword">return</span> zlib.createGzip();</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(encoding.match(<span class="regexp">/deflate/</span>))&#123;</span><br><span class="line">            res.setHeader(<span class="string">"Content-Encoding"</span>, <span class="string">'deflate'</span>);</span><br><span class="line">            <span class="keyword">return</span> zlib.createDeflate();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">sendFile(filePath,req,res,statObj)&#123; <span class="comment">// 创建流返回去就好了</span></span><br><span class="line">    <span class="comment">// 在文件发送过程中 如果浏览器支持压缩 我需要对浏览器的内容先压缩 再返回</span></span><br><span class="line">    <span class="keyword">let</span> flag = <span class="keyword">this</span>.gzip(filePath,req,res,statObj);</span><br><span class="line">    <span class="keyword">let</span> t = <span class="built_in">require</span>(<span class="string">"mime"</span>).getType(filePath) || <span class="string">'text/plain'</span>; </span><br><span class="line">	<span class="comment">// 这里加了一个默认的文本类型   如果打开的是www  这个没有后缀，mime就不能获取类型了</span></span><br><span class="line">    res.setHeader(<span class="string">"Content-Type"</span>, t + <span class="string">";charset=utf-8"</span>);</span><br><span class="line">    <span class="keyword">if</span>( !flag)&#123;</span><br><span class="line">        fs.createReadStream(filePath).pipe(res); <span class="comment">// 以前是可读流导入到可写流里</span></span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        fs.createReadStream(filePath).pipe(flag).pipe(res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2）缓存"><a href="#2）缓存" class="headerlink" title="2）缓存"></a>2）缓存</h3><h4 id="强制缓存"><a href="#强制缓存" class="headerlink" title="强制缓存"></a>强制缓存</h4><p><img src="https://jiafei2333.github.io/html/images/cache-1.png" alt></p>
<p>先新建 1.html 、1.css   启动服务 server &nbsp;&nbsp;&nbsp; <a href="http://127.0.0.1:8080/1.html" target="_blank" rel="noopener">http://127.0.0.1:8080/1.html</a></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--1.html--&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"X-UA-Compatible"</span> <span class="attr">content</span>=<span class="string">"ie=edge"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">href</span>=<span class="string">"1.css"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1.css</span></span><br><span class="line">body&#123;</span><br><span class="line">    background: red</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// server.js</span></span><br><span class="line">sendFile(filePath,req,res,statObj)&#123; <span class="comment">// 创建流返回去就好了</span></span><br><span class="line">    <span class="comment">// 缓存</span></span><br><span class="line">    <span class="comment">// 强制缓存：</span></span><br><span class="line">    <span class="comment">// 表示10秒内不要再访问服务器</span></span><br><span class="line">    res.setHeader(<span class="string">'Cache-Control'</span>,<span class="string">'max-age=10'</span>); </span><br><span class="line">    <span class="comment">// 老版本写法 新版本也可以生效 如果两个都写 采用Cache-Control</span></span><br><span class="line">    res.setHeader(<span class="string">'Expires'</span>,<span class="keyword">new</span> <span class="built_in">Date</span>(<span class="built_in">Date</span>.now()+<span class="number">10</span>*<span class="number">1000</span>).toGMTString());</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">'打印~~'</span>, filePath);</span><br><span class="line">	</span><br><span class="line">    <span class="keyword">let</span> flag = <span class="keyword">this</span>.gzip(filePath,req,res,statObj);</span><br><span class="line">    <span class="keyword">let</span> t = <span class="built_in">require</span>(<span class="string">"mime"</span>).getType(filePath) || <span class="string">'text/plain'</span>;</span><br><span class="line">    res.setHeader(<span class="string">"Content-Type"</span>, t + <span class="string">";charset=utf-8"</span>);</span><br><span class="line">    <span class="keyword">if</span>( !flag)&#123;</span><br><span class="line">        fs.createReadStream(filePath).pipe(res);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        fs.createReadStream(filePath).pipe(flag).pipe(res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在看看效果 访问 <a href="http://127.0.0.1:8080/1.html" target="_blank" rel="noopener">http://127.0.0.1:8080/1.html</a></p>
<p><img src="https://jiafei2333.github.io/html/images/cache-2.png" alt></p>
<p>如图所示浏览器缓存了 ‘css’</p>
<p><img src="https://jiafei2333.github.io/html/images/cache-3.png" alt></p>
<p>如图所示 css走的缓存<br>但是这里html还是走的服务器   </p>
<blockquote>
<p>如果设置强制缓存 首页是不会缓存的  所以首页一定会发起请求，如果首页设置了强制缓存，它包含的资源则会走缓存</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 其他的设置</span></span><br><span class="line">res.setHeader(<span class="string">'Cache-Control'</span>,<span class="string">'no-cache'</span>); <span class="comment">// 每次都访问服务器 但是缓存</span></span><br><span class="line">res.setHeader(<span class="string">'Cache-Control'</span>,<span class="string">'no-store'</span>); <span class="comment">// 不走缓存 而且缓存里没有</span></span><br></pre></td></tr></table></figure>

<h4 id="对比缓存"><a href="#对比缓存" class="headerlink" title="对比缓存"></a>对比缓存</h4><p><img src="https://jiafei2333.github.io/html/images/cache-4.png" alt></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">cache(filePath,req,res,statObj)&#123;<span class="comment">// 协商缓存/ 对比缓存</span></span><br><span class="line">	<span class="comment">// statObj.ctime 是一个时间类型</span></span><br><span class="line">    <span class="keyword">let</span> lasModified = statObj.ctime.toGMTString();</span><br><span class="line">    res.setHeader(<span class="string">'Last-Modified'</span>,lasModified);</span><br><span class="line">    <span class="keyword">let</span> ifModifiedSince = req.headers[<span class="string">'if-modified-since'</span>];</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">if</span>(ifModifiedSince) &#123;</span><br><span class="line">        <span class="keyword">if</span>(ifModifiedSince !== lasModified)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">sendFile(filePath,req,res,statObj)&#123; <span class="comment">// 创建流返回去就好了</span></span><br><span class="line">    <span class="comment">// 缓存</span></span><br><span class="line">    res.setHeader(<span class="string">'Cache-Control'</span>,<span class="string">'no-cache'</span>); <span class="comment">// 每次都访问服务器 但是缓存</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对比缓存    对比缓存这里将其他缓存设置的第一条打开</span></span><br><span class="line">    <span class="keyword">let</span> cache = <span class="keyword">this</span>.cache(filePath,req,res,statObj);</span><br><span class="line">    <span class="keyword">if</span>(cache)&#123; <span class="comment">// 有缓存 直接找缓存里的内容就好了</span></span><br><span class="line">        res.statusCode = <span class="number">304</span>;</span><br><span class="line">        <span class="keyword">return</span> res.end();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> flag = <span class="keyword">this</span>.gzip(filePath,req,res,statObj);</span><br><span class="line">    <span class="keyword">let</span> t = <span class="built_in">require</span>(<span class="string">"mime"</span>).getType(filePath) || <span class="string">'text/plain'</span>;</span><br><span class="line">    res.setHeader(<span class="string">"Content-Type"</span>, t + <span class="string">";charset=utf-8"</span>);</span><br><span class="line">    <span class="keyword">if</span>( !flag)&#123;</span><br><span class="line">        fs.createReadStream(filePath).pipe(res); </span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        fs.createReadStream(filePath).pipe(flag).pipe(res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第一次刷新 res里有这个时间戳</p>
<p><img src="https://jiafei2333.github.io/html/images/cache-5.png" alt></p>
<p>第二次刷新请求，请求头带了这个时间戳</p>
<p><img src="https://jiafei2333.github.io/html/images/cache-6.png" alt></p>
<p>并且这时的状态码是304</p>
<ul>
<li>存在的问题<br>1) 文件可能没发生变化 但是修改时间变化了 （写入新的数据然后又撤销了，这样文件没有被修改，但是修改的那个时间戳改变了）<br>2) 精确的时间不准确 会导致问题 同一时间内改了很多次<br>3) cdn （静态资源通过cdn cdn分发的时间不一样也会导致缓存失效）</li>
</ul>
<p>解决方式 ： 指纹</p>
<h4 id="指纹"><a href="#指纹" class="headerlink" title="指纹"></a>指纹</h4><p>什么叫指纹：把整个内容进行md5，md5之后 内容只要有一点发生改变，md5戳也会发生变化<br>新建 2.crypto.js</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 2.crypto.js</span></span><br><span class="line"><span class="keyword">const</span> crypto = <span class="built_in">require</span>(<span class="string">'crypto'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 摘要算法   md5不叫加密算法，因为它不可逆</span></span><br><span class="line"><span class="comment">// md5特点：</span></span><br><span class="line"><span class="comment">// 1）不可逆</span></span><br><span class="line"><span class="comment">// 2) 相同内容 摘要的结果相同，有一点不同出来的结果完全不同</span></span><br><span class="line"><span class="comment">// 3) 摘要的结果长度相同</span></span><br><span class="line"><span class="keyword">let</span> r = crypto.createHash(<span class="string">'md5'</span>).update(<span class="string">'1234'</span>).update(<span class="string">'56'</span>).digest(<span class="string">'base64'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(r); <span class="comment">// 4QrcOUm6Wau+VuBX8g+IPg==</span></span><br><span class="line"><span class="comment">//https://cmd5.com/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// sha1 sha256 加盐算法</span></span><br><span class="line"><span class="keyword">const</span> crypto = <span class="built_in">require</span>(<span class="string">'crypto'</span>);</span><br><span class="line"><span class="keyword">let</span> r = crypto.createHmac(<span class="string">'sha1'</span>,<span class="string">'key12345...'</span>).update(<span class="string">'123456'</span>).digest(<span class="string">'base64'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(r); <span class="comment">// GEVfizKc3KFLfxH1UUlazNNMPlk=</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// server.js</span></span><br><span class="line">cache(filePath,req,res,statObj)&#123;</span><br><span class="line">    <span class="comment">// 解决方式 ： 指纹</span></span><br><span class="line">    <span class="keyword">let</span> Etag = crypto.createHash(<span class="string">'md5'</span>).update(fs.readFileSync(filePath)).digest(<span class="string">'base64'</span>);</span><br><span class="line">    res.setHeader(<span class="string">'Etag'</span>, Etag); <span class="comment">// 真的Etag可能只是文件的某一部分</span></span><br><span class="line">    <span class="keyword">let</span> ifNoneMatch = req.headers[<span class="string">'if-none-match'</span>];</span><br><span class="line">    <span class="keyword">if</span>(ifNoneMatch) &#123;</span><br><span class="line">        <span class="keyword">if</span>(ifNoneMatch !== Etag)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 我们可以计算文件md5戳 文件如果很大会读取前20个  slice(0,20)</span></span><br></pre></td></tr></table></figure>

<p>完整的server.js</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// server.js</span></span><br><span class="line"><span class="keyword">import</span> http <span class="keyword">from</span> <span class="string">'http'</span>;</span><br><span class="line"><span class="keyword">import</span> fs, &#123; readFileSync &#125; <span class="keyword">from</span> <span class="string">'fs'</span>;</span><br><span class="line"><span class="keyword">import</span> path <span class="keyword">from</span> <span class="string">'path'</span>;</span><br><span class="line"><span class="keyword">import</span> util <span class="keyword">from</span> <span class="string">'util'</span>;</span><br><span class="line"><span class="keyword">import</span> url <span class="keyword">from</span> <span class="string">'url'</span>;</span><br><span class="line"><span class="keyword">import</span> zlib  <span class="keyword">from</span> <span class="string">'zlib'</span>;</span><br><span class="line"><span class="keyword">import</span> crypto <span class="keyword">from</span> <span class="string">'crypto'</span>;</span><br><span class="line"><span class="keyword">let</span> &#123; readFile,writeFile,readdir,stat &#125;  = fs.promises</span><br><span class="line"><span class="comment">// 第三方 </span></span><br><span class="line"><span class="keyword">import</span> mime <span class="keyword">from</span> <span class="string">'mime'</span>;</span><br><span class="line"><span class="keyword">import</span> chalk <span class="keyword">from</span> <span class="string">'chalk'</span>; <span class="comment">// 变颜色</span></span><br><span class="line"><span class="keyword">import</span> ejs <span class="keyword">from</span> <span class="string">'ejs'</span>;</span><br><span class="line"><span class="comment">// npm i mime chalk ejs</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> template = fs.readFileSync(path.resolve(__dirname,<span class="string">'../template.html'</span>),<span class="string">'utf8'</span>);</span><br><span class="line"><span class="comment">// console.log(template);</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Server</span></span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(config)&#123;</span><br><span class="line">        <span class="keyword">this</span>.port = config.port;</span><br><span class="line">        <span class="keyword">this</span>.template = template; <span class="comment">// 将template属性放到实例上 可以保证属性永远可以通过this来获取，不被参数覆盖掉</span></span><br><span class="line">        <span class="comment">// console.log(config);</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">async</span> handleRequest(req,res)&#123;</span><br><span class="line">        <span class="keyword">let</span> &#123;pathname&#125; = url.parse(req.url, <span class="literal">true</span>);</span><br><span class="line">        <span class="comment">// 解析中文路径</span></span><br><span class="line">        pathname = <span class="built_in">decodeURIComponent</span>(pathname); <span class="comment">// 如果是中文路径 浏览器会把中文转化成十六进制  decodeURIComponent('你好')；  可以先把这行注释了看看能否访问‘你好’ 文件夹</span></span><br><span class="line">        <span class="comment">// let filePath = path.join(__dirname, pathname);</span></span><br><span class="line">        <span class="comment">// 这里面启动server时 引用的是dist下的main __dirname 打印 /Users/jiafei/Desktop/Architecture-Course/17.http/dist  ，__dirname指当前执行文件的路径，到时候打包到dist文件下， 而这个服务是启动当前文件执行的目录 应该就是17.http目录</span></span><br><span class="line">        <span class="keyword">let</span> filePath = path.join(process.cwd(), pathname);  <span class="comment">// 找到当前执行命令的目录</span></span><br><span class="line">        <span class="comment">// 找到当前执行命令的目录,并执行，而不是当前文件所在的文件夹目录</span></span><br><span class="line">        <span class="comment">// console.log(filePath); // /Users/jiafei/Desktop/Architecture-Course/17.http/</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> statObj = <span class="keyword">await</span> stat(filePath);</span><br><span class="line">            <span class="keyword">if</span>(statObj.isDirectory())&#123;</span><br><span class="line">                <span class="comment">// console.log('是目录');</span></span><br><span class="line">                <span class="comment">// 我需要判断是不是目录</span></span><br><span class="line">                <span class="comment">// 如果是目录 需要读取目录下的文件</span></span><br><span class="line">                <span class="keyword">let</span> dirs = <span class="keyword">await</span> readdir(filePath);</span><br><span class="line">                <span class="built_in">console</span>.log(dirs);</span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                [ '.babelrc',</span></span><br><span class="line"><span class="comment">                    '1.md',</span></span><br><span class="line"><span class="comment">                    'bin',</span></span><br><span class="line"><span class="comment">                    'dist',</span></span><br><span class="line"><span class="comment">                    'http-1.md',</span></span><br><span class="line"><span class="comment">                    'http-2.md',</span></span><br><span class="line"><span class="comment">                    'http-3.md',</span></span><br><span class="line"><span class="comment">                    'node_modules',</span></span><br><span class="line"><span class="comment">                    'package-lock.json',</span></span><br><span class="line"><span class="comment">                    'package.json',</span></span><br><span class="line"><span class="comment">                    'src' ]</span></span><br><span class="line"><span class="comment">                */</span></span><br><span class="line">               <span class="comment">// 现在需要将这些列表数据渲染成一个页面展示给前端  这里用到ejs 新建template.html 这里将静态资源放在了跟目录下</span></span><br><span class="line">                <span class="comment">// 我需要访问文件的时候 增加他当前的路径，如果是/ 就不增加了，否则将路径拼在文件前面</span></span><br><span class="line">                <span class="keyword">let</span> templateStr = ejs.render(<span class="keyword">this</span>.template,&#123;</span><br><span class="line">                    dirs,</span><br><span class="line">                    path:pathname === <span class="string">'/'</span>?<span class="string">''</span>:pathname</span><br><span class="line">                &#125;); <span class="comment">// 返回的是渲染好的字符串</span></span><br><span class="line">                res.setHeader(<span class="string">'Content-Type'</span>,<span class="string">'text/html;charset=utf-8'</span>)</span><br><span class="line">                res.end(templateStr);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">this</span>.sendFile(filePath,req,res,statObj); <span class="comment">// 浏览器请求  localhost:8080/http-1.md</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">            <span class="keyword">this</span>.sendError(error,req,res);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果文件很大 在服务器上压缩会有性能问题</span></span><br><span class="line">    gzip(filePath,req,res,statObj)&#123; <span class="comment">// 现在压缩从4.5k =&gt; 2.6k</span></span><br><span class="line">        <span class="comment">// 查看一下当前是否支持压缩</span></span><br><span class="line">        <span class="keyword">let</span> encoding = req.headers[<span class="string">'accept-encoding'</span>];</span><br><span class="line">        <span class="keyword">if</span>(encoding)&#123;  <span class="comment">// 查看一下是否支持gzip 、 deflate</span></span><br><span class="line">            <span class="keyword">if</span>(encoding.match(<span class="regexp">/gzip/</span>))&#123;</span><br><span class="line">                res.setHeader(<span class="string">"Content-Encoding"</span>, <span class="string">'gzip'</span>); <span class="comment">// 告诉浏览器是用什么压缩的</span></span><br><span class="line">                <span class="keyword">return</span> zlib.createGzip();</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(encoding.match(<span class="regexp">/deflate/</span>))&#123;</span><br><span class="line">                res.setHeader(<span class="string">"Content-Encoding"</span>, <span class="string">'deflate'</span>);</span><br><span class="line">                <span class="keyword">return</span> zlib.createDeflate();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cache(filePath,req,res,statObj)&#123;<span class="comment">// 协商缓存/ 对比缓存</span></span><br><span class="line">        <span class="comment">// 存在的问题</span></span><br><span class="line">        <span class="comment">// 1) 文件可能没发生变化 但是修改时间变化了 （写入新的数据然后又撤销了，这样文件没有被修改，但是修改的那个时间戳改变了）</span></span><br><span class="line">        <span class="comment">// 2) 精确的时间不准确 会导致问题 同一时间内改了很多次</span></span><br><span class="line">        <span class="comment">// 3) cdn （静态资源通过cdn cdn分发的时间不一样也会导致缓存失效）</span></span><br><span class="line">        <span class="comment">// 解决方式 ： 指纹</span></span><br><span class="line">        <span class="comment">// statObj.ctime 是一个时间类型</span></span><br><span class="line">        <span class="keyword">let</span> lasModified = statObj.ctime.toGMTString();</span><br><span class="line">        <span class="keyword">let</span> Etag = crypto.createHash(<span class="string">'md5'</span>).update(fs.readFileSync(filePath)).digest(<span class="string">'base64'</span>);</span><br><span class="line">        res.setHeader(<span class="string">'Last-Modified'</span>,lasModified);</span><br><span class="line">        res.setHeader(<span class="string">'Etag'</span>, Etag); <span class="comment">// 真真的Etag可能只是文件的某一部分</span></span><br><span class="line">        <span class="keyword">let</span> ifModifiedSince = req.headers[<span class="string">'if-modified-since'</span>];</span><br><span class="line">        <span class="keyword">let</span> ifNoneMatch = req.headers[<span class="string">'if-none-match'</span>];</span><br><span class="line">        <span class="comment">// if(ifNoneMatch) &#123;</span></span><br><span class="line">        <span class="comment">//     if(ifNoneMatch !== Etag)&#123;</span></span><br><span class="line">        <span class="comment">//         return false</span></span><br><span class="line">        <span class="comment">//     &#125;</span></span><br><span class="line">        <span class="comment">// &#125;else&#123;</span></span><br><span class="line">        <span class="comment">//     return false;</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        <span class="comment">// if(ifModifiedSince) &#123;</span></span><br><span class="line">        <span class="comment">//     if(ifModifiedSince !== lasModified)&#123;</span></span><br><span class="line">        <span class="comment">//         return false</span></span><br><span class="line">        <span class="comment">//     &#125;</span></span><br><span class="line">        <span class="comment">// &#125;else&#123;</span></span><br><span class="line">        <span class="comment">//     return false;</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        <span class="comment">// 对比缓存+指纹   有一个不满足就返回false</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(ifNoneMatch &amp;&amp; ifModifiedSince)&#123;</span><br><span class="line">            <span class="keyword">if</span>(ifNoneMatch !== Etag || ifModifiedSince !== lasModified)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 指纹 什么叫指纹：把整个内容进行md5，md5之后 内容只要有一点发生改变，md5戳也会发生变化</span></span><br><span class="line">        <span class="comment">// 如果指纹变了 就不是一个人 md5   这里新建 2.crypto.js</span></span><br><span class="line">        <span class="comment">// 我们可以计算文件md5戳 文件如果很大会读取前20个  slice(0,20)</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    sendFile(filePath,req,res,statObj)&#123; <span class="comment">// 创建流返回去就好了</span></span><br><span class="line">        <span class="comment">// 缓存</span></span><br><span class="line">        <span class="comment">// 强制缓存：</span></span><br><span class="line">        <span class="comment">// 表示10秒内不要再访问服务器</span></span><br><span class="line">        res.setHeader(<span class="string">'Cache-Control'</span>,<span class="string">'max-age=10'</span>); </span><br><span class="line">        <span class="comment">// // 老版本写法 新版本也可以生效 如果两个都写 采用Cache-Control</span></span><br><span class="line">        <span class="comment">// res.setHeader('Expires',new Date(Date.now()+10*1000).toGMTString());</span></span><br><span class="line">        <span class="comment">// // 现在看看效果 访问 http://127.0.0.1:8080/1.html</span></span><br><span class="line">        <span class="comment">// console.log('打印~~', filePath); // 如图’浏览器缓存了css‘ 缓存了css</span></span><br><span class="line">        <span class="comment">// 但是这里html还是走的服务器   如果设置强制缓存 首页是不会缓存的  所以首页一定会发起请求，如果首页设置了强制缓存，它包换的资源则会走缓存</span></span><br><span class="line">        <span class="comment">// 如图'css走的缓存'</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 其他的设置</span></span><br><span class="line">        <span class="comment">//res.setHeader('Cache-Control','no-cache'); // 每次都访问服务器 但是缓存</span></span><br><span class="line">        <span class="comment">// res.setHeader('Cache-Control','no-store'); // 不走缓存 而且缓存里没有</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 对比缓存 这里新建副本3    对比缓存这里将其他缓存设置的第一条打开</span></span><br><span class="line">        <span class="keyword">let</span> cache = <span class="keyword">this</span>.cache(filePath,req,res,statObj);</span><br><span class="line">        <span class="keyword">if</span>(cache)&#123; <span class="comment">// 有缓存 直接找缓存里的内容就好了</span></span><br><span class="line">            res.statusCode = <span class="number">304</span>;</span><br><span class="line">            <span class="keyword">return</span> res.end();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在文件发送过程中 如果浏览器支持压缩 我需要对浏览器的内容先压缩 再返回</span></span><br><span class="line">        <span class="keyword">let</span> flag = <span class="keyword">this</span>.gzip(filePath,req,res,statObj);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> t = <span class="built_in">require</span>(<span class="string">"mime"</span>).getType(filePath) || <span class="string">'text/plain'</span>; <span class="comment">// 这里加了一个默认的文本类型   如果打开的是www  这个没有后缀，mime就不能获取类型了</span></span><br><span class="line">        res.setHeader(<span class="string">"Content-Type"</span>, t + <span class="string">";charset=utf-8"</span>);</span><br><span class="line">        <span class="keyword">if</span>( !flag)&#123;</span><br><span class="line">            fs.createReadStream(filePath).pipe(res); <span class="comment">// 以前是可读流导入到可写流里</span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            fs.createReadStream(filePath).pipe(flag).pipe(res);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    sendError(error,req,res)&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(e);</span><br><span class="line">        res.statusCode = <span class="number">404</span>;</span><br><span class="line">        res.end(<span class="string">'Not Found'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    start()&#123;</span><br><span class="line">        <span class="keyword">let</span> server = http.createServer(<span class="keyword">this</span>.handleRequest.bind(<span class="keyword">this</span>));</span><br><span class="line">        server.listen(<span class="keyword">this</span>.port, ()=&gt;&#123;</span><br><span class="line">            <span class="comment">// 这一块的参数展现形式包括颜色  参考http-server 图1</span></span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;chalk.yellow(<span class="string">'Starting up http-server, serving'</span>)&#125;</span> <span class="subst">$&#123;chalk.blue(<span class="string">'./'</span>)&#125;</span></span></span><br><span class="line"><span class="string">            Available on:</span></span><br><span class="line"><span class="string">              http://127.0.0.1:<span class="subst">$&#123;chalk.red(<span class="string">'8080'</span>)&#125;</span></span></span><br><span class="line"><span class="string">              http://192.168.0.100::<span class="subst">$&#123;chalk.yellow(<span class="string">'8080'</span>)&#125;</span></span></span><br><span class="line"><span class="string">            Hit CTRL-C to stop the server`</span>);</span><br><span class="line">            <span class="comment">// 现在已经启动了这服务 现在需要能够访问   =&gt; handleRequest()</span></span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Server;</span><br></pre></td></tr></table></figure>

<p>这里测试这个服务的时候 千万别忘了这个是es6语法 要在node中执行需要转化成es5 转化的服务要开起来 npm run babel:watch</p>
<blockquote>
<p>Tips<br>__dirname 指当前执行文件的目录<br>process.cwd() 指当前执行命令的目录</p>
</blockquote>
]]></content>
      <categories>
        <category>Nodejs</category>
      </categories>
      <tags>
        <tag>Nodejs</tag>
        <tag>HTTP</tag>
      </tags>
  </entry>
  <entry>
    <title>正则</title>
    <url>/2019/09/29/RegExp/</url>
    <content><![CDATA[<h3 id="test"><a href="#test" class="headerlink" title="test"></a>test</h3><blockquote>
<p>test() 方法执行一个检索，用来查看正则表达式与指定的字符串是否匹配。返回 true 或 false</p>
</blockquote>
<a id="more"></a>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 用法：</span><br><span class="line">regexObj.test(str)</span><br></pre></td></tr></table></figure>

<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>1】</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">'a=1&amp;b=2'</span>; <span class="comment">//如果是这样的字符串，也可以用下面的正则取到</span></span><br><span class="line">str.replace(<span class="regexp">/([^=&amp;])=([^&amp;=])/g</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">arguments</span>[<span class="number">1</span>],<span class="built_in">arguments</span>[<span class="number">2</span>])</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>2】</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// /a/123</span></span><br><span class="line">正则 /\/a\/\d+<span class="regexp">/</span></span><br></pre></td></tr></table></figure>

<p>3】<br>将 <code>&lt;span class=&quot;proofreadSignClass</code> 的span标签匹配出来</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">'&lt;p style="word-spacing: 0.05em; line-height: 1.6em; margin-top: 1.2em; margin-bottom: -1.2em; padding-bottom: 1.2em; position: relative; z-index: 1; color: rgb(48, 68, 85); font-family: &amp;quot;Source Sans Pro&amp;quot;, &amp;quot;Helvetica Neue&amp;quot;, Arial, sans-serif;"&gt;&amp;#8203;&lt;span style="color: rgb(0, 0, 0); font-family: 宋体; font-size: 14px; caret-color: red;"&gt;&lt;span class="proofreadSignClass errorWordMark" style="border:2px solid red;color:#F39C12;" title="同音字错误：中华人名共和国→中华人民共和国"&gt;中华人名共和国&lt;/span&gt;&lt;span class="proofreadSignClass errorWordMark" style="border:2px solid red;color:#F39C12;" title="标点符号错误：,→，"&gt;,&lt;/span&gt;神经。&lt;span style="color: rgb(48, 68, 85); font-family: &amp;quot;Source Sans Pro&amp;quot;, &amp;quot;Helvetica Neue&amp;quot;, Arial, sans-serif; word-spacing: 0.8px;"&gt;&lt;/span&gt;&lt;span style="word-spacing: 0.8px; caret-color: red; font-family: 宋体; font-size: 14px;"&gt;&lt;span class="proofreadSignClass errorWordMark" style="border:2px solid red;color:#F39C12;" title="同音字错误：中华人名共和国→中华人民共和国"&gt;中华人名共和国&lt;/span&gt;&lt;span class="proofreadSignClass errorWordMark" style="border:2px solid red;color:#F39C12;" title="标点符号错误：,→，"&gt;,&lt;/span&gt;神经。&lt;/span&gt;&lt;span style="color: rgb(48, 68, 85); font-family: &amp;quot;Source Sans Pro&amp;quot;, &amp;quot;Helvetica Neue&amp;quot;, Arial, sans-serif; word-spacing: 0.8px;"&gt;&lt;/span&gt;&lt;span style="word-spacing: 0.8px; caret-color: red; font-family: 宋体; font-size: 14px;"&gt;&lt;span class="proofreadSignClass errorWordMark" style="border:2px solid red;color:#F39C12;" title="同音字错误：中华人名共和国→中华人民共和国"&gt;中华人名共和国&lt;/span&gt;&lt;span class="proofreadSignClass errorWordMark" style="border:2px solid red;color:#F39C12;" title="标点符号错误：,→，"&gt;,&lt;/span&gt;神经。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> proofreadHtml = <span class="function">(<span class="params">str</span>) =&gt;</span>&#123;</span><br><span class="line">  <span class="keyword">let</span> reg = str.match(<span class="regexp">/(&lt;span class="proofreadSignClass[^&gt;]*&gt;)([\s\S]*?)(&lt;\/span&gt;)/ig</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(reg, reg.length);</span><br><span class="line">&#125;</span><br><span class="line">proofreadHtml(str);</span><br></pre></td></tr></table></figure>

<p>结果</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">[ <span class="string">'&lt;span class="proofreadSignClass errorWordMark" style="border:2px solid red;color:#F39C12;" title="同音字错误：中华人名共和国→中华人民共和国"&gt;中华人名共和国&lt;/span&gt;'</span>,</span><br><span class="line">  <span class="string">'&lt;span class="proofreadSignClass errorWordMark" style="border:2px solid red;color:#F39C12;" title="标点符号错误：,→，"&gt;,&lt;/span&gt;'</span>,</span><br><span class="line">  <span class="string">'&lt;span class="proofreadSignClass errorWordMark" style="border:2px solid red;color:#F39C12;" title="同音字错误：中华人名共和国→中华人民共和国"&gt;中华人名共和国&lt;/span&gt;'</span>,</span><br><span class="line">  <span class="string">'&lt;span class="proofreadSignClass errorWordMark" style="border:2px solid red;color:#F39C12;" title="标点符号错误：,→，"&gt;,&lt;/span&gt;'</span>,</span><br><span class="line">  <span class="string">'&lt;span class="proofreadSignClass errorWordMark" style="border:2px solid red;color:#F39C12;" title="同音字错误：中华人名共和国→中华人民共和国"&gt;中华人名共和国&lt;/span&gt;'</span>,</span><br><span class="line">  <span class="string">'&lt;span class="proofreadSignClass errorWordMark" style="border:2px solid red;color:#F39C12;" title="标点符号错误：,→，"&gt;,&lt;/span&gt;'</span> ]</span><br></pre></td></tr></table></figure>

<p>[\s\S]是完全通配的意思，\s是指空白，包括空格、换行、tab缩进等所有的空白，而\S刚好相反<br>这样一正一反下来，就表示所有的字符，完全的，一字不漏的。<br>另外，[]这个符号，表示在它里面包含的单个字符不限顺序的出现，比如下面的正则：<br>[ace]*<br>这表示，只要出现a/c/e这三个任意的字母，都会被匹配<br>[\s]表示，只要出现空白就匹配<br>[\S]表示，非空白就匹配<br>那么它们的组合，表示所有的都匹配，与它相对应的，有[\w\W]等，意义完全相同、另外要说的一点是，为什么有”.”这个通配符了，还要这样的用法。<br>其实，[\s\S]  [\w\W]这样的用法，比较”.”所匹配的还要多，因为”.”是不会匹配换行的，所有出现有换行匹配的时候，人们就习惯 使用[\s\S]或者[\w\W]这样的完全通配模式。</p>
]]></content>
      <categories>
        <category>js基础</category>
      </categories>
      <tags>
        <tag>正则</tag>
      </tags>
  </entry>
  <entry>
    <title>Nodejs http （一）</title>
    <url>/2019/09/29/Node-http-1/</url>
    <content><![CDATA[<h3 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h3><h4 id="Http-状态码"><a href="#Http-状态码" class="headerlink" title="Http 状态码"></a>Http 状态码</h4><ul>
<li>101 websocket 双向通信</li>
<li>200 成功 204 没有响应体 206 断点续传</li>
<li>301(永久重定向) 302(临时重向) 304（缓存）只能服务端设置</li>
<li>401 （没登录没有权限） 403 （登录了没权限） 404  405（请求方法不存在、不支持，比如说发请求，服务器只支持get、post，但是我发了一个delete）</li>
<li>502 负载均衡挂了  500服务器挂</li>
</ul>
<h4 id="请求方法-RestfulApi"><a href="#请求方法-RestfulApi" class="headerlink" title="请求方法 RestfulApi"></a>请求方法 RestfulApi</h4><p>根据不同的动作 做对应的处理</p>
<ul>
<li>get 获取资源 </li>
<li>post 新增资源 </li>
<li>put 上传文件  修改</li>
<li>delete  删除资源</li>
<li>options 跨域出现 （复杂请求时出现） 只是get / post 都是简单请求 + 自定义的header</li>
</ul>
<h4 id="传输数据"><a href="#传输数据" class="headerlink" title="传输数据"></a>传输数据</h4><ul>
<li><p>请求行 url</p>
</li>
<li><p>请求头 自定header</p>
</li>
<li><p>请求体 提交的数据</p>
</li>
<li><p>响应行 状态码</p>
</li>
<li><p>响应头 可以自定义</p>
</li>
<li><p>响应体 返还给浏览器的结果</p>
</li>
</ul>
<h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><blockquote>
<p>通过node实现一个http服务，都是通过核心模块提供（http模块）</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 服务器要有特定的ip 和端口号</span></span><br><span class="line"><span class="keyword">let</span> server = http.createServer();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 开启一个端口号</span></span><br><span class="line">server.listen(<span class="number">3000</span>, ()=&gt;&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'server start 3000'</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>每次服务端代码发生变化 都需要重启服务<br>可以安装nodemon  node的监视器 监视文件变化的</p>
<blockquote>
<p>sudo npm install nodemon -g    使用：  nodemon 文件名（可以增加配置文件）</p>
</blockquote>
<a id="more"></a>

<h3 id="server"><a href="#server" class="headerlink" title="server"></a>server</h3><p>新建文件 1.http.js</p>
<h5 id="如果端口被占用了-自动-1"><a href="#如果端口被占用了-自动-1" class="headerlink" title="如果端口被占用了 自动+ 1"></a>如果端口被占用了 自动+ 1</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line"><span class="keyword">let</span> server = http.createServer();</span><br><span class="line"><span class="keyword">let</span> port = <span class="number">3000</span>;</span><br><span class="line">server.listen(port, ()=&gt;&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'server start '</span> + port);</span><br><span class="line">&#125;);</span><br><span class="line">server.on(<span class="string">'error'</span>, (err) =&gt; &#123;</span><br><span class="line">    <span class="comment">// console.log(err);</span></span><br><span class="line">    <span class="keyword">if</span>(err.errno === <span class="string">'EADDRINUSE'</span>)&#123;</span><br><span class="line">        server.listen( ++port);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h5 id="图解"><a href="#图解" class="headerlink" title="图解"></a>图解</h5><p><img src="https://jiafei2333.github.io/html/images/HTTP-req.png" alt title="数据传输"></p>
<h5 id="如果别人请求我，我需要去解析请求"><a href="#如果别人请求我，我需要去解析请求" class="headerlink" title="如果别人请求我，我需要去解析请求"></a>如果别人请求我，我需要去解析请求</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line"><span class="keyword">const</span> url = <span class="built_in">require</span>(<span class="string">'url'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> server = http.createServer();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 监听请求事件</span></span><br><span class="line">server.on(<span class="string">'request'</span>, (req,res)=&gt;&#123;</span><br><span class="line">    <span class="comment">// req 代表的是客户端</span></span><br><span class="line">    <span class="comment">// res 代表的是服务端</span></span><br><span class="line">    <span class="comment">// 1)请求行   浏览器访问localhost:3000, nodemon运行的命令行里就会console.log出GET（我现在是服务端，所以nodemon就是服务端在接收数据，浏览器运行就是客户端在发起请求，所以现在每次需要接收到东西，都需要浏览器发起请求）</span></span><br><span class="line">    <span class="built_in">console</span>.log(req.method); <span class="comment">// GET 方法名大写</span></span><br><span class="line">    <span class="built_in">console</span>.log(req.url); <span class="comment">// 请求路径   /  表示首页 url不包含# hash</span></span><br><span class="line">    <span class="keyword">let</span> &#123;pathname, query&#125; = url.parse(req.url, <span class="literal">true</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(pathname,query);</span><br><span class="line">    <span class="comment">// 2) 请求头</span></span><br><span class="line">    <span class="built_in">console</span>.log(req.headers); <span class="comment">// 取header都是小写</span></span><br><span class="line">    <span class="comment">// 3) 请求体</span></span><br><span class="line">    <span class="keyword">let</span> arr = [];</span><br><span class="line">    req.on(<span class="string">'data'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">chunk</span>) </span>&#123; <span class="comment">// data方法不一定触发，如果是get请求就没有请求体  流的原理 push(null) ,然后走end方法</span></span><br><span class="line">        arr.push(chunk);</span><br><span class="line">    &#125;);</span><br><span class="line">    req.on(<span class="string">'end'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="comment">// end方法一定触发</span></span><br><span class="line">        <span class="built_in">console</span>.log(Buffer.concat(arr).toString());</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'end'</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">// 这里用post请求可以 curl -v -X POST --data a=1 http://localhost:3000,运行，nodemon命令行就能打印出 a=1这个请求体</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 响应行 头 体</span></span><br><span class="line">    res.statusCode = <span class="number">404</span>; <span class="comment">// 响应状态码</span></span><br><span class="line">    <span class="comment">// res.setHeader('Content-Length', '1'); // 返回内容的长度 不写注释默然返回全部会自动计算个数</span></span><br><span class="line">    <span class="comment">//res.end('end'); // 可写流原理 end方法里面有数据会调write写入，然后再关闭，这里和write('写入数据'); end(); 这样是一样的</span></span><br><span class="line">    <span class="comment">// res.end('结束');// 直接写中文会乱码 如下</span></span><br><span class="line">    res.setHeader(<span class="string">'Content-Type'</span>,<span class="string">'text/plain;charset=utf-8'</span>); </span><br><span class="line">    <span class="comment">// 百度 Content-Type对应表，其中  文本 .txt  text/plain    .js application/x-javascript   .html text/html  后面再加上编码charset=utf-8 utf-8要加-不然ie不兼容</span></span><br><span class="line">    <span class="comment">// res.end('结束');</span></span><br><span class="line">    res.end(<span class="string">'结束'</span>);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> port = <span class="number">3000</span>;</span><br><span class="line">server.listen(port, ()=&gt;&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'server start '</span> + port);</span><br><span class="line">&#125;);</span><br><span class="line">server.on(<span class="string">'error'</span>, (err) =&gt; &#123;</span><br><span class="line">    <span class="comment">// console.log(err);</span></span><br><span class="line">    <span class="keyword">if</span>(err.errno === <span class="string">'EADDRINUSE'</span>)&#123;</span><br><span class="line">        server.listen( ++port);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 一个完整的url</span><br><span class="line">const requestUrl = `http://username:password@www.baidu.com:80/s?offset=1&amp;limit=30#app`</span><br><span class="line"></span><br><span class="line">let result = url.parse(requestUrl,true);</span><br><span class="line">console.log(result)</span><br><span class="line">&#123;</span><br><span class="line">    protocol: &apos;http:&apos;,</span><br><span class="line">    slashes: true,  是否有/</span><br><span class="line">    auth: &apos;username:password&apos;, 用户信息</span><br><span class="line">    host: &apos;www.baidu.com:80&apos;,</span><br><span class="line">    port: &apos;80&apos;,</span><br><span class="line">    hostname: &apos;www.baidu.com&apos;, // 主机名</span><br><span class="line">    hash: &apos;#app&apos;,</span><br><span class="line">    search: &apos;?offset=1&amp;limit=30&apos;,</span><br><span class="line">    query: [Object: null prototype] &#123; offset: &apos;1&apos;, limit: &apos;30&apos; &#125;, // line4 true</span><br><span class="line">    query: &apos;offset=1&amp;limit=30&apos;, // 不填输出这个</span><br><span class="line">    pathname: &apos;/s&apos;,  请求路径 资源路由</span><br><span class="line">    path: &apos;/s?offset=1&amp;limit=30&apos;,</span><br><span class="line">    href:</span><br><span class="line">     &apos;http://username:password@www.baidu.com:80/s?offset=1&amp;limit=30#app&apos; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="client"><a href="#client" class="headerlink" title="client"></a>client</h3><p>新建文件 2.client.js<br>中间层<br>这里相当于是服务端，向1.http.js中的 localhost:3000发送请求</p>
<h3 id="request"><a href="#request" class="headerlink" title="request"></a>request</h3><h4 id="get"><a href="#get" class="headerlink" title="get"></a>get</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>)</span><br><span class="line">http.get(<span class="string">'http://localhost:3000'</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;<span class="comment">// 这样发送请求是不会有跨域问题的，因为这是服务器</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'发送成功'</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>Run Code运行 发送成功 在3000端口看到接收请求<br>get方法没有请求体</p>
<h4 id="request-发送请求体"><a href="#request-发送请求体" class="headerlink" title="request 发送请求体"></a>request 发送请求体</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1.http.js</span></span><br><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line"><span class="keyword">const</span> url = <span class="built_in">require</span>(<span class="string">'url'</span>);</span><br><span class="line"><span class="keyword">let</span> server = http.createServer();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 监听请求事件</span></span><br><span class="line">server.on(<span class="string">'request'</span>, (req,res)=&gt;&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(req.method); <span class="comment">// POST</span></span><br><span class="line">    <span class="built_in">console</span>.log(req.url); <span class="comment">// /</span></span><br><span class="line">    <span class="keyword">let</span> &#123;pathname, query&#125; = url.parse(req.url, <span class="literal">true</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(pathname,query); <span class="comment">// / [Object: null prototype] &#123;&#125;</span></span><br><span class="line">    <span class="built_in">console</span>.log(req.headers); <span class="comment">// &#123; host: 'localhost:3000', connection: 'close' &#125;</span></span><br><span class="line">    <span class="keyword">let</span> arr = [];</span><br><span class="line">    req.on(<span class="string">'data'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">chunk</span>) </span>&#123; </span><br><span class="line">        arr.push(chunk);</span><br><span class="line">    &#125;);</span><br><span class="line">    req.on(<span class="string">'end'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">        <span class="built_in">console</span>.log(Buffer.concat(arr).toString());</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'end'</span>);</span><br><span class="line">        res.statusCode = <span class="number">404</span>; </span><br><span class="line">        res.setHeader(<span class="string">'Content-Type'</span>,<span class="string">'text/plain;charset=utf-8'</span>);</span><br><span class="line">        res.end(Buffer.concat(arr)); <span class="comment">// 将你发给我的数据再发送给你，因为on 'data' 'end' 都是异步的，所以这里把line20-22放到end里面</span></span><br><span class="line">    &#125;);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> port = <span class="number">3000</span>;</span><br><span class="line">server.listen(port, ()=&gt;&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'server start '</span> + port);</span><br><span class="line">&#125;);</span><br><span class="line">server.on(<span class="string">'error'</span>, (err) =&gt; &#123;</span><br><span class="line">    <span class="comment">// console.log(err);</span></span><br><span class="line">    <span class="keyword">if</span>(err.errno === <span class="string">'EADDRINUSE'</span>)&#123;</span><br><span class="line">        server.listen( ++port);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1.client.js</span></span><br><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line"><span class="keyword">let</span> config =&#123;</span><br><span class="line">    port: <span class="number">3000</span>,</span><br><span class="line">    hostname: <span class="string">'localhost'</span>,</span><br><span class="line">    headers:&#123;</span><br><span class="line">        a: <span class="number">1</span></span><br><span class="line">    &#125;,</span><br><span class="line">    method: <span class="string">'POST'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 请求后 会将响应的结果放到函数中</span></span><br><span class="line"><span class="keyword">let</span> client = http.request(config, <span class="function"><span class="keyword">function</span>(<span class="params">res</span>) </span>&#123;</span><br><span class="line">    res.on(<span class="string">'data'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">chunk</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'接收到服务端返回的数据：'</span>, chunk.toString()); <span class="comment">// 接收到服务端返回的数据： a=2</span></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br><span class="line">client.end(<span class="string">'a=2'</span>);</span><br><span class="line"><span class="comment">// 或者 client.write(....);client.end();</span></span><br></pre></td></tr></table></figure>

<h3 id="数据传输"><a href="#数据传输" class="headerlink" title="数据传输"></a>数据传输</h3><blockquote>
<p>常见格式</p>
</blockquote>
<p>1) json字符串  {a:1}<br>2) 表单格式 a=1&amp;b=2  如test.form.html文件<br>3) 文件格式 图片 formData<br>4) 传递是字符串</p>
<p>所以需要告诉服务端传过去的数据类型，在header里设置</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1.client.js</span></span><br><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> config =&#123;</span><br><span class="line">    port: <span class="number">3000</span>,</span><br><span class="line">    hostname: <span class="string">'localhost'</span>,</span><br><span class="line">    headers:&#123;<span class="comment">// 请求头 规范</span></span><br><span class="line">        <span class="string">'Content-Type'</span>: <span class="string">'application/x-www-form-urlencoded'</span>, <span class="comment">// 表单格式</span></span><br><span class="line">        <span class="comment">// 'Content-Type': 'application/json'  json类型</span></span><br><span class="line">    &#125;,</span><br><span class="line">    method: <span class="string">'POST'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 请求后 会将响应的结果放到函数中</span></span><br><span class="line"><span class="keyword">let</span> client = http.request(config, <span class="function"><span class="keyword">function</span>(<span class="params">res</span>) </span>&#123;</span><br><span class="line">    res.on(<span class="string">'data'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">chunk</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'接收到服务端返回的数据：'</span>, chunk.toString());</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br><span class="line">client.end(<span class="string">'a=2'</span>); <span class="comment">// 写响应体 ajax的data数据</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1.server.js</span></span><br><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line"><span class="keyword">const</span> url = <span class="built_in">require</span>(<span class="string">'url'</span>);</span><br><span class="line"><span class="keyword">const</span> querystring = <span class="built_in">require</span>(<span class="string">'querystring'</span>); <span class="comment">// 查询字符串</span></span><br><span class="line"><span class="keyword">let</span> server = http.createServer();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 监听请求事件</span></span><br><span class="line">server.on(<span class="string">'request'</span>, (req,res)=&gt;&#123;</span><br><span class="line">    <span class="keyword">let</span> &#123;pathname, query&#125; = url.parse(req.url, <span class="literal">true</span>);</span><br><span class="line">    <span class="keyword">let</span> arr = [];</span><br><span class="line">    req.on(<span class="string">'data'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">chunk</span>) </span>&#123; </span><br><span class="line">        arr.push(chunk);</span><br><span class="line">    &#125;);</span><br><span class="line">    req.on(<span class="string">'end'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">        res.statusCode = <span class="number">404</span>; </span><br><span class="line">        res.setHeader(<span class="string">'Content-Type'</span>,<span class="string">'text/plain;charset=utf-8'</span>);</span><br><span class="line">        <span class="keyword">let</span> content = Buffer.concat(arr).toString();</span><br><span class="line">        <span class="keyword">let</span> type = req.headers[<span class="string">'content-type'</span>]</span><br><span class="line">        <span class="keyword">if</span>(type === <span class="string">'application/json'</span>)&#123;</span><br><span class="line">            <span class="keyword">let</span> obj = <span class="built_in">JSON</span>.parse(content)</span><br><span class="line">            <span class="keyword">return</span> res.end(obj.a+<span class="string">''</span>); <span class="comment">// 为了保证是个字符串加''</span></span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(type === <span class="string">'application/x-www-form-urlencoded'</span>)&#123;</span><br><span class="line">            <span class="comment">// 第二个参数 字段间的分隔符 第三个参数 是key value分隔符</span></span><br><span class="line">            <span class="keyword">let</span> obj = querystring.parse(content,<span class="string">'&amp;'</span>, <span class="string">'='</span>); <span class="comment">// 默认可以不传</span></span><br><span class="line">            <span class="keyword">return</span> res.end(obj.a+<span class="string">''</span>);</span><br><span class="line">			</span><br><span class="line">            <span class="comment">//  let str = 'a=1&amp;b=2'; //如果是这样的字符串，也可以用下面的正则取到</span></span><br><span class="line">            <span class="comment">//  str.replace(/([^=&amp;])=([^&amp;=])/g,function()&#123;</span></span><br><span class="line">            <span class="comment">//      console.log(arguments[1],arguments[2])</span></span><br><span class="line">            <span class="comment">//  &#125;)</span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123; <span class="comment">//  如果不支持的就默认返回</span></span><br><span class="line">            <span class="keyword">return</span> res.end(content);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> port = <span class="number">3000</span>;</span><br><span class="line">server.listen(port, ()=&gt;&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'server start '</span> + port);</span><br><span class="line">&#125;);</span><br><span class="line">server.on(<span class="string">'error'</span>, (err) =&gt; &#123;</span><br><span class="line">    <span class="comment">// console.log(err);</span></span><br><span class="line">    <span class="keyword">if</span>(err.errno === <span class="string">'EADDRINUSE'</span>)&#123;</span><br><span class="line">        server.listen( ++port);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h4 id="表单格式"><a href="#表单格式" class="headerlink" title="表单格式"></a>表单格式</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- test.form.html --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">"http://localhost:3000"</span> <span class="attr">method</span>=<span class="string">"POST"</span> <span class="attr">enctype</span>=<span class="string">"application/x-www-form-urlencoded"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"username"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"password"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">button</span>&gt;</span>提交<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">        form没有跨域问题 action可以直接跳转  method只有post、get</span></span><br><span class="line"><span class="comment">        用VS安装的插件 Open with Live Server运行该文件</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    localhost:3000 服务器返回 username=123&amp;password=456  格式</span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 步骤：输入框输入123 456 点击提交，跳转到localhost:3000 页面上打印出 username=123&amp;password=456 --&gt;</span></span><br></pre></td></tr></table></figure>

<p>上面讲的都是怎么去通信，但实际上不可能你发送给服务器什么，服务器就返还给你<br>客户端访问服务器有2种情况 1、请求别人的服务器 自己写个文件去访问别人服务器；2、我去对服务器要资源（静态资源）</p>
<p>node 适合 I/O 密集  像web 的网站，主要是 想要html服务器返回给你html，想要js，服务器返回给你js，它主要的操作就是I/O,所以这样的功能，node的性能比较高<br>别人客户端访问我 我服务器可以返回什么：</p>
<p>1) 服务器可以返回静态资源   3.static.js<br>2) 我的服务器可以返回动态的资源 接口<br>3) 访问别人的服务器 把别人的服务的结果格式化后返回去 这就是所谓的中间层 或者爬虫</p>
<h3 id="静态资源"><a href="#静态资源" class="headerlink" title="静态资源"></a>静态资源</h3><p>新建 index.html 、style.css、3.static.js</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--index.html --&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"X-UA-Compatible"</span> <span class="attr">content</span>=<span class="string">"ie=edge"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">href</span>=<span class="string">"/style.css"</span>&gt;</span></span><br><span class="line">    hello</span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// style.css</span></span><br><span class="line">body&#123;</span><br><span class="line">    background: red</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 3.static.js</span></span><br><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line"><span class="keyword">const</span> url = <span class="built_in">require</span>(<span class="string">'url'</span>);</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> server = http.createServer(<span class="function">(<span class="params">req,res</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="comment">// fs操作 绝对路径</span></span><br><span class="line">    <span class="comment">// localhost:3000/index.html</span></span><br><span class="line">    <span class="keyword">let</span> &#123;pathname&#125; = url.parse(req.url); <span class="comment">//    /index.html</span></span><br><span class="line">    <span class="comment">// 上面的pathname有/ 所以这里绝对路径用join</span></span><br><span class="line">    <span class="keyword">let</span> filePath = path.join(__dirname, pathname);</span><br><span class="line">    <span class="comment">// /Users/jiafei/Desktop/Architecture-Course/16.http/index.html</span></span><br><span class="line">    <span class="comment">// 判断文件是否存在  existsSync  access stat</span></span><br><span class="line">    fs.stat(filePath, (err, statObj)=&gt;&#123;</span><br><span class="line">        <span class="keyword">if</span>(err)&#123;</span><br><span class="line">            res.statusCode = <span class="number">404</span>;</span><br><span class="line">            <span class="keyword">return</span> res.end(<span class="string">'Not Found'</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (statObj.isDirectory()) &#123;</span><br><span class="line">                <span class="comment">// 如果是文件夹 需要读取文件中的index.html</span></span><br><span class="line">                filePath = path.join(filePath, <span class="string">"index.html"</span>);</span><br><span class="line">                fs.access(filePath, <span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line">                  <span class="keyword">if</span> (err) &#123;</span><br><span class="line">                    res.statusCode = <span class="number">404</span>;</span><br><span class="line">                    res.end(<span class="string">`Not Found`</span>);</span><br><span class="line">                  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// readFile writeFile  pipe</span></span><br><span class="line">                    res.setHeader(<span class="string">"Content-Type"</span>, <span class="string">"text/html;charset=utf-8"</span>);</span><br><span class="line">                    fs.createReadStream(filePath).pipe(res);</span><br><span class="line">                    <span class="comment">// 可读流                           可写流</span></span><br><span class="line">                  &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">              &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 如果是文件读取出来写回去就ok</span></span><br><span class="line">                <span class="keyword">let</span> t = <span class="built_in">require</span>(<span class="string">"mime"</span>).getType(filePath);</span><br><span class="line">                res.setHeader(<span class="string">"Content-Type"</span>, t + <span class="string">";charset=utf-8"</span>);</span><br><span class="line">                fs.createReadStream(filePath).pipe(res);</span><br><span class="line">              &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="built_in">console</span>.log(filePath);</span><br><span class="line">&#125;);</span><br><span class="line">server.listen(<span class="number">3000</span>);</span><br></pre></td></tr></table></figure>

<p>分析：浏览器 访问index.html（html加载css）  -&gt; style.css，客户端访问服务器 想要html 服务器就把html读出来，返回去，fs的读取操作。<br>服务端 nodemon 3.static.js<br>客户端：浏览器 <a href="http://localhost:3000/index.html" target="_blank" rel="noopener">http://localhost:3000/index.html</a></p>
<h4 id="优化-4-static-js"><a href="#优化-4-static-js" class="headerlink" title="优化 4.static.js"></a>优化 4.static.js</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line"><span class="keyword">const</span> url = <span class="built_in">require</span>(<span class="string">'url'</span>);</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>).promises;</span><br><span class="line"><span class="keyword">const</span> &#123; createReadStream &#125; = <span class="built_in">require</span>(<span class="string">"fs"</span>);</span><br><span class="line"><span class="keyword">const</span> mime = <span class="built_in">require</span>(<span class="string">"mime"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 提供一个静态服务</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HttpServer</span></span>&#123;</span><br><span class="line">    <span class="keyword">async</span> handleRequest(req,res)&#123; <span class="comment">// 处理请求</span></span><br><span class="line">        <span class="comment">// this =&gt; HttpServer 指向当前类的实例</span></span><br><span class="line">        <span class="comment">// console.log(this);</span></span><br><span class="line">        <span class="keyword">let</span> &#123; pathname, query &#125; = url.parse(req.url, <span class="literal">true</span>);</span><br><span class="line">        <span class="keyword">let</span> filePath = path.join(__dirname, pathname);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> statObj = <span class="keyword">await</span> fs.stat(filePath); <span class="comment">// 文件是否存在</span></span><br><span class="line">            <span class="keyword">this</span>.sendFile(statObj, filePath, req, res); <span class="comment">// 就把文件发回去</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">            <span class="keyword">this</span>.sendError(e, res);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">async</span> sendFile(statObj, filePath, req, res) &#123; <span class="comment">// 发送文件需要判断是不是目录</span></span><br><span class="line">        <span class="keyword">if</span> (statObj.isDirectory()) &#123;</span><br><span class="line">          filePath = path.join(filePath, <span class="string">"index.html"</span>); <span class="comment">// 增加index.html</span></span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">await</span> fs.access(filePath); <span class="comment">// 如果有就继续</span></span><br><span class="line">          &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.sendError(e, res); <span class="comment">// 如果没有 就直接报错</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 返回文件的逻辑</span></span><br><span class="line">        res.setHeader(<span class="string">"Content-Type"</span>, mime.getType(filePath) + <span class="string">";charset=utf-8"</span>);</span><br><span class="line">        createReadStream(filePath).pipe(res); <span class="comment">// res.write() res.end()</span></span><br><span class="line">    &#125;</span><br><span class="line">    sendError(e,res) &#123; <span class="comment">// 发送错误</span></span><br><span class="line">        <span class="built_in">console</span>.log(e);</span><br><span class="line">        res.statusCode = <span class="number">404</span>;</span><br><span class="line">        res.end(<span class="string">`Not Found`</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 开启一个服务</span></span><br><span class="line">    start(...args)&#123;</span><br><span class="line">        <span class="comment">// 1) 保证this指向正确  this.handleRequest.bind(this)</span></span><br><span class="line">        <span class="keyword">let</span> server = http.createServer(<span class="keyword">this</span>.handleRequest.bind(<span class="keyword">this</span>));</span><br><span class="line">        server.listen(...args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> hs = <span class="keyword">new</span> HttpServer();</span><br><span class="line">hs.start(<span class="number">3000</span>, ()=&gt;&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'server start~~'</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Nodejs</category>
      </categories>
      <tags>
        <tag>Nodejs</tag>
        <tag>HTTP</tag>
      </tags>
  </entry>
  <entry>
    <title>Nodejs 流(stream) Readable、Writable</title>
    <url>/2019/09/29/Node-stream-pipe/</url>
    <content><![CDATA[<h3 id="可读流-可写流"><a href="#可读流-可写流" class="headerlink" title="可读流 + 可写流"></a>可读流 + 可写流</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> rs = fs.createReadStream(path.resolve(__dirname, <span class="string">'1.txt'</span>),&#123;</span><br><span class="line">    highWaterMark: <span class="number">4</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> ws = fs.createWriteStream(path.resolve(__dirname, <span class="string">'2.txt'</span>), &#123;</span><br><span class="line">    highWaterMark: <span class="number">1</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">rs.on(<span class="string">'data'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">chunk</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> flag = ws.write(chunk);</span><br><span class="line">    <span class="keyword">if</span>( !flag)&#123;</span><br><span class="line">        rs.pause(); <span class="comment">// 暂停读流</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">ws.on(<span class="string">'drain'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'干了'</span>);</span><br><span class="line">    rs.resume();</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h3 id="现在换成自己写的"><a href="#现在换成自己写的" class="headerlink" title="现在换成自己写的"></a>现在换成自己写的</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ReadStream = <span class="built_in">require</span>(<span class="string">'./ReadStream'</span>);</span><br><span class="line"><span class="keyword">const</span> WriteStream = <span class="built_in">require</span>(<span class="string">'./WriteStream'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> rs = <span class="keyword">new</span> ReadStream(path.resolve(__dirname, <span class="string">'1.txt'</span>),&#123;</span><br><span class="line">    highWaterMark: <span class="number">4</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> ws = <span class="keyword">new</span> WriteStream(path.resolve(__dirname, <span class="string">'2.txt'</span>), &#123;</span><br><span class="line">    highWaterMark: <span class="number">1</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">rs.on(<span class="string">'data'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">chunk</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> flag = ws.write(chunk);</span><br><span class="line">    <span class="keyword">if</span>( !flag)&#123;</span><br><span class="line">        rs.pause(); <span class="comment">// 暂停读流</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">ws.on(<span class="string">'drain'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'干了'</span>);</span><br><span class="line">    rs.resume();</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>这样也可以运行成功 上面line15-24还是太麻烦了，原生有封装</p>
<h3 id="pipe"><a href="#pipe" class="headerlink" title="pipe"></a>pipe</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ReadStream = <span class="built_in">require</span>(<span class="string">'./ReadStream'</span>);</span><br><span class="line"><span class="keyword">const</span> WriteStream = <span class="built_in">require</span>(<span class="string">'./WriteStream'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> rs = <span class="keyword">new</span> ReadStream(path.resolve(__dirname, <span class="string">'1.txt'</span>),&#123;</span><br><span class="line">    <span class="comment">// highWaterMark: 4 // 这里也可以注释掉</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> ws = <span class="keyword">new</span> WriteStream(path.resolve(__dirname, <span class="string">'2.txt'</span>), &#123;</span><br><span class="line">    <span class="comment">// highWaterMark: 1 // 这里也可以注释掉</span></span><br><span class="line">&#125;)</span><br><span class="line">rs.pipe(ws);  <span class="comment">// 默认会调用可写流的write方法 最终会调用end方法</span></span><br><span class="line"><span class="comment">// 同理 现在要在ReadStream.js中增加pipe方法</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ReadStream.js</span></span><br><span class="line">pipe(ws)&#123;</span><br><span class="line">	<span class="keyword">this</span>.on(<span class="string">'data'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">chunk</span>)</span>&#123;</span><br><span class="line">		<span class="keyword">let</span> flag = ws.write(chunk);</span><br><span class="line">		<span class="keyword">if</span>( !flag)&#123;</span><br><span class="line">			<span class="keyword">this</span>.pause();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;)</span><br><span class="line">	ws.on(<span class="string">'drain'</span>,()=&gt;&#123;</span><br><span class="line">		<span class="keyword">this</span>.resume();</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>上面都是基于文件的流<br>自己可以实现自己的流<br>http socket 压缩 req res 这些都是靠流来实现的，所以流是nodejs的核心机制<br>我们这里的fs是自己实现了流，下面描述下它的执行过程：<br>默认可读流会提供一个read方法</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123;Readable&#125; = <span class="built_in">require</span>(<span class="string">'stream'</span>);</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyRead</span> <span class="keyword">extends</span> <span class="title">Readable</span></span>&#123; <span class="comment">// 自己写一个类来继承Readable</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>源码看下 <code>Readable</code> 是什么</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">两个类 第一个类 是 子类：ReadStream(_read),会把读取到的数据 调用push方法传进去   父类：Readable (read)</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123;Readable,Writable&#125; = <span class="built_in">require</span>(<span class="string">'stream'</span>);</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyRead</span> <span class="keyword">extends</span> <span class="title">Readable</span></span>&#123; <span class="comment">//自己写的流</span></span><br><span class="line">    _read()&#123;</span><br><span class="line">        <span class="keyword">this</span>.push(<span class="string">'1'</span>); <span class="comment">// 这个push调的是父类的push</span></span><br><span class="line">        <span class="keyword">this</span>.push(<span class="literal">null</span>); <span class="comment">// 放完了 表示暂停 这里会调line13的end方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> mr = <span class="keyword">new</span> MyRead(); </span><br><span class="line"></span><br><span class="line">mr.on(<span class="string">'data'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">chunk</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(chunk)</span><br><span class="line">&#125;)</span><br><span class="line">mr.on(<span class="string">'end'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">chunk</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'end'</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 可以看到这个流跟文件完全没有关系 自己写的</span></span><br></pre></td></tr></table></figure>

<p>同样 WriteStream 有一个(write方法)  子类有(_write方法)，子类会自己去调_write方法</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123;Readable,Writable&#125; = <span class="built_in">require</span>(<span class="string">'stream'</span>);</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyWrite</span> <span class="keyword">extends</span> <span class="title">Writable</span></span>&#123;</span><br><span class="line">    _write(chunk,encoding,clearBuffer)&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(chunk,<span class="string">'---'</span>);</span><br><span class="line">        clearBuffer()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> myWrite = <span class="keyword">new</span> MyWrite();</span><br><span class="line">myWrite.write(<span class="string">'123'</span>);</span><br><span class="line">myWrite.write(<span class="string">'123'</span>);</span><br><span class="line">myWrite.write(<span class="string">'123'</span>);</span><br><span class="line">myWrite.write(<span class="string">'123'</span>);</span><br><span class="line"><span class="comment">/*执行结果：</span></span><br><span class="line"><span class="comment">&lt;Buffer 31 32 33&gt; '---'</span></span><br><span class="line"><span class="comment">&lt;Buffer 31 32 33&gt; '---'</span></span><br><span class="line"><span class="comment">&lt;Buffer 31 32 33&gt; '---'</span></span><br><span class="line"><span class="comment">&lt;Buffer 31 32 33&gt; '---'</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>Nodejs</tag>
        <tag>文件系统 fs</tag>
        <tag>流 stream</tag>
      </tags>
  </entry>
  <entry>
    <title>Nodejs fs （三）之 可写流 createWriteStream</title>
    <url>/2019/09/27/Node-fs-createWriteStream/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote>
<p> 可读流中有 on(‘data’) on(‘end’)<br>可写流有 write    end</p>
</blockquote>
<h2 id="fs-createWriteStream"><a href="#fs-createWriteStream" class="headerlink" title="fs.createWriteStream"></a>fs.createWriteStream</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>这里先创建一个文件 notd.md</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">你好</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 可读流</span></span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"><span class="keyword">let</span> rs = fs.createReadStream(path.resolve(__dirname,<span class="string">'note.md'</span>),&#123;</span><br><span class="line">    highWaterMark: <span class="number">1</span> <span class="comment">// 代表每次读1个</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可写流</span></span><br><span class="line"><span class="keyword">let</span> ws = fs.createWriteStream(path.resolve(__dirname,<span class="string">'copy.md'</span>));</span><br><span class="line"><span class="comment">// 默认是暂停模式</span></span><br><span class="line"><span class="keyword">let</span> arr = [];</span><br><span class="line">rs.on(<span class="string">'data'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">    arr.push(data)</span><br><span class="line">    <span class="comment">// 去做写的操作</span></span><br><span class="line">    ws.write(data);</span><br><span class="line">&#125;)</span><br><span class="line">rs.on(<span class="string">'end'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(Buffer.concat(arr).toString()); <span class="comment">//你好</span></span><br><span class="line">    ws.end();</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> rs = fs.createReadStream(path.resolve(__dirname,<span class="string">'note1.md'</span>),&#123;</span><br><span class="line">    highWaterMark: <span class="number">1</span> <span class="comment">// 默认64 * 1024 每次读一个 读完一个往里写</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可写流</span></span><br><span class="line"><span class="keyword">let</span> ws = fs.createWriteStream(path.resolve(__dirname,<span class="string">'copy1.md'</span>),&#123;</span><br><span class="line">    highWaterMark: <span class="number">3</span>, <span class="comment">// 默认 16 * 1024  预计占用的内存空间是多少</span></span><br><span class="line"></span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 默认是暂停模式</span></span><br><span class="line"><span class="keyword">let</span> arr = [];</span><br><span class="line"></span><br><span class="line">rs.on(<span class="string">'data'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">    arr.push(data)</span><br><span class="line">    <span class="comment">// 去做写的操作</span></span><br><span class="line">    <span class="keyword">let</span> flag = ws.write(data); <span class="comment">// 做到收支平衡，读一点写一点</span></span><br><span class="line">    <span class="comment">// flag代表的是当前预计的内存大小是否被撑满</span></span><br><span class="line">    <span class="built_in">console</span>.log(flag);</span><br><span class="line">    <span class="comment">// write调的就是fs.write是异步的，相当于多个异步请求操作同一个文件，不能多个异步同时操作一个文件，所以会放到缓存区中</span></span><br><span class="line">&#125;)</span><br><span class="line">rs.on(<span class="string">'end'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(Buffer.concat(arr).toString());</span><br><span class="line">    ws.end();</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>具体要看flag可以看下面的 只看可写流</p>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><h4 id="1-预计写10个数-同步的写"><a href="#1-预计写10个数-同步的写" class="headerlink" title="1. 预计写10个数 同步的写"></a>1. 预计写10个数 同步的写</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="keyword">let</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"><span class="keyword">let</span> ws = fs.createWriteStream(path.resolve(__dirname, <span class="string">'note3.md'</span>), &#123;</span><br><span class="line">    highWaterMark: <span class="number">3</span>,</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">let</span> index = <span class="number">-1</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">write</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(++index&lt;<span class="number">10</span>)&#123; </span><br><span class="line">        <span class="keyword">let</span> flag = ws.write(index+<span class="string">''</span>); <span class="comment">// 可写流写入的数据只能是字符串或者Buffer 所以这里+''</span></span><br><span class="line">        <span class="built_in">console</span>.log(flag);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">write();</span><br><span class="line"><span class="comment">/*执行结果</span></span><br><span class="line"><span class="comment">true</span></span><br><span class="line"><span class="comment">true</span></span><br><span class="line"><span class="comment">false</span></span><br><span class="line"><span class="comment">false</span></span><br><span class="line"><span class="comment">false</span></span><br><span class="line"><span class="comment">false</span></span><br><span class="line"><span class="comment">false</span></span><br><span class="line"><span class="comment">false</span></span><br><span class="line"><span class="comment">false</span></span><br><span class="line"><span class="comment">false</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// 文件 note3.md   0123456789</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>可写流写入的数据只能是字符串或者Buffer 所以这里+’’</p>
</blockquote>
<p>原理如图：<br><img src="https://jiafei2333.github.io/html/images/fs.createWriteStream.png" alt title="可写流"></p>
<p>第一次0往里写还能写下，第二次1往里写还能写下，第三次2往里写，2能写下，但是之后的不能写下了，所以如图flag为false，即flag表示是否还能继续往里写，值为false时表示预计的缓存区放不下， 但是还是会放进去，会撑开，这样就浪费内存了，希望的是写不下了，就等待，等写完了再放进去。</p>
<h4 id="2-加flag的判断"><a href="#2-加flag的判断" class="headerlink" title="2. 加flag的判断"></a>2. 加flag的判断</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="keyword">let</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"><span class="keyword">let</span> ws = fs.createWriteStream(path.resolve(__dirname, <span class="string">'note3.md'</span>), &#123;</span><br><span class="line">    highWaterMark: <span class="number">3</span>,</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">let</span> index = <span class="number">-1</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">write</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> flag = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">while</span>(++index&lt;<span class="number">10</span> &amp;&amp; flag)&#123; </span><br><span class="line">        flag = ws.write(index+<span class="string">''</span>);</span><br><span class="line">        <span class="built_in">console</span>.log(flag);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">write();</span><br><span class="line"><span class="comment">// 文件 note3.md   012</span></span><br></pre></td></tr></table></figure>

<h4 id="3-当内存中的值都写入文件之后继续写入"><a href="#3-当内存中的值都写入文件之后继续写入" class="headerlink" title="3. 当内存中的值都写入文件之后继续写入"></a>3. 当内存中的值都写入文件之后继续写入</h4><blockquote>
<p>on(‘drain’)</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 当内存中的值都写入文件之后继续写入</span></span><br><span class="line"><span class="keyword">let</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="keyword">let</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"><span class="keyword">let</span> ws = fs.createWriteStream(path.resolve(__dirname, <span class="string">'note3.md'</span>), &#123;</span><br><span class="line">    highWaterMark: <span class="number">3</span>,</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">let</span> index = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">write</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> flag = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">while</span>(index&lt;<span class="number">10</span> &amp;&amp; flag)&#123; </span><br><span class="line">        flag = ws.write(index+<span class="string">''</span>);</span><br><span class="line">        index ++;</span><br><span class="line">        <span class="built_in">console</span>.log(flag);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">write();</span><br><span class="line"><span class="comment">// 只有当写入的个数达到了预计的大小 并且被写入到文件后清空了 才会触发drain，所以这里最后只有一个9传进去之后没有再触发（即执行结果里面最后一个true之后没有再触发‘干了’）</span></span><br><span class="line">ws.on(<span class="string">'drain'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'干了'</span>);</span><br><span class="line">    write();</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">/*执行结果：</span></span><br><span class="line"><span class="comment">true</span></span><br><span class="line"><span class="comment">true</span></span><br><span class="line"><span class="comment">false</span></span><br><span class="line"><span class="comment">干了</span></span><br><span class="line"><span class="comment">true</span></span><br><span class="line"><span class="comment">true</span></span><br><span class="line"><span class="comment">false</span></span><br><span class="line"><span class="comment">干了</span></span><br><span class="line"><span class="comment">true</span></span><br><span class="line"><span class="comment">true</span></span><br><span class="line"><span class="comment">false</span></span><br><span class="line"><span class="comment">干了</span></span><br><span class="line"><span class="comment">true</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h4 id="4-只有手动调end-才会触发关闭文件的事件"><a href="#4-只有手动调end-才会触发关闭文件的事件" class="headerlink" title="4. 只有手动调end 才会触发关闭文件的事件"></a>4. 只有手动调end 才会触发关闭文件的事件</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="keyword">let</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"><span class="keyword">let</span> ws = fs.createWriteStream(path.resolve(__dirname, <span class="string">'note3.md'</span>), &#123;</span><br><span class="line">    highWaterMark: <span class="number">3</span>,</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">let</span> index = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">write</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> flag = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">while</span>(index&lt;<span class="number">10</span> &amp;&amp; flag)&#123; </span><br><span class="line">        flag = ws.write(index+<span class="string">''</span>);</span><br><span class="line">        index ++;</span><br><span class="line">        <span class="built_in">console</span>.log(flag);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(index === <span class="number">10</span>)&#123;</span><br><span class="line">        ws.end(); <span class="comment">// 关闭文件 关闭可写流   // 0123456789</span></span><br><span class="line">        <span class="comment">//ws.end('hello'); // 如果end里加了参数，最后会写入文件中 // 0123456789hello</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">write();</span><br><span class="line">ws.on(<span class="string">'drain'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'干了'</span>);</span><br><span class="line">    write();</span><br><span class="line">&#125;)</span><br><span class="line">ws.on(<span class="string">'close'</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'close'</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="手写可写流"><a href="#手写可写流" class="headerlink" title="手写可写流"></a>手写可写流</h3><p>新建：调用文件 write.js &nbsp;&nbsp;&nbsp;&nbsp; 原理 ReadStream.js</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// write.js</span></span><br><span class="line"><span class="keyword">let</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="keyword">let</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"><span class="keyword">const</span> WriteStream = <span class="built_in">require</span>(<span class="string">'./WriteStream'</span>);</span><br><span class="line"><span class="keyword">let</span> ws = <span class="keyword">new</span> WriteStream(path.resolve(__dirname, <span class="string">'note3.md'</span>), &#123;</span><br><span class="line">    highWaterMark: <span class="number">3</span>, <span class="comment">// 表示预期占用几个内存</span></span><br><span class="line">    encoding: <span class="string">'utf8'</span>, <span class="comment">// 写入的编码</span></span><br><span class="line">    start: <span class="number">0</span>, <span class="comment">// 从文件的第0个位置写入</span></span><br><span class="line">    mode: <span class="number">438</span>,</span><br><span class="line">    flags: <span class="string">'w'</span>, <span class="comment">// 默认操作是可写</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">let</span> index = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">write</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> flag = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">while</span>(index&lt;<span class="number">10</span> &amp;&amp; flag)&#123; </span><br><span class="line">        flag = ws.write(index+<span class="string">''</span>);</span><br><span class="line">        index ++;</span><br><span class="line">        <span class="built_in">console</span>.log(flag);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// if(index === 10)&#123;</span></span><br><span class="line">    <span class="comment">//     ws.end('hello');</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">&#125;</span><br><span class="line">write();</span><br><span class="line">ws.on(<span class="string">'drain'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'干了'</span>);</span><br><span class="line">    write();</span><br><span class="line">&#125;)</span><br><span class="line">ws.on(<span class="string">'close'</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'close'</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// WriteStream.js</span></span><br><span class="line"><span class="keyword">const</span> EventEmitter = <span class="built_in">require</span>(<span class="string">'events'</span>);</span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WriteStream</span> <span class="keyword">extends</span> <span class="title">EventEmitter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(path, options = &#123;&#125;)&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        <span class="keyword">this</span>.path = path;</span><br><span class="line">        <span class="keyword">this</span>.highWaterMark = options.highWaterMark || <span class="number">16</span> * <span class="number">1024</span>;</span><br><span class="line">        <span class="keyword">this</span>.encoding = options.encoding || <span class="string">'utf8'</span>;</span><br><span class="line">        <span class="keyword">this</span>.start = options.start || <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">this</span>.mode = options.mode || <span class="number">0o666</span>;</span><br><span class="line">        <span class="keyword">this</span>.flags = options.flags || <span class="string">'w'</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 先打开文件</span></span><br><span class="line">        <span class="keyword">this</span>.open();</span><br><span class="line">        <span class="comment">// 缓存区</span></span><br><span class="line">        <span class="keyword">this</span>.cache = []; <span class="comment">// 写的时候只有第一次往文件里写，其他的都放缓存区</span></span><br><span class="line">        <span class="keyword">this</span>.writing = <span class="literal">false</span>; <span class="comment">// 判断是否正在被写入</span></span><br><span class="line">        <span class="keyword">this</span>.len = <span class="number">0</span>; <span class="comment">// 缓存区的大小</span></span><br><span class="line">        <span class="keyword">this</span>.needDrain = <span class="literal">false</span>; <span class="comment">// 是否触发drain事件</span></span><br><span class="line">        <span class="keyword">this</span>.offset = <span class="keyword">this</span>.start; <span class="comment">// 表示每次写入文件的偏移量</span></span><br><span class="line">    &#125;</span><br><span class="line">    open()&#123; <span class="comment">// 先打开文件</span></span><br><span class="line">        fs.open(<span class="keyword">this</span>.path, <span class="keyword">this</span>.flags, (err, fd)=&gt;&#123;</span><br><span class="line">            <span class="keyword">this</span>.fd = fd; <span class="comment">// 文件标识符</span></span><br><span class="line">            <span class="keyword">this</span>.emit(<span class="string">'open'</span>, <span class="keyword">this</span>.write);</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    write(chunk, encoding=<span class="keyword">this</span>.encoding,callback)&#123; <span class="comment">// 用户会同步的调用write方法</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'write~~'</span>,<span class="keyword">this</span>.fd); <span class="comment">// 打印这里可以看到 write比open先调用，write这里是同步操作，open是异步  line27当open打开文件之后再触发write</span></span><br><span class="line">        <span class="comment">// 此时这里面用户调用write方法时 需要判断当前是否正在写入，如果正在写入放到缓存中，如果不是正在写入需要把它真正的向文件写入</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 因为len取的长度是字节长度，所以这里面数据类型要统一，判断是否为Buffer</span></span><br><span class="line">        <span class="comment">// 1) 判断这个chunk 是不是Buffer 如果不是Buffer转化成Buffer</span></span><br><span class="line">        chunk = Buffer.isBuffer(chunk) ? chunk : Buffer.from(chunk);</span><br><span class="line">        <span class="keyword">this</span>.len += chunk.length; <span class="comment">// 统计写入数据的个数</span></span><br><span class="line">        <span class="keyword">let</span> flag = <span class="keyword">this</span>.len &lt; <span class="keyword">this</span>.highWaterMark;</span><br><span class="line">        <span class="keyword">this</span>.needDrain = !flag; <span class="comment">//当前写入的内容&gt;=highWaterMark才会触发</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.writing)&#123; <span class="comment">// 当前是否正在写入 是  往内存中放</span></span><br><span class="line">            <span class="keyword">this</span>.cache.push(&#123; <span class="comment">// 将除了第一次真实的向内存中写入的 其他都放入内存中</span></span><br><span class="line">                chunk,</span><br><span class="line">                encoding,</span><br><span class="line">                callback</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;<span class="comment">// 真实向文件中写入</span></span><br><span class="line">            <span class="keyword">this</span>.writing = <span class="literal">true</span>; <span class="comment">// 标识正在写入</span></span><br><span class="line">            <span class="keyword">this</span>._write(chunk,encoding,()=&gt;&#123;</span><br><span class="line">                callback &amp;&amp; callback(); <span class="comment">// 先执行自己的成功操作</span></span><br><span class="line">                <span class="keyword">this</span>.clearBuffer(); <span class="comment">// 再清空队列中的第一个</span></span><br><span class="line">            &#125;); </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> flag;</span><br><span class="line">    &#125;</span><br><span class="line">    clearBuffer()&#123; <span class="comment">// </span></span><br><span class="line">        <span class="comment">// console.log('清空缓存区队列中的数据');</span></span><br><span class="line">        <span class="keyword">let</span> obj = <span class="keyword">this</span>.cache.shift();<span class="comment">// 取第一个值</span></span><br><span class="line">        <span class="keyword">if</span>(obj)&#123;<span class="comment">// 说明需要写入</span></span><br><span class="line">            <span class="keyword">this</span>._write(obj.chunk,obj.encoding,()=&gt;&#123;</span><br><span class="line">                obj.callback &amp;&amp; obj.callback(); </span><br><span class="line">                <span class="keyword">this</span>.clearBuffer(); </span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123; <span class="comment">// 说明缓存区中没有 需要写入</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">this</span>.needDrain)&#123;</span><br><span class="line">                <span class="keyword">this</span>.needDrain = <span class="literal">false</span>; <span class="comment">// 表示下一次需要重新判断是否需要触发drain事件</span></span><br><span class="line">                <span class="keyword">this</span>.writing = <span class="literal">false</span>; <span class="comment">// 表示下一次调用write要向文件中写入(因为缓存区已经obj没有数据了)))</span></span><br><span class="line">                <span class="keyword">this</span>.emit(<span class="string">'drain'</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 核心的写入方法</span></span><br><span class="line">    _write(chunk,encoding,clearBuffer)&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">typeof</span> <span class="keyword">this</span>.fd !== <span class="string">'number'</span>)&#123; <span class="comment">//write()相对于open是先调用的</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.once(<span class="string">'open'</span>,()=&gt;&#123;<span class="keyword">this</span>._write(chunk,encoding,clearBuffer)&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// todo 写入操作</span></span><br><span class="line">        <span class="comment">// flags 是读取还是写入</span></span><br><span class="line">        <span class="comment">// chunk 写入的数据</span></span><br><span class="line">        <span class="comment">// 0表示把数据的第0个位置开始写入</span></span><br><span class="line">        <span class="comment">// 读取buffer多少个字节</span></span><br><span class="line">        <span class="comment">// 每次写入文件的偏移量</span></span><br><span class="line">        fs.write(<span class="keyword">this</span>.fd,chunk,<span class="number">0</span>,chunk.length,<span class="keyword">this</span>.offset, (err, written)=&gt;&#123; <span class="comment">// written表示真实写入的格式</span></span><br><span class="line">            <span class="keyword">this</span>.offset += written; <span class="comment">// 增加偏移量</span></span><br><span class="line">            <span class="keyword">this</span>.len -= written; <span class="comment">// 减少缓存区的数据</span></span><br><span class="line">            clearBuffer(); <span class="comment">// 清空缓存</span></span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    close()&#123;</span><br><span class="line">        fs.close(<span class="keyword">this</span>.fd, ()=&gt;&#123;</span><br><span class="line">            <span class="keyword">this</span>.emit(<span class="string">'close'</span>);</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    end(chunk,encoding)&#123; <span class="comment">// 如果传递参数 就需要写入</span></span><br><span class="line">        <span class="keyword">if</span>(chunk)&#123; <span class="comment">// 写入</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>._write(chunk,encoding,()=&gt;&#123;</span><br><span class="line">                <span class="keyword">this</span>.close();</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">module</span>.exports = WriteStream;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Nodejs</category>
      </categories>
      <tags>
        <tag>Nodejs</tag>
        <tag>文件系统 fs</tag>
      </tags>
  </entry>
  <entry>
    <title>Nodejs fs （二）之 可读流 createReadStream</title>
    <url>/2019/09/27/Node-fs-createReadStream/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote>
<p>文件流&nbsp;&nbsp;&nbsp;&nbsp;文件的读取和操作<br>readFile 、writeFile 缺陷 ：会淹没内存 所以可以变成=&gt; read+write（open、read、close） 读一点写一点，但是这样又太复杂  fs自己封装了 <code>fs.createReadStream</code></p>
</blockquote>
<a id="more"></a>

<h2 id="fs-createReadStream"><a href="#fs-createReadStream" class="headerlink" title="fs.createReadStream"></a>fs.createReadStream</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>这里先创建一个文件1.txt</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">12345678909</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里的参数在vscode编辑器中可以将鼠标放到createReadStream就会显示出来了</span></span><br><span class="line"><span class="keyword">let</span> rs = fs.createReadStream(path.resolve(__dirname, <span class="string">'1.txt'</span>),&#123;</span><br><span class="line">    flags:<span class="string">'r'</span>, <span class="comment">// 当前要做什么操作</span></span><br><span class="line">    encoding:<span class="literal">null</span>, <span class="comment">// 默认是Buffer</span></span><br><span class="line">    highWaterMark: <span class="number">64</span> * <span class="number">1024</span>,<span class="comment">// 内部会创建 64k大的Buffer</span></span><br><span class="line">    <span class="comment">//highWaterMark: 2,</span></span><br><span class="line">    <span class="comment">// 读取 默认权限是4 写入默认是2  执行是1  ls可以查看文件权限 chmod改变权限</span></span><br><span class="line">    mode:<span class="number">0o666</span>,<span class="comment">//默认  文件读取 写入权限 执行权限  16进制 转化为十进制 438</span></span><br><span class="line">    autoClose:<span class="literal">true</span>, <span class="comment">// true 读完之后会关闭</span></span><br><span class="line">    start:<span class="number">0</span>, <span class="comment">// 开始读取的位置</span></span><br><span class="line">    end:<span class="number">10</span> <span class="comment">// 这样的话一次性读取11个 包前 又包后</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 默认流的模式是暂停模式</span></span><br><span class="line">rs.on(<span class="string">'data'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123; <span class="comment">// 每次读取到的结果</span></span><br><span class="line">    <span class="built_in">console</span>.log(data); <span class="comment">// &lt;Buffer 31 32 33 34 35 36 37 38 39 30 39&gt;</span></span><br><span class="line">    <span class="comment">//如果把line9打开</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    &lt;Buffer 31 32&gt;</span></span><br><span class="line"><span class="comment">    &lt;Buffer 33 34&gt;</span></span><br><span class="line"><span class="comment">    &lt;Buffer 35 36&gt;</span></span><br><span class="line"><span class="comment">    &lt;Buffer 37 38&gt;</span></span><br><span class="line"><span class="comment">    &lt;Buffer 39 30&gt;</span></span><br><span class="line"><span class="comment">    &lt;Buffer 39&gt;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="comment">// 读取了6次 11/2</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<ul>
<li>可读流需要掌握的方法 ‘data’ ‘end’ Buffer.concat()</li>
</ul>
<p>1.txt</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">你好</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"><span class="keyword">let</span> rs = fs.createReadStream(path.resolve(__dirname, <span class="string">'1.txt'</span>),&#123;</span><br><span class="line">    flags:<span class="string">'r'</span>,</span><br><span class="line">    encoding:<span class="literal">null</span>, </span><br><span class="line">    highWaterMark: <span class="number">2</span>,</span><br><span class="line">    mode:<span class="number">0o666</span>,</span><br><span class="line">    autoClose:<span class="literal">true</span>, </span><br><span class="line">    start:<span class="number">0</span>,</span><br><span class="line">    end:<span class="number">10</span></span><br><span class="line">&#125;)</span><br><span class="line">rs.on(<span class="string">'open'</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'文件打开触发open事件'</span>);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 每次将传入的数据 接收保存起来</span></span><br><span class="line"><span class="keyword">let</span> arr = [];</span><br><span class="line">rs.on(<span class="string">'data'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(data);</span><br><span class="line">    arr.push(data);</span><br><span class="line">&#125;)</span><br><span class="line">rs.on(<span class="string">'end'</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'文件读取完毕'</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(Buffer.concat(arr).toString());<span class="comment">// 你好 这里用了Buffer中文转码的时候不会乱码</span></span><br><span class="line">&#125;)</span><br><span class="line">rs.on(<span class="string">'close'</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'文件关闭'</span>);</span><br><span class="line">&#125;)</span><br><span class="line">rs.on(<span class="string">'error'</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'出错了'</span>);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">/*执行结果：</span></span><br><span class="line"><span class="comment">文件打开触发open事件</span></span><br><span class="line"><span class="comment">&lt;Buffer e4 bd&gt;</span></span><br><span class="line"><span class="comment">&lt;Buffer a0 e5&gt;</span></span><br><span class="line"><span class="comment">&lt;Buffer a5 bd&gt;</span></span><br><span class="line"><span class="comment">文件读取完毕</span></span><br><span class="line"><span class="comment">你好</span></span><br><span class="line"><span class="comment">文件关闭</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h3 id="手写可读流原理"><a href="#手写可读流原理" class="headerlink" title="手写可读流原理"></a>手写可读流原理</h3><h4 id="1】"><a href="#1】" class="headerlink" title="1】"></a>1】</h4><p>新建：调用文件 stream.js&nbsp;&nbsp;&nbsp;&nbsp; 原理 ReadStream.js</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// stream.js</span></span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"><span class="keyword">let</span> ReadStream = <span class="built_in">require</span>(<span class="string">'./ReadStream'</span>);</span><br><span class="line"><span class="keyword">let</span> rs = <span class="keyword">new</span> ReadStream(path.resolve(__dirname, <span class="string">'1.txt'</span>),&#123;</span><br><span class="line">    flags:<span class="string">'r'</span>,</span><br><span class="line">    encoding:<span class="literal">null</span>, </span><br><span class="line">    highWaterMark: <span class="number">2</span>,</span><br><span class="line">    mode:<span class="number">0o666</span>,</span><br><span class="line">    autoClose:<span class="literal">true</span>, </span><br><span class="line">    start:<span class="number">0</span>,</span><br><span class="line">    end:<span class="number">10</span></span><br><span class="line">&#125;)</span><br><span class="line">rs.on(<span class="string">'open'</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'文件打开触发open事件'</span>);</span><br><span class="line">&#125;)</span><br><span class="line">rs.on(<span class="string">'data'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(data);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>对<code>ReadStream.js</code>分析：rs这个实例是有<code>on</code>方法，并且这里上面line17 <code>rs.on(&#39;data&#39;)</code> 时能够读取文件，所以我需要下面line21能够监听到<code>on(&#39;data&#39;)</code> 这个事件， 所以这里继承 <code>events</code> ，因为它有 <code>&#39;newListener&#39;</code> 可以监听到 <code>&#39;data&#39;</code> ,同样的这个实例上也就有<br><code>on (&#39;newListener&#39;)</code> 方法 如line21，所以这里 <code>ReadStream extends Events</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ReadStream.js</span></span><br><span class="line"><span class="keyword">const</span> Events = <span class="built_in">require</span>(<span class="string">'events'</span>);</span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ReadStream</span> <span class="keyword">extends</span> <span class="title">Events</span></span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(path, options = &#123;&#125;)&#123;</span><br><span class="line">        <span class="keyword">super</span>(); </span><br><span class="line">        <span class="comment">// 写类的时候构造函数中的属性都放到this上，这是一个规范，为了扩展方便，下面扩展方法的时候可以拿到</span></span><br><span class="line">        <span class="comment">// 默认参数的赋值</span></span><br><span class="line">        <span class="keyword">this</span>.path = path;</span><br><span class="line">        <span class="keyword">this</span>.flags = options.flags || <span class="string">'r'</span>;</span><br><span class="line">        <span class="keyword">this</span>.encoding = options.encoding || <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">this</span>.highWaterMark = options.highWaterMark || <span class="number">64</span> * <span class="number">1024</span>;</span><br><span class="line">        <span class="keyword">this</span>.mode = options.mode || <span class="number">438</span>;</span><br><span class="line">        <span class="keyword">this</span>.autoClose = options.autoClose || <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">this</span>.start = options.start | <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">this</span>.end = options.end;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.flowing = <span class="literal">null</span>; <span class="comment">// 默认是暂停模式</span></span><br><span class="line">        <span class="keyword">this</span>.open(); <span class="comment">// 打开文件 当创建可读流时，就打开文件(异步执行)</span></span><br><span class="line">        <span class="comment">// 继承了events所以这里也有on newListener方法</span></span><br><span class="line">        <span class="keyword">this</span>.on(<span class="string">'newListener'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">type</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(type === <span class="string">'data'</span>)&#123;<span class="comment">// 当用户监听data事件的时候 就开始读取文件</span></span><br><span class="line">                <span class="keyword">this</span>.flowing = <span class="literal">true</span>;</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="string">'开始读取'</span>);</span><br><span class="line">                <span class="keyword">this</span>.read();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    read()&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'read~'</span>);</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.fd);</span><br><span class="line">        <span class="comment">//这里要fs.read(fd)所以必须要拿到fd</span></span><br><span class="line">    &#125;</span><br><span class="line">    open()&#123;</span><br><span class="line">        fs.open(<span class="keyword">this</span>.path, <span class="keyword">this</span>.flags, (err, fd) =&gt;&#123;</span><br><span class="line">            <span class="keyword">this</span>.fd = fd;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'open~'</span>)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">module</span>.exports = ReadStream;</span><br><span class="line"><span class="comment">/*执行结果：</span></span><br><span class="line"><span class="comment">开始读取</span></span><br><span class="line"><span class="comment">read~</span></span><br><span class="line"><span class="comment">undefined</span></span><br><span class="line"><span class="comment">open~</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>结果分析：从打印结果可以看出，虽然line19先执行的是open，但是line35 执行的是异步，而stream.js line17这里又绑了data，就会马上触发line21，只要stream.js里面的on绑定了事件（此刻是’data‘），就会立刻触发’newListener‘，这里面是同步的，也就执行了line29read()方法</p>
<h4 id="2】"><a href="#2】" class="headerlink" title="2】"></a>2】</h4><p>现在希望先open执行完再执行read</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// stream.js</span></span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"><span class="keyword">let</span> ReadStream = <span class="built_in">require</span>(<span class="string">'./ReadStream'</span>);</span><br><span class="line"><span class="keyword">let</span> rs = <span class="keyword">new</span> ReadStream(path.resolve(__dirname, <span class="string">'1.txt'</span>),&#123;</span><br><span class="line">    flags:<span class="string">'r'</span>,</span><br><span class="line">    encoding:<span class="literal">null</span>, </span><br><span class="line">    highWaterMark: <span class="number">2</span>,</span><br><span class="line">    mode:<span class="number">0o666</span>,</span><br><span class="line">    autoClose:<span class="literal">true</span>, </span><br><span class="line">    start:<span class="number">0</span>,</span><br><span class="line">    end:<span class="number">10</span></span><br><span class="line">&#125;)</span><br><span class="line">rs.on(<span class="string">'open'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">fd</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'文件打开触发open事件'</span>,fd);</span><br><span class="line">&#125;)</span><br><span class="line">rs.on(<span class="string">'data'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"data:"</span>,data);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ReadStream.js</span></span><br><span class="line"><span class="keyword">const</span> Events = <span class="built_in">require</span>(<span class="string">'events'</span>);</span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ReadStream</span> <span class="keyword">extends</span> <span class="title">Events</span></span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(path, options = &#123;&#125;)&#123;</span><br><span class="line">        <span class="keyword">super</span>(); </span><br><span class="line">        <span class="comment">// 默认参数的赋值</span></span><br><span class="line">        <span class="keyword">this</span>.path = path;</span><br><span class="line">        <span class="keyword">this</span>.flags = options.flags || <span class="string">'r'</span>;</span><br><span class="line">        <span class="keyword">this</span>.encoding = options.encoding || <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">this</span>.highWaterMark = options.highWaterMark || <span class="number">64</span> * <span class="number">1024</span>;</span><br><span class="line">        <span class="keyword">this</span>.mode = options.mode || <span class="number">438</span>;</span><br><span class="line">        <span class="keyword">this</span>.autoClose = options.autoClose || <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">this</span>.start = options.start | <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">this</span>.end = options.end;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.flowing = <span class="literal">null</span>; <span class="comment">// 默认是暂停模式</span></span><br><span class="line">        <span class="keyword">this</span>.open(); <span class="comment">// 打开文件 </span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.on(<span class="string">'newListener'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">type</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(type === <span class="string">'data'</span>)&#123; </span><br><span class="line">                <span class="keyword">this</span>.flowing = <span class="literal">true</span>;</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="string">'开始读取'</span>);</span><br><span class="line">                <span class="keyword">this</span>.read();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    read()&#123;</span><br><span class="line">        <span class="comment">//console.log('read~');</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">typeof</span> <span class="keyword">this</span>.fd !== <span class="string">'number'</span>)&#123;<span class="comment">// 因为read比open先执行</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.once(<span class="string">'open'</span>, <span class="keyword">this</span>.read); <span class="comment">//所以先把read方法存起来，等open后再次调用</span></span><br><span class="line">            <span class="comment">// this.once('open', this.read); // 这2行等同于上一行写法</span></span><br><span class="line">            <span class="comment">// return ;</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'read~~'</span>,<span class="keyword">this</span>.fd); <span class="comment">//这样read里面就能拿到fd</span></span><br><span class="line">    &#125;</span><br><span class="line">    open()&#123;</span><br><span class="line">        fs.open(<span class="keyword">this</span>.path, <span class="keyword">this</span>.flags, (err, fd) =&gt;&#123;</span><br><span class="line">            <span class="keyword">this</span>.fd = fd;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'open~'</span>)</span><br><span class="line">            <span class="keyword">this</span>.emit(<span class="string">'open'</span>,<span class="keyword">this</span>.fd);</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*执行结果：</span></span><br><span class="line"><span class="comment">开始读取</span></span><br><span class="line"><span class="comment">open~</span></span><br><span class="line"><span class="comment">文件打开触发open事件 3</span></span><br><span class="line"><span class="comment">read~~ 3</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="built_in">module</span>.exports = ReadStream;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>分析：</p>
</blockquote>
<ul>
<li>顺序：<code>stream.js</code> line5一new这个类，立马line18执行open事件，因为line38是异步执行，所以在line41emit的时候，<code>stream.js</code>的line14 open已经绑定好了，所以能够触发 并且把fd也能传过去</li>
<li>这里用发布订阅的思想来解耦<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"> <span class="comment">// 之前的相当于如下：</span></span><br><span class="line">fs.open(path,..,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="comment">// 成功之后再read</span></span><br><span class="line">    fs.read(...console.)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 现在就相当于</span></span><br><span class="line">fs.open(...,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    rs.emit(<span class="string">'ok'</span>);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">this</span>.on(<span class="string">'ok'</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    rs.read(...);  </span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 让两个相关联的异步解耦并且是有关联的</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="3】"><a href="#3】" class="headerlink" title="3】"></a>3】</h4><p>读取到内容</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// stream.js</span></span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"><span class="keyword">let</span> ReadStream = <span class="built_in">require</span>(<span class="string">'./ReadStream'</span>);</span><br><span class="line"><span class="keyword">let</span> rs = <span class="keyword">new</span> ReadStream(path.resolve(__dirname, <span class="string">'1.txt'</span>),&#123;</span><br><span class="line">    flags:<span class="string">'r'</span>,</span><br><span class="line">    encoding:<span class="literal">null</span>, </span><br><span class="line">    highWaterMark: <span class="number">2</span>,</span><br><span class="line">    mode:<span class="number">0o666</span>,</span><br><span class="line">    autoClose:<span class="literal">true</span>, </span><br><span class="line">    start:<span class="number">0</span>,</span><br><span class="line">    end:<span class="number">10</span></span><br><span class="line">&#125;)</span><br><span class="line">rs.on(<span class="string">'open'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">fd</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'文件打开触发open事件'</span>,fd);</span><br><span class="line">&#125;)</span><br><span class="line">rs.on(<span class="string">'data'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Buffer:'</span>,data);</span><br><span class="line">&#125;)</span><br><span class="line">rs.on(<span class="string">'end'</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'文件读取完毕'</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ReadStream.js</span></span><br><span class="line"><span class="keyword">const</span> Events = <span class="built_in">require</span>(<span class="string">'events'</span>);</span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ReadStream</span> <span class="keyword">extends</span> <span class="title">Events</span></span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(path, options = &#123;&#125;)&#123;</span><br><span class="line">        <span class="keyword">super</span>(); </span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 默认参数的赋值</span></span><br><span class="line">        <span class="keyword">this</span>.path = path;</span><br><span class="line">        <span class="keyword">this</span>.flags = options.flags || <span class="string">'r'</span>;</span><br><span class="line">        <span class="keyword">this</span>.encoding = options.encoding || <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">this</span>.highWaterMark = options.highWaterMark || <span class="number">64</span> * <span class="number">1024</span>;</span><br><span class="line">        <span class="keyword">this</span>.mode = options.mode || <span class="number">438</span>;</span><br><span class="line">        <span class="keyword">this</span>.autoClose = options.autoClose || <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">this</span>.start = options.start | <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">this</span>.end = options.end;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.flowing = <span class="literal">null</span>; </span><br><span class="line">        <span class="keyword">this</span>.offset = <span class="number">0</span>; <span class="comment">// 偏移量</span></span><br><span class="line">        <span class="keyword">this</span>.open(); </span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.on(<span class="string">'newListener'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">type</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(type === <span class="string">'data'</span>)&#123; </span><br><span class="line">                <span class="keyword">this</span>.flowing = <span class="literal">true</span>;</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="string">'开始读取'</span>);</span><br><span class="line">                <span class="keyword">this</span>.read();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    read()&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">typeof</span> <span class="keyword">this</span>.fd !== <span class="string">'number'</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.once(<span class="string">'open'</span>, <span class="keyword">this</span>.read); </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//读文件</span></span><br><span class="line">        <span class="keyword">let</span> buffer = Buffer.alloc(<span class="keyword">this</span>.highWaterMark);</span><br><span class="line">        <span class="comment">// 每次读取2个把buffer填满</span></span><br><span class="line">        fs.read(<span class="keyword">this</span>.fd,buffer,<span class="number">0</span>,<span class="keyword">this</span>.highWaterMark,<span class="keyword">this</span>.offset,(err,bytesRead)=&gt;&#123;</span><br><span class="line">            <span class="keyword">this</span>.offset += bytesRead; </span><br><span class="line">            <span class="keyword">if</span>(bytesRead &gt; <span class="number">0</span>)&#123;<span class="comment">// 如果读取到内容就再次尝试读取</span></span><br><span class="line">                <span class="comment">// 将数据传输给stream.js line17 data中</span></span><br><span class="line">                <span class="keyword">this</span>.emit(<span class="string">'data'</span>, buffer);</span><br><span class="line">                <span class="keyword">this</span>.read();</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">this</span>.emit(<span class="string">'end'</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    open()&#123;</span><br><span class="line">        fs.open(<span class="keyword">this</span>.path, <span class="keyword">this</span>.flags, (err, fd) =&gt;&#123;</span><br><span class="line">			<span class="built_in">console</span>.log(<span class="string">'open~'</span>)</span><br><span class="line">            <span class="keyword">this</span>.fd = fd;</span><br><span class="line">            <span class="keyword">this</span>.emit(<span class="string">'open'</span>,<span class="keyword">this</span>.fd);</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">module</span>.exports = ReadStream;</span><br><span class="line"><span class="comment">/*执行结果：</span></span><br><span class="line"><span class="comment">开始读取</span></span><br><span class="line"><span class="comment">open~</span></span><br><span class="line"><span class="comment">文件打开触发open事件 3</span></span><br><span class="line"><span class="comment">Buffer: &lt;Buffer e4 bd&gt;</span></span><br><span class="line"><span class="comment">Buffer: &lt;Buffer a0 e5&gt;</span></span><br><span class="line"><span class="comment">Buffer: &lt;Buffer a5 bd&gt;</span></span><br><span class="line"><span class="comment">文件读取完毕</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>问题： 现在可以看到 1.txt里面的 你好 占6个字节 现在将左侧 <code>stream.js</code>的line12 end改成4，这样从0-4就是读取5个 运行可以看到结果还是读取了6个 因为line37读取的是this.highWaterMark；如果使用原生的则是读取5个</p>
<h4 id="4】"><a href="#4】" class="headerlink" title="4】"></a>4】</h4><p>howMuchToRead 、close()</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// stream.js</span></span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"><span class="keyword">let</span> ReadStream = <span class="built_in">require</span>(<span class="string">'./ReadStream'</span>);</span><br><span class="line"><span class="keyword">let</span> rs = <span class="keyword">new</span> ReadStream(path.resolve(__dirname, <span class="string">'1.txt'</span>),&#123;</span><br><span class="line">    flags:<span class="string">'r'</span>,</span><br><span class="line">    encoding:<span class="literal">null</span>, </span><br><span class="line">    highWaterMark: <span class="number">2</span>,</span><br><span class="line">    mode:<span class="number">0o666</span>,</span><br><span class="line">    autoClose:<span class="literal">true</span>, </span><br><span class="line">    start:<span class="number">0</span>,</span><br><span class="line">    end:<span class="number">4</span></span><br><span class="line">&#125;)</span><br><span class="line">rs.on(<span class="string">'open'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">fd</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'文件打开触发open事件'</span>,fd);</span><br><span class="line">&#125;)</span><br><span class="line">rs.on(<span class="string">'data'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'buffer:'</span>,data);</span><br><span class="line">&#125;)</span><br><span class="line">rs.on(<span class="string">'end'</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'文件读取完毕'</span>);</span><br><span class="line">&#125;)</span><br><span class="line">rs.on(<span class="string">'close'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'文件关闭'</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ReadStream.js</span></span><br><span class="line"><span class="keyword">const</span> Events = <span class="built_in">require</span>(<span class="string">'events'</span>);</span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ReadStream</span> <span class="keyword">extends</span> <span class="title">Events</span></span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(path, options = &#123;&#125;)&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 默认参数的赋值</span></span><br><span class="line">        <span class="keyword">this</span>.path = path;</span><br><span class="line">        <span class="keyword">this</span>.flags = options.flags || <span class="string">'r'</span>;</span><br><span class="line">        <span class="keyword">this</span>.encoding = options.encoding || <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">this</span>.highWaterMark = options.highWaterMark || <span class="number">64</span> * <span class="number">1024</span>;</span><br><span class="line">        <span class="keyword">this</span>.mode = options.mode || <span class="number">438</span>;</span><br><span class="line">        <span class="keyword">this</span>.autoClose = options.autoClose || <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">this</span>.start = options.start | <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">this</span>.end = options.end;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.flowing = <span class="literal">null</span>; </span><br><span class="line">        <span class="keyword">this</span>.offset = <span class="number">0</span>; <span class="comment">// 偏移量</span></span><br><span class="line">        <span class="keyword">this</span>.open(); </span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.on(<span class="string">'newListener'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">type</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(type === <span class="string">'data'</span>)&#123; </span><br><span class="line">                <span class="keyword">this</span>.flowing = <span class="literal">true</span>;</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="string">'开始读取'</span>);</span><br><span class="line">                <span class="keyword">this</span>.read();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    read()&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">typeof</span> <span class="keyword">this</span>.fd !== <span class="string">'number'</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.once(<span class="string">'open'</span>, <span class="keyword">this</span>.read); </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 每次读取2个把buffer填满</span></span><br><span class="line">        <span class="comment">// 一共读取几个 this.end - this.start + 1   4-0+1 = 5个</span></span><br><span class="line">        <span class="comment">// 现在是 2 2 2</span></span><br><span class="line">        <span class="comment">// 应该是 2 2 1</span></span><br><span class="line">        <span class="keyword">let</span> howMuchToRead = <span class="keyword">this</span>.end ? <span class="built_in">Math</span>.min(<span class="keyword">this</span>.highWaterMark, <span class="keyword">this</span>.end - <span class="keyword">this</span>.start + <span class="number">1</span> - <span class="keyword">this</span>.offset) : <span class="keyword">this</span>.highWaterMark;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> buffer = Buffer.alloc(howMuchToRead);</span><br><span class="line"></span><br><span class="line">        fs.read(<span class="keyword">this</span>.fd,buffer,<span class="number">0</span>,howMuchToRead,<span class="keyword">this</span>.offset,(err,bytesRead)=&gt;&#123;</span><br><span class="line">            <span class="keyword">this</span>.offset += bytesRead; </span><br><span class="line">            <span class="keyword">if</span>(bytesRead &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">this</span>.emit(<span class="string">'data'</span>, buffer);</span><br><span class="line">                <span class="keyword">this</span>.read();</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">this</span>.emit(<span class="string">'end'</span>);</span><br><span class="line">                <span class="keyword">this</span>.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    close()&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.autoClose)&#123;</span><br><span class="line">            fs.close(<span class="keyword">this</span>.fd,()=&gt; &#123;</span><br><span class="line">                <span class="keyword">this</span>.emit(<span class="string">'close'</span>);</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    open()&#123;</span><br><span class="line">        fs.open(<span class="keyword">this</span>.path, <span class="keyword">this</span>.flags, (err, fd) =&gt;&#123;</span><br><span class="line">			<span class="built_in">console</span>.log(<span class="string">'open~'</span>);</span><br><span class="line">            <span class="keyword">this</span>.fd = fd;</span><br><span class="line">            <span class="keyword">this</span>.emit(<span class="string">'open'</span>,<span class="keyword">this</span>.fd);</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">module</span>.exports = ReadStream;</span><br><span class="line"><span class="comment">/*执行结果：</span></span><br><span class="line"><span class="comment">开始读取</span></span><br><span class="line"><span class="comment">open~</span></span><br><span class="line"><span class="comment">文件打开触发open事件 3</span></span><br><span class="line"><span class="comment">buffer: &lt;Buffer e4 bd&gt;</span></span><br><span class="line"><span class="comment">buffer: &lt;Buffer a0 e5&gt;</span></span><br><span class="line"><span class="comment">buffer: &lt;Buffer a5&gt;</span></span><br><span class="line"><span class="comment">文件读取完毕</span></span><br><span class="line"><span class="comment">文件关闭</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h4 id="5】"><a href="#5】" class="headerlink" title="5】"></a>5】</h4><p>pause() 、resume()</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这里引用原生 fs.createReadStream</span></span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"><span class="keyword">let</span> ReadStream = <span class="built_in">require</span>(<span class="string">'./ReadStream'</span>);</span><br><span class="line"><span class="keyword">let</span> rs = fs.createReadStream(path.resolve(__dirname, <span class="string">'1.txt'</span>),&#123;</span><br><span class="line">    flags:<span class="string">'r'</span>,</span><br><span class="line">    encoding:<span class="literal">null</span>, </span><br><span class="line">    highWaterMark: <span class="number">2</span>,</span><br><span class="line">    mode:<span class="number">0o666</span>,</span><br><span class="line">    autoClose:<span class="literal">true</span>, </span><br><span class="line">    start:<span class="number">0</span>,</span><br><span class="line">    end:<span class="number">4</span></span><br><span class="line">&#125;)</span><br><span class="line">rs.on(<span class="string">'open'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">fd</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'文件打开触发open事件'</span>,fd);</span><br><span class="line">&#125;)</span><br><span class="line">rs.on(<span class="string">'data'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'buffer:'</span>,data);<span class="comment">// 只读取了2个 buffer: &lt;Buffer e4 bd&gt;</span></span><br><span class="line">    rs.pause();  <span class="comment">// 暂停  </span></span><br><span class="line">&#125;)</span><br><span class="line">setInterval(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    rs.resume(); <span class="comment">// 每隔2秒开启读取</span></span><br><span class="line">&#125;, <span class="number">2000</span>);</span><br><span class="line">rs.on(<span class="string">'close'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'文件关闭'</span>);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">/*执行结果</span></span><br><span class="line"><span class="comment">文件打开触发open事件 3</span></span><br><span class="line"><span class="comment">buffer: &lt;Buffer e4 bd&gt;</span></span><br><span class="line"><span class="comment">buffer: &lt;Buffer a0 e5&gt; （隔2秒打印）</span></span><br><span class="line"><span class="comment">buffer: &lt;Buffer a5&gt;    （隔2秒打印）</span></span><br><span class="line"><span class="comment">文件关闭</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>引用改成自己手写的ReadStream<br>this.flowing</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// stream.js</span></span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"><span class="keyword">let</span> ReadStream = <span class="built_in">require</span>(<span class="string">'./ReadStream'</span>);</span><br><span class="line"><span class="keyword">let</span> rs = <span class="keyword">new</span> ReadStream(path.resolve(__dirname, <span class="string">'1.txt'</span>),&#123;</span><br><span class="line">    flags:<span class="string">'r'</span>,</span><br><span class="line">    encoding:<span class="literal">null</span>, </span><br><span class="line">    highWaterMark: <span class="number">2</span>,</span><br><span class="line">    mode:<span class="number">0o666</span>,</span><br><span class="line">    autoClose:<span class="literal">true</span>, </span><br><span class="line">    start:<span class="number">0</span>,</span><br><span class="line">    end:<span class="number">4</span></span><br><span class="line">&#125;)</span><br><span class="line">rs.on(<span class="string">'open'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">fd</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'文件打开触发open事件'</span>,fd);</span><br><span class="line">&#125;)</span><br><span class="line">rs.on(<span class="string">'data'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'buffer:'</span>,data);</span><br><span class="line">    rs.pause(); <span class="comment">// 暂停</span></span><br><span class="line">&#125;)</span><br><span class="line">setInterval(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    rs.resume(); <span class="comment">// 每隔2秒开启读取</span></span><br><span class="line">&#125;, <span class="number">2000</span>);</span><br><span class="line">rs.on(<span class="string">'close'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'文件关闭'</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ReadStream.js</span></span><br><span class="line"><span class="keyword">const</span> Events = <span class="built_in">require</span>(<span class="string">'events'</span>);</span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ReadStream</span> <span class="keyword">extends</span> <span class="title">Events</span></span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(path, options = &#123;&#125;)&#123;</span><br><span class="line">        <span class="keyword">super</span>(); </span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 默认参数的赋值</span></span><br><span class="line">        <span class="keyword">this</span>.path = path;</span><br><span class="line">        <span class="keyword">this</span>.flags = options.flags || <span class="string">'r'</span>;</span><br><span class="line">        <span class="keyword">this</span>.encoding = options.encoding || <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">this</span>.highWaterMark = options.highWaterMark || <span class="number">64</span> * <span class="number">1024</span>;</span><br><span class="line">        <span class="keyword">this</span>.mode = options.mode || <span class="number">438</span>;</span><br><span class="line">        <span class="keyword">this</span>.autoClose = options.autoClose || <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">this</span>.start = options.start | <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">this</span>.end = options.end;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.flowing = <span class="literal">null</span>;  <span class="comment">// *******************************flowing</span></span><br><span class="line">        <span class="keyword">this</span>.offset = <span class="number">0</span>; <span class="comment">// 偏移量</span></span><br><span class="line">        <span class="keyword">this</span>.temp = <span class="literal">true</span>; <span class="comment">// resume方法里是否执行read()的标识 ********************temp</span></span><br><span class="line">        <span class="keyword">this</span>.open(); </span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.on(<span class="string">'newListener'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">type</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(type === <span class="string">'data'</span>)&#123; </span><br><span class="line">                <span class="keyword">this</span>.flowing = <span class="literal">true</span>;  <span class="comment">// *******************************flowing</span></span><br><span class="line">                <span class="built_in">console</span>.log(<span class="string">'开始读取'</span>);</span><br><span class="line">                <span class="keyword">this</span>.read();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    read()&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">typeof</span> <span class="keyword">this</span>.fd !== <span class="string">'number'</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.once(<span class="string">'open'</span>, <span class="keyword">this</span>.read); </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">let</span> howMuchToRead = <span class="keyword">this</span>.end ? <span class="built_in">Math</span>.min(<span class="keyword">this</span>.highWaterMark, <span class="keyword">this</span>.end - <span class="keyword">this</span>.start + <span class="number">1</span> - <span class="keyword">this</span>.offset) : <span class="keyword">this</span>.highWaterMark;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> buffer = Buffer.alloc(howMuchToRead);</span><br><span class="line"></span><br><span class="line">        fs.read(<span class="keyword">this</span>.fd,buffer,<span class="number">0</span>,howMuchToRead,<span class="keyword">this</span>.offset,(err,bytesRead)=&gt;&#123;</span><br><span class="line">            <span class="keyword">this</span>.offset += bytesRead; </span><br><span class="line">            <span class="keyword">if</span>(bytesRead &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">this</span>.emit(<span class="string">'data'</span>, buffer);</span><br><span class="line">                <span class="keyword">this</span>.flowing &amp;&amp; <span class="keyword">this</span>.read(); <span class="comment">// flowing为true时  *******************************flowing</span></span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">this</span>.temp = <span class="literal">false</span>; <span class="comment">// // *******************************temp</span></span><br><span class="line">                <span class="keyword">this</span>.emit(<span class="string">'end'</span>);</span><br><span class="line">                <span class="keyword">this</span>.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    close()&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.autoClose)&#123;</span><br><span class="line">            fs.close(<span class="keyword">this</span>.fd,()=&gt; &#123;</span><br><span class="line">                <span class="keyword">this</span>.emit(<span class="string">'close'</span>);</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    open()&#123;</span><br><span class="line">        fs.open(<span class="keyword">this</span>.path, <span class="keyword">this</span>.flags, (err, fd) =&gt;&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'open~'</span>);</span><br><span class="line">            <span class="keyword">this</span>.fd = fd;</span><br><span class="line">            <span class="keyword">this</span>.emit(<span class="string">'open'</span>,<span class="keyword">this</span>.fd);</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    pause()&#123;</span><br><span class="line">        <span class="keyword">this</span>.flowing = <span class="literal">false</span>; <span class="comment">// *******************************flowing</span></span><br><span class="line">    &#125;</span><br><span class="line">    resume()&#123;</span><br><span class="line">        <span class="keyword">this</span>.flowing = <span class="literal">true</span>; <span class="comment">// *******************************flowing</span></span><br><span class="line">        <span class="keyword">this</span>.temp &amp;&amp; <span class="keyword">this</span>.read(); <span class="comment">// *******************************temp</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">module</span>.exports = ReadStream;</span><br><span class="line"><span class="comment">/*执行结果：</span></span><br><span class="line"><span class="comment">开始读取</span></span><br><span class="line"><span class="comment">open~</span></span><br><span class="line"><span class="comment">文件打开触发open事件 3</span></span><br><span class="line"><span class="comment">buffer: &lt;Buffer e4 bd&gt;</span></span><br><span class="line"><span class="comment">buffer: &lt;Buffer a0 e5&gt;   （隔2秒打印）</span></span><br><span class="line"><span class="comment">buffer: &lt;Buffer a5&gt;      （隔2秒打印）</span></span><br><span class="line"><span class="comment">文件关闭                  （隔2秒打印）</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>可读流</p>
</blockquote>
<ul>
<li>如何将多个 有关系的异步代码进行拆分  read() open()  发布订阅</li>
</ul>
<blockquote>
<p>可写流</p>
</blockquote>
<ul>
<li>如何处理并发操作文件 多个异步 造队列 =&gt; 链表</li>
</ul>
]]></content>
      <categories>
        <category>Nodejs</category>
      </categories>
      <tags>
        <tag>Nodejs</tag>
        <tag>文件系统 fs</tag>
      </tags>
  </entry>
  <entry>
    <title>Nodejs fs （一）</title>
    <url>/2019/09/25/Node-fs/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote>
<p>flie system 可以在服务端读取文件和数据 方法是同步+异步共存<br>同步方法易使用(刚开始可以用同步)<br>异步方法不会阻塞主线程（程序运行起来之后可以用异步 回调函数）</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="keyword">let</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读取文件 文件不存在会报错</span></span><br><span class="line"><span class="comment">// 写入文件 文件不存在会创建文件</span></span><br><span class="line">fs.readFile(path.resolve(__dirname,<span class="string">'./note.md'</span>),<span class="function"><span class="keyword">function</span>(<span class="params">err, data</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(err) <span class="built_in">console</span>.log(err);</span><br><span class="line">    fs.writeFile(path.resolve(__dirname,<span class="string">'./note1.md'</span>), data, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<blockquote>
<p>分析：先将note.md中的内容全部读取到内存中，再将内存写入note1中。如果文件非常大，这样就会很消耗内存，所以不适合大文件来使用，可能会导致内存的浪费 性能不高。<br>所以可以读取一些 写入一些</p>
</blockquote>
<h3 id="fs-Buffer"><a href="#fs-Buffer" class="headerlink" title="fs + Buffer"></a>fs + Buffer</h3><blockquote>
<p>手动按照字节读取 fs.open  fs.read fs.write  fs.close</p>
</blockquote>
<p>fs.open</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// r 读取  </span></span><br><span class="line"><span class="comment">// w 写入</span></span><br><span class="line"><span class="comment">// r+ 在读的基础上可以写 但是文件不存在会报错</span></span><br><span class="line"><span class="comment">// w+ 在写的基础上可以读取 如果文件不存在会创建</span></span><br><span class="line"><span class="keyword">let</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="keyword">let</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line">fs.open(path.resolve(__dirname,<span class="string">'./note.md'</span>), <span class="string">'r'</span>, (err, fd)=&gt;&#123; <span class="comment">// fd:file descriptor 文件描述符</span></span><br><span class="line">    <span class="built_in">console</span>.log(fd);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<ul>
<li>现在希望每次读3个再写入</li>
</ul>
<p>fs.open + fs.read + fs.close + Buffer</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="keyword">let</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"><span class="keyword">let</span> buffer = Buffer.alloc(<span class="number">3</span>);</span><br><span class="line">fs.open(path.resolve(__dirname,<span class="string">'./note.md'</span>), <span class="string">'r'</span>, (err, fd)=&gt;&#123;<span class="comment">// fd类似于一个标识，代表读取的文件名和'r'这个操作  是number类型</span></span><br><span class="line">    <span class="comment">// 读取文件 fd代表文件 buffer代表要把读取的内容放到哪个Buffer中</span></span><br><span class="line">    <span class="comment">// 0,3 从buffer的第0个位置写入 写入3个</span></span><br><span class="line">    <span class="comment">// 0 从文件的哪个位置读取</span></span><br><span class="line">    fs.read(fd,buffer,<span class="number">0</span>,<span class="number">3</span>,<span class="number">0</span>, <span class="function"><span class="keyword">function</span>(<span class="params">err, bytesRead</span>)</span>&#123; <span class="comment">// bytesRead真正读取到的个数</span></span><br><span class="line">        <span class="built_in">console</span>.log(bytesRead, buffer);</span><br><span class="line">        fs.close(fd, ()=&gt;&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'close'</span>);</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 3 &lt;Buffer e4 bd a0&gt;  close</span></span><br></pre></td></tr></table></figure>

<ul>
<li>写入  在读的过程中写入</li>
</ul>
<p>fs.open + fs.read + fs.write + Buffer</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="keyword">let</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"><span class="keyword">let</span> buffer = Buffer.alloc(<span class="number">3</span>);</span><br><span class="line">fs.open(path.resolve(__dirname,<span class="string">'./note.md'</span>), <span class="string">'r'</span>, (err, rfd)=&gt;&#123;</span><br><span class="line">    <span class="comment">// 读取文件 fd代表文件 buffer代表要把读取的内容放到哪个Buffer中</span></span><br><span class="line">    <span class="comment">// 0,3 从buffer的第0个位置写入 写入3个</span></span><br><span class="line">    <span class="comment">// 0 从文件的哪个位置读取</span></span><br><span class="line">    fs.open(path.resolve(__dirname,<span class="string">'./note1.md'</span>), <span class="string">'w'</span>, (err,wfd)=&gt;&#123;</span><br><span class="line">        <span class="comment">// 读取的过程是将读取到的内容 写入到buffer中</span></span><br><span class="line">        <span class="comment">// 写入文件的过程是将buffer中的内容读取出来写到文件中</span></span><br><span class="line">        fs.read(rfd,buffer,<span class="number">0</span>,<span class="number">3</span>,<span class="number">0</span>, <span class="function"><span class="keyword">function</span>(<span class="params">err, bytesRead</span>)</span>&#123;  <span class="comment">// bytesRead真正读取到的个数</span></span><br><span class="line">            fs.write(wfd,buffer,<span class="number">0</span>,<span class="number">3</span>,<span class="number">0</span>, <span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line">                </span><br><span class="line">            &#125;)</span><br><span class="line">            <span class="comment">// fs.write(wfd,buffer,0,3,3, function(err) &#123;</span></span><br><span class="line">                </span><br><span class="line">            <span class="comment">// &#125;)</span></span><br><span class="line">            <span class="comment">// fs.write(wfd,buffer,0,3,6, function(err) &#123;</span></span><br><span class="line">                </span><br><span class="line">            <span class="comment">// &#125;)</span></span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// node.md  1234567890</span></span><br><span class="line"><span class="comment">// 现在将line15-20注释打开 可以看到note1.md里面一直追加存入123123123</span></span><br></pre></td></tr></table></figure>

<ul>
<li>writeFileSync 、appendFileSync</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="keyword">let</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line">fs.writeFileSync(path.resolve(__dirname,<span class="string">'note2.md'</span>), <span class="string">'123'</span>);</span><br><span class="line">fs.writeFileSync(path.resolve(__dirname,<span class="string">'note2.md'</span>), <span class="string">'123'</span>);<span class="comment">// 如果文件存在，会将文件中的内容情况 覆盖</span></span><br><span class="line">fs.writeFileSync(path.resolve(__dirname,<span class="string">'note2.md'</span>), <span class="string">'123'</span>);</span><br><span class="line"><span class="comment">// 123</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如下 追加</span></span><br><span class="line"><span class="keyword">let</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="keyword">let</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line">fs.writeFileSync(path.resolve(__dirname,<span class="string">'note3.md'</span>), <span class="string">'123'</span>);</span><br><span class="line">fs.writeFileSync(path.resolve(__dirname,<span class="string">'note3.md'</span>), <span class="string">'123'</span>,&#123;<span class="attr">flag</span>:<span class="string">'a'</span>&#125;);</span><br><span class="line">fs.writeFileSync(path.resolve(__dirname,<span class="string">'note3.md'</span>), <span class="string">'123'</span>,&#123;<span class="attr">flag</span>:<span class="string">'a'</span>&#125;);</span><br><span class="line"><span class="comment">// 123123123</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line"><span class="keyword">let</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="keyword">let</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"><span class="comment">// 写入时 没有会创建 有会追加</span></span><br><span class="line">fs.appendFileSync(path.resolve(__dirname,<span class="string">'note4.md'</span>), <span class="string">'123'</span>);</span><br><span class="line">fs.appendFileSync(path.resolve(__dirname,<span class="string">'note4.md'</span>), <span class="string">'123'</span>);</span><br><span class="line">fs.appendFileSync(path.resolve(__dirname,<span class="string">'note4.md'</span>), <span class="string">'123'</span>);</span><br><span class="line"><span class="comment">// 123123123</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>两个耦合性比较高的代码 怎么拆分， 发布订阅  =&gt;  流</p>
</blockquote>
<ul>
<li>读取一点写一点 不会导致淹没可用内存</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"><span class="comment">// 读取一点写一点 不会导致淹没可用内存</span></span><br><span class="line"><span class="keyword">const</span> SIZE = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">let</span> buffer = Buffer.alloc(SIZE);</span><br><span class="line">fs.open(path.resolve(__dirname,<span class="string">'note.md'</span>), <span class="string">'r'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err, rfd</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(err) <span class="keyword">return</span> <span class="built_in">console</span>.log(err);</span><br><span class="line"></span><br><span class="line">    fs.open(path.resolve(__dirname,<span class="string">'copy.md'</span>), <span class="string">'w'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err, wfd</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(err)  <span class="keyword">return</span> <span class="built_in">console</span>.log(err);</span><br><span class="line">        <span class="keyword">let</span> readOffset = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">let</span> writeOffset = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// co</span></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">next</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            fs.read(rfd,buffer,<span class="number">0</span>,SIZE,readOffset, <span class="function"><span class="keyword">function</span> (<span class="params">err, bytesRead</span>) </span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(bytesRead === <span class="number">0</span>)&#123;</span><br><span class="line">                    fs.close(rfd, ()=&gt;&#123;&#125;);</span><br><span class="line">                    fs.close(wfd, ()=&gt;&#123;&#125;);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                fs.write(wfd,buffer,<span class="number">0</span>,bytesRead,writeOffset,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">                    readOffset += bytesRead;</span><br><span class="line">                    writeOffset += bytesRead;</span><br><span class="line">                    next();</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">        next();</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// copy.md    1234567890</span></span><br></pre></td></tr></table></figure>

<h2 id="fs操作文件"><a href="#fs操作文件" class="headerlink" title="fs操作文件"></a>fs操作文件</h2><blockquote>
<p>文件的操作</p>
</blockquote>
<ul>
<li>fs.readFile  、fs.existSync 、fs.access</li>
<li>fs.writeFile 、fs.copyFile()</li>
<li>fs.rename  、fs.unlink  </li>
</ul>
<blockquote>
<p>文件夹的操作</p>
</blockquote>
<ul>
<li>创建目录 mkdir   </li>
<li>删除目录 rmdir  </li>
<li>读取目录 readdir</li>
</ul>
<blockquote>
<p>fs.stat 提供了关于文件的信息(文件状态)</p>
</blockquote>
<ul>
<li>删除文件 重命名</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"><span class="comment">// 重命名</span></span><br><span class="line">fs.rename(path.resolve(__dirname, <span class="string">'copy.md'</span>), path.resolve(__dirname, <span class="string">'c.md'</span>),<span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 删除</span></span><br><span class="line">fs.unlink(path.resolve(__dirname, <span class="string">'c.md'</span>), <span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="创建目录"><a href="#创建目录" class="headerlink" title="创建目录"></a>创建目录</h3><blockquote>
<p>创建目录 必须是存在的文件夹才能向下创建</p>
</blockquote>
<ul>
<li>mkdirSync 、mkdir创建文件夹</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 现有a/文件夹</span></span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line">fs.mkdirSync(<span class="string">'a/b'</span>);  </span><br><span class="line"><span class="comment">// 直接a/b/c/d 这里只有a/b文件夹，不能直接创建到d</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line">fs.mkdir(<span class="string">'a/b/c/d'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(err) <span class="built_in">console</span>.log(err); <span class="comment">// 这样就会报错  只能先创建  a/b/c</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<ul>
<li>现在希望实现 mkdir(‘a/b/c/d’)</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mkdir</span>(<span class="params">paths, callback</span>)</span>&#123;</span><br><span class="line">    paths = paths.split(<span class="string">'/'</span>);</span><br><span class="line">    <span class="keyword">let</span> index = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 这里用异步的方式创建 创建完a之后再创建b再创建c、d 异步迭代的模式</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">next</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(index === paths.length + <span class="number">1</span>) <span class="keyword">return</span> callback();</span><br><span class="line">        <span class="keyword">let</span> dirPath = paths.slice(<span class="number">0</span>, index++).join(<span class="string">'/'</span>);</span><br><span class="line">        fs.access(dirPath, <span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(err)&#123;</span><br><span class="line">                <span class="comment">// 不存在</span></span><br><span class="line">                fs.mkdir(dirPath,next);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123; <span class="comment">// 存在创建下一层</span></span><br><span class="line">                next();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    next();</span><br><span class="line">&#125;</span><br><span class="line">mkdir(<span class="string">'a/b/c/d'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'创建完成'</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="删除目录"><a href="#删除目录" class="headerlink" title="删除目录"></a>删除目录</h3><blockquote>
<p>删除目录 包含子目录不能删除</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 删除目录</span></span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line">fs.rmdir(<span class="string">'a'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err); <span class="comment">// 报错 a目录下有子目录</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line">fs.readdir(<span class="string">'a'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">err, dirs</span>)</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(dirs); <span class="comment">// 返回的是数组 ['b']</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<ul>
<li>删除a文件夹下的文件夹或文件 这里只有一层</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line">fs.readdir(<span class="string">'a'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">err,dirs</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(dirs)</span><br><span class="line">    dirs = dirs.map(<span class="function"><span class="params">dir</span>=&gt;</span>path.join(<span class="string">'a'</span>,dir));</span><br><span class="line">    <span class="built_in">console</span>.log(dirs);</span><br><span class="line">    dirs.forEach(<span class="function"><span class="params">dir</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="comment">// 判断当前路径的状态</span></span><br><span class="line">        fs.stat(dir,<span class="function"><span class="keyword">function</span>(<span class="params">err,statObj</span>)</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(statObj.isFile())&#123;</span><br><span class="line">                fs.unlink(dir,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                fs.rmdir(dir,()=&gt;&#123;&#125;)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h4 id="递归删除目录"><a href="#递归删除目录" class="headerlink" title="递归删除目录"></a>递归删除目录</h4><blockquote>
<p>其实就是树的遍历 </p>
</blockquote>
<ul>
<li>先序深度遍历</li>
</ul>
<p><img src="https://jiafei2333.github.io/html/images/Tree-Traversal.png" alt title="树的遍历"></p>
<p>深度 先序 串联</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">preSeriesDeep</span>(<span class="params">dir, callback</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 有儿子就删除儿子</span></span><br><span class="line">    <span class="comment">// 儿子删除完毕后删除自己 考虑的时候只考虑第一层和第二层，后面的都是一样的</span></span><br><span class="line">    fs.stat(dir, <span class="function"><span class="keyword">function</span>(<span class="params">err, statObj</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(statObj.isFile())&#123; <span class="comment">// 是文件就删除</span></span><br><span class="line">            fs.unlink(dir, callback);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123; <span class="comment">// 是文件夹</span></span><br><span class="line">            fs.readdir(dir, <span class="function"><span class="keyword">function</span>(<span class="params">err,dirs</span>)</span>&#123;</span><br><span class="line">                <span class="comment">// dirs 是读到的儿子 // [ '1.js', 'b', 'e' ]</span></span><br><span class="line">                dirs = dirs.map( <span class="function"><span class="params">item</span>=&gt;</span> path.join(dir, item));</span><br><span class="line">                <span class="keyword">let</span> index = <span class="number">0</span>;</span><br><span class="line">                <span class="function"><span class="keyword">function</span> <span class="title">next</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">                    <span class="keyword">if</span>(index === dirs.length) <span class="keyword">return</span> fs.rmdir(dir, callback);</span><br><span class="line">                    <span class="keyword">let</span> dirPath = dirs[index++];</span><br><span class="line">                    <span class="comment">// 删除当前第一个儿子 成功后删除第二个儿子</span></span><br><span class="line">                    preSeriesDeep(dirPath, next);</span><br><span class="line">                &#125;</span><br><span class="line">                next(); <span class="comment">// 取出第一个删掉</span></span><br><span class="line">                </span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line">preSeriesDeep(<span class="string">'a'</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"删除成功"</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>分析：如图，现在删除的顺序是c、d删除，再删b再删e，其实删cdb和e没有必然关系，这样就会导致性能上的劣势。所以可以cdb自己删自己的，e包括它下面的自己删自己的，同一层的全部删除完毕之后 告诉上一层，如这里的a，然后再删除a 上面可以理解为串联的删。</p>
</blockquote>
<p>并发的删除</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">preparallelDeep</span>(<span class="params">dir, callback</span>)</span>&#123;</span><br><span class="line">    fs.stat(dir, <span class="function"><span class="keyword">function</span>(<span class="params">err, statObj</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(statObj.isFile())&#123; <span class="comment">// 是文件就删除</span></span><br><span class="line">            fs.unlink(dir, callback);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            fs.readdir(dir, <span class="function"><span class="keyword">function</span>(<span class="params">err,dirs</span>)</span>&#123;</span><br><span class="line">                dirs = dirs.map( <span class="function"><span class="params">item</span>=&gt;</span> path.join(dir, item));</span><br><span class="line">                <span class="comment">// 如果没有儿子节点，直接将自己删除即可</span></span><br><span class="line">                <span class="keyword">if</span>(dirs.length === <span class="number">0</span>) <span class="keyword">return</span> fs.rmdir(dir, callback);</span><br><span class="line">                <span class="keyword">let</span> index = <span class="number">0</span>;</span><br><span class="line">                <span class="function"><span class="keyword">function</span> <span class="title">done</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">                    <span class="comment">// index ++;</span></span><br><span class="line">                    <span class="comment">// if(index === dirs.length)&#123;</span></span><br><span class="line">                    <span class="comment">//     return fs.rmdir(dir, callback);</span></span><br><span class="line">                    <span class="comment">// &#125;</span></span><br><span class="line">                    <span class="comment">// 简写</span></span><br><span class="line">                    <span class="keyword">if</span>(++index === dirs.length) <span class="keyword">return</span> fs.rmdir(dir, callback);</span><br><span class="line">                &#125;</span><br><span class="line">                dirs.forEach( <span class="function"><span class="params">dir</span>=&gt;</span>&#123;</span><br><span class="line">                    preparallelDeep(dir, done)</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line">preparallelDeep(<span class="string">'a'</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"删除成功"</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>上面的代码还是有点复杂 只要是异步的其实都可以用Promise</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">preDeep</span>(<span class="params">dir</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>( <span class="function">(<span class="params">resolve, reject</span>) =&gt;</span>&#123;</span><br><span class="line">        fs.stat(dir,<span class="function"><span class="keyword">function</span>(<span class="params">err, statObj</span>)</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(statObj.isFile())&#123;</span><br><span class="line">                fs.unlink(dir,resolve); <span class="comment">// 这行注意下 自己想的时候没想到这样放，在下一行resolve() 了</span></span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                fs.readdir(dir, <span class="function"><span class="keyword">function</span>(<span class="params">err, dirs</span>) </span>&#123;</span><br><span class="line">                    dirs = dirs.map( <span class="function"><span class="params">item</span> =&gt;</span> preDeep(path.join(dir, item)));</span><br><span class="line">                    <span class="built_in">Promise</span>.all(dirs).then(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">                        fs.rmdir(dir,resolve); <span class="comment">// 这行也是</span></span><br><span class="line">                    &#125;)</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">preDeep(<span class="string">'a'</span>).then(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'删除成功'</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>async + await 后序都会这样写 重要</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123;unlink, readdir, stat, rmdir&#125; = <span class="built_in">require</span>(<span class="string">'fs'</span>).promises;</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">preDeep</span>(<span class="params">dir</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> statObj = <span class="keyword">await</span> stat(dir);</span><br><span class="line">    <span class="keyword">if</span>(statObj.isFile())&#123;</span><br><span class="line">        <span class="keyword">await</span> unlink(dir);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">let</span> dirs = <span class="keyword">await</span> readdir(dir);  <span class="comment">// generator  await是它的语法糖</span></span><br><span class="line">        dirs = dirs.map( <span class="function"><span class="params">item</span> =&gt;</span> preDeep(path.join(dir,item)));</span><br><span class="line">        <span class="keyword">await</span> <span class="built_in">Promise</span>.all(dirs);</span><br><span class="line">        <span class="keyword">await</span> rmdir(dir);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">preDeep(<span class="string">'a'</span>).then(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'删除成功'</span>);</span><br><span class="line">&#125;).catch(<span class="function"><span class="params">err</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"捕获错误"</span>, err)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<ul>
<li>广度遍历</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">wide</span>(<span class="params">dir</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> arr = [dir];</span><br><span class="line">    <span class="keyword">let</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> current = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">while</span> (current = arr[index++]) &#123;</span><br><span class="line">        <span class="keyword">let</span> dirs = fs.readdirSync(current);</span><br><span class="line">        dirs = dirs.map( <span class="function"><span class="params">item</span> =&gt;</span> path.join(current, item));</span><br><span class="line">        arr = [...arr, ...dirs];</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// 循环arr删除即可</span></span><br><span class="line">    <span class="built_in">console</span>.log(arr);</span><br><span class="line">&#125;</span><br><span class="line">wide(<span class="string">'a'</span>);</span><br><span class="line"><span class="comment">// [ 'a', 'a/b', 'a/e', 'a/b/c', 'a/b/c/d' ]</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Nodejs</category>
      </categories>
  </entry>
  <entry>
    <title>Node-Buffer</title>
    <url>/2019/09/25/Node-Buffer/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><blockquote>
<p>默认文件读取操作， 读取出来的都是buffer<br>  内存的表示方式就是Buffer ，内存二进制的 、Buffer十六进制的</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// node.md</span><br><span class="line">你好</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="keyword">let</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> r = fs.readFileSync(path.resolve(__dirname, <span class="string">'note.md'</span>));</span><br><span class="line"><span class="built_in">console</span>.log(r);</span><br><span class="line"><span class="comment">// &lt;Buffer e4 bd a0 e5 a5 bd&gt;</span></span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h3 id="进制转化"><a href="#进制转化" class="headerlink" title="进制转化"></a>进制转化</h3><blockquote>
<ul>
<li>将任意进制转化成任意进制：<ul>
<li>xxx.toString(‘xxx’); 只是值会变成字符串 </li>
<li>toString(‘utf8’ || ‘base64’);   不支持gbk</li>
</ul>
</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>将任意进制转化成十进制<ul>
<li>parseInt(‘0xff’,16); // 十六进制 =&gt; 十进制</li>
</ul>
</li>
</ul>
</blockquote>
<ul>
<li>示例</li>
</ul>
<blockquote>
<p>0.1 + 0.2 != 0.3 </p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 我们需要将值存到内存中 保存的时候存储的是二进制</span></span><br><span class="line"><span class="number">0.0001100110011001100110011001100110011001100110011001101</span>   <span class="number">0.1</span></span><br><span class="line"><span class="number">0.001100110011001100110011001100110011001100110011001101</span>    <span class="number">0.2</span></span><br></pre></td></tr></table></figure>

<ul>
<li>进制转化 小数 *2 取整法</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 0.1如何变成二进制 如下：</span></span><br><span class="line"><span class="number">0.1</span> * <span class="number">2</span> = <span class="number">0.2</span> =&gt;<span class="number">0</span> </span><br><span class="line"><span class="number">0.2</span> * <span class="number">2</span> = <span class="number">0.4</span> =&gt;<span class="number">0</span></span><br><span class="line"><span class="number">0.4</span> * <span class="number">2</span> = <span class="number">0.8</span> =&gt;<span class="number">0</span></span><br><span class="line"><span class="number">0.8</span> * <span class="number">2</span> = <span class="number">1.6</span> =&gt;<span class="number">1</span></span><br><span class="line"><span class="number">0.6</span> * <span class="number">2</span> = <span class="number">1.2</span> =&gt;<span class="number">1</span></span><br><span class="line"><span class="number">0.2</span> * <span class="number">2</span> = <span class="number">0.4</span> =&gt;<span class="number">0</span> </span><br><span class="line"><span class="number">0.4</span> * <span class="number">2</span> = <span class="number">0.8</span> =&gt;<span class="number">0</span></span><br><span class="line"><span class="number">0.8</span> * <span class="number">2</span> = <span class="number">1.6</span> =&gt;<span class="number">1</span></span><br><span class="line">...循环</span><br></pre></td></tr></table></figure>

<ul>
<li><p>整数 进制转化 基于编码<br>ASCII(美国) 默认 就一个字节来表示是一个字母或者符号<br>1个字节 有8个bit 最大是 8个1 =&gt; 10进制 255<br>默认 字母 常见符号 \r \n<br>gbk 用两个字节来表示中文<br>utf-8 用两个字节来表示中文</p>
</li>
<li><p>将10进制 转化成其他进制 0xff 0b 0o</p>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="number">100.</span>.toString(<span class="number">16</span>)); <span class="comment">// 64 值变成了字符串</span></span><br><span class="line"><span class="built_in">console</span>.log((<span class="number">100</span>).toString(<span class="number">16</span>)); <span class="comment">// 64 值变成了字符串</span></span><br></pre></td></tr></table></figure>

<ul>
<li>十六进制转化成十进制 </li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log((<span class="number">0xff</span>).toString(<span class="number">10</span>)); <span class="comment">// 255</span></span><br><span class="line"><span class="comment">// 255 string</span></span><br></pre></td></tr></table></figure>

<ul>
<li>十六进制转化成十进制</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">parseInt</span>(<span class="string">'0xff'</span>,<span class="number">16</span>), <span class="keyword">typeof</span> <span class="built_in">parseInt</span>(<span class="string">'0xff'</span>,<span class="number">16</span>));</span><br><span class="line"><span class="comment">// 255 'number'</span></span><br></pre></td></tr></table></figure>

<ul>
<li>base64</li>
</ul>
<p>二进制的值不能超过64  （核心就是进制的转化）</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在浏览器header中，任意的url中都可以采用base64，前端实现文件预览 （fileReadReader 读出来也是base64）</span></span><br><span class="line"><span class="comment">// 特点：转码后的结果 比原来的内容 大</span></span><br><span class="line"><span class="comment">// 分析：</span></span><br><span class="line"><span class="comment">// 如果一个汉字</span></span><br><span class="line"><span class="built_in">console</span>.log(Buffer.from(<span class="string">'珠'</span>)); <span class="comment">// e7 8f a0   &lt;Buffer e7 8f a0&gt;</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">0xe7</span>.toString(<span class="number">2</span>));</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">0x8f</span>.toString(<span class="number">2</span>));</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">0xa0</span>.toString(<span class="number">2</span>));</span><br><span class="line"><span class="comment">// 11100111  10001111  10100000 左侧是二进制的格式，现在要把 3*8的格式转成 6*4如下：</span></span><br><span class="line"><span class="comment">// 111001  111000  111110  100000</span></span><br></pre></td></tr></table></figure>

<p>base64 转化后取特定的字符串取值</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">'ABCDEFGHIJKLMNOPQRSTUVWXYZ'</span>;</span><br><span class="line">str+= <span class="string">'ABCDEFGHIJKLMNOPQRSTUVWXYZ'</span>.toLowerCase();</span><br><span class="line">str+= <span class="string">'0123456789+/'</span></span><br><span class="line"><span class="keyword">let</span> result = str[<span class="number">0b111001</span>] + str[<span class="number">0b111000</span>] + str[<span class="number">0b111110</span>] + str[<span class="number">0b100000</span>];</span><br><span class="line"><span class="built_in">console</span>.log(result); <span class="comment">// 54+g  可以在线转化 就是珠</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// base64就是编码转化 不需要发送http请求。大小会比以前大 </span></span><br><span class="line"><span class="built_in">console</span>.log(Buffer.from(<span class="string">'珠'</span>).toString(<span class="string">'base64'</span>)); <span class="comment">// 54+g</span></span><br></pre></td></tr></table></figure>

<h3 id="编码问题"><a href="#编码问题" class="headerlink" title="编码问题"></a>编码问题</h3><blockquote>
<p>iconv-lite</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 现在新建一个test.md gbk格式的文件</span></span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"><span class="keyword">let</span> r = fs.readFileSync(path.resolve(__dirname, <span class="string">'test.md'</span>), <span class="string">'utf-8'</span>); <span class="comment">// 读取文件只能设置utf8或者不设置默认输出的是buffer</span></span><br><span class="line"><span class="built_in">console</span>.log(r); <span class="comment">// 可以看到都是乱码</span></span><br><span class="line"><span class="comment">// 这里可以引入第三方的包 iconv-lite   gbk 转成 utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> iconv = <span class="built_in">require</span>(<span class="string">'iconv-lite'</span>);</span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"><span class="keyword">let</span> r = fs.readFileSync(path.resolve(__dirname, <span class="string">'test.md'</span>)); </span><br><span class="line"><span class="built_in">console</span>.log(iconv.decode(r, <span class="string">'gbk'</span>));  <span class="comment">// 你好</span></span><br></pre></td></tr></table></figure>

<h3 id="Buffer"><a href="#Buffer" class="headerlink" title="Buffer"></a>Buffer</h3><blockquote>
<p>把二进制表现成了10进制 可以和字符串进行转化</p>
</blockquote>
<h4 id="1）-Buffer的声明方式"><a href="#1）-Buffer的声明方式" class="headerlink" title="1） Buffer的声明方式"></a>1） Buffer的声明方式</h4><blockquote>
<p>Buffer代表的是内存 一旦声明就不能扩展  数组的话可以扩展</p>
</blockquote>
<ul>
<li>固定大小</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> buf = Buffer.alloc(<span class="number">5</span>);<span class="comment">// 分配5个  出来的结果很像数组</span></span><br><span class="line"><span class="built_in">console</span>.log(buf); </span><br><span class="line"><span class="comment">//  &lt;Buffer 00 00 00 00 00&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> buf = Buffer.allocUnsafe(<span class="number">5</span>); <span class="comment">// 随机抓取5个内存</span></span><br><span class="line"><span class="built_in">console</span>.log(buf); </span><br><span class="line"><span class="comment">// &lt;Buffer 06 00 00 00 14&gt;  可能包含之前的信息，优点是速度快</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> buf = Buffer.allocUnsafe(<span class="number">5</span>);</span><br><span class="line">buf.fill(<span class="number">0</span>); <span class="comment">// 手动填充</span></span><br><span class="line"><span class="built_in">console</span>.log(buf); </span><br><span class="line"><span class="comment">// &lt;Buffer 00 00 00 00 00&gt;</span></span><br><span class="line"><span class="comment">// allocUnsafe + fill  =&gt; alloc</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> buf = Buffer.from([<span class="number">100</span>, <span class="number">200</span>, <span class="number">300</span>]);  <span class="comment">// 数组 少用 手动写</span></span><br><span class="line"><span class="built_in">console</span>.log(buf); </span><br><span class="line"><span class="comment">// &lt;Buffer 64 c8 2c&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> buf = Buffer.from(<span class="string">'加菲'</span>);  <span class="comment">// 字符串</span></span><br><span class="line"><span class="built_in">console</span>.log(buf); </span><br><span class="line"><span class="comment">// &lt;Buffer e5 8a a0 e8 8f b2&gt;  这个同样也不能扩容，因为字符串长度是固定的</span></span><br></pre></td></tr></table></figure>

<p>常用的赋值方式是第一种和最后一种</p>
<h4 id="2-Buffer的常见方法"><a href="#2-Buffer的常见方法" class="headerlink" title="2) Buffer的常见方法"></a>2) Buffer的常见方法</h4><blockquote>
<p>和数组类似</p>
</blockquote>
<h5 id="2-1）-slice"><a href="#2-1）-slice" class="headerlink" title="2.1） slice"></a>2.1） slice</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],<span class="number">4</span>,<span class="number">5</span>];</span><br><span class="line"><span class="keyword">let</span> newArr = arr.slice(<span class="number">0</span>); <span class="comment">// 浅拷贝 </span></span><br><span class="line">newArr[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">100</span>;</span><br><span class="line"><span class="built_in">console</span>.log(arr, newArr);</span><br><span class="line"><span class="comment">// [ [ 1, 100, 3 ], 4, 5 ] [ [ 1, 100, 3 ], 4, 5 ]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> buffer = Buffer.from(<span class="string">'加菲'</span>); <span class="comment">// &lt;Buffer 64 8a a0 e8 8f b2&gt;</span></span><br><span class="line"><span class="keyword">let</span> newBuffer = buffer.slice(<span class="number">0</span>);</span><br><span class="line">newBuffer[<span class="number">0</span>] = <span class="number">100</span>;</span><br><span class="line"><span class="built_in">console</span>.log(buffer); </span><br><span class="line"><span class="comment">//&lt;Buffer e5 8a a0 e8 8f b2&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>Buffer存放的都是内存地址，如果截取了某一段，改变的时候也是更改了这个内存地址</p>
</blockquote>
<h5 id="2-2）判断Buffer类型"><a href="#2-2）判断Buffer类型" class="headerlink" title="2.2）判断Buffer类型"></a>2.2）判断Buffer类型</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(Buffer.isBuffer(buffer)); <span class="comment">//true 是不是Buffer</span></span><br></pre></td></tr></table></figure>

<h5 id="2-3-Buffer不能扩展大小"><a href="#2-3-Buffer不能扩展大小" class="headerlink" title="2.3) Buffer不能扩展大小"></a>2.3) Buffer不能扩展大小</h5><blockquote>
<p>copy</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> buffer1 = Buffer.from(<span class="string">"珠"</span>);</span><br><span class="line"><span class="keyword">let</span> buffer2 = Buffer.from(<span class="string">"珠"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 现在想要把这2块内存放到一起</span></span><br><span class="line"><span class="comment">// 可以声明一个大Buffer 将2个放在一起</span></span><br><span class="line"><span class="keyword">let</span> buff = Buffer.alloc(<span class="number">6</span>);</span><br><span class="line"><span class="keyword">let</span> buffer1 = Buffer.from(<span class="string">"珠"</span>);</span><br><span class="line"><span class="keyword">let</span> buffer2 = Buffer.from(<span class="string">"珠"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当前buffer.copy(目标buffer,目标的开始位置,源的开始，源的结束)</span></span><br><span class="line">buffer1.copy(buff,<span class="number">0</span>,<span class="number">0</span>,<span class="number">3</span>);</span><br><span class="line">buffer2.copy(buff,<span class="number">3</span>,<span class="number">0</span>,<span class="number">3</span>);</span><br><span class="line"><span class="built_in">console</span>.log(buff, buff.toString())</span><br><span class="line"><span class="comment">// &lt;Buffer e7 8f a0 e7 8f a0&gt; '珠珠'</span></span><br></pre></td></tr></table></figure>

<ul>
<li>写一下这个copy 的原理</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Buffer.prototype.copy = <span class="function"><span class="keyword">function</span>(<span class="params">targetBuffer, targetStart, sourceStart = <span class="number">0</span>, sourceEnd = this.length</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; sourceEnd - sourceStart; i++)&#123; <span class="comment">// 确定循环次数</span></span><br><span class="line">        targetBuffer[targetStart + i] = <span class="keyword">this</span>[ sourceStart + i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="2-4-concat拼接"><a href="#2-4-concat拼接" class="headerlink" title="2.4) concat拼接"></a>2.4) concat拼接</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> buffer1 = Buffer.from(<span class="string">"珠"</span>);</span><br><span class="line"><span class="keyword">let</span> buffer2 = Buffer.from(<span class="string">"珠"</span>);</span><br><span class="line"><span class="keyword">let</span> newBuffer = Buffer.concat([buffer1, buffer2], <span class="number">10</span>); <span class="comment">//可以提供大小 也可以不写</span></span><br><span class="line"><span class="built_in">console</span>.log(newBuffer, newBuffer.toString());</span><br><span class="line"><span class="comment">// &lt;Buffer e7 8f a0 e7 8f a0 00 00 00 00&gt; '珠珠\u0000\u0000\u0000\u0000'</span></span><br></pre></td></tr></table></figure>

<ul>
<li>写下concat的原理</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Buffer.concat = <span class="function"><span class="keyword">function</span> (<span class="params">list, length = list.reduce( (a,b</span>)=&gt;<span class="title">a</span>+<span class="title">b</span>.<span class="title">length</span>,0))</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> buffer = Buffer.alloc(length);</span><br><span class="line">    <span class="keyword">let</span> offset = <span class="number">0</span>;</span><br><span class="line">    list.forEach( <span class="function"><span class="params">b</span>=&gt;</span>&#123;</span><br><span class="line">        b.copy(buffer, offset);</span><br><span class="line">        offset+= b.length;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> buffer;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> buffer1 = Buffer.from(<span class="string">"珠"</span>);</span><br><span class="line"><span class="keyword">let</span> buffer2 = Buffer.from(<span class="string">"珠"</span>);</span><br><span class="line"><span class="keyword">let</span> newBuffer = Buffer.concat([buffer1, buffer2]); <span class="comment">//可以提供大小 也可以不写</span></span><br><span class="line"><span class="built_in">console</span>.log(newBuffer, newBuffer.toString());</span><br><span class="line"><span class="comment">// &lt;Buffer e7 8f a0 e7 8f a0&gt; '珠珠'</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>isBuffer 、length字节数 、concat  、toString()|toString(‘base64’) 、slice 、fill<br>  Buffer场景：文件读写 、数据读写</p>
</blockquote>
<h4 id="3-扩展Buffer的方法"><a href="#3-扩展Buffer的方法" class="headerlink" title="3) 扩展Buffer的方法"></a>3) 扩展Buffer的方法</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> buffer = Buffer.from(<span class="string">'加菲加菲加菲'</span>); </span><br><span class="line"><span class="built_in">console</span>.log(buffer.indexOf(<span class="string">'加'</span>,<span class="number">2</span>)); </span><br><span class="line"><span class="comment">// 一个中文字占3个字节，2代表从第二个字节开始    6</span></span><br></pre></td></tr></table></figure>

<ul>
<li>行读取器 </li>
</ul>
<p>文本 希望每拿到一行就打印</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> buffer = Buffer.from(<span class="string">`加菲加菲加菲加菲</span></span><br><span class="line"><span class="string">加菲加菲加菲加菲加菲</span></span><br><span class="line"><span class="string">加菲加菲加菲加菲`</span>);</span><br><span class="line"><span class="built_in">console</span>.log(buffer);</span><br><span class="line"><span class="comment">// &lt;Buffer e5 8a a0 e8 8f b2 e5 8a a0 e8 8f b2 e5 8a a0 e8 8f b2 e5 8a a0 e8 8f b2 0a e5 8a a0 e8 8f b2 e5 8a a0 e8 8f b2 e5 8a a0 e8 8f b2 e5 8a a0 e8 8f b2 e5 ... &gt;</span></span><br><span class="line"><span class="built_in">console</span>.log(Buffer.from(<span class="string">'\n'</span>)); <span class="comment">// 0a</span></span><br><span class="line"><span class="comment">//console.log(Buffer.from('\r\n')); // 0d 0a window的话是\r\n</span></span><br></pre></td></tr></table></figure>

<p>现在希望能够通过 buffer.split(‘\n’) 就能把上面的数据分成三段取出</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> buffer = Buffer.from(<span class="string">`加菲加菲加菲加菲</span></span><br><span class="line"><span class="string">加菲加菲加菲加菲加菲</span></span><br><span class="line"><span class="string">加菲加菲加菲加菲`</span>);</span><br><span class="line">Buffer.prototype.split = <span class="function"><span class="keyword">function</span>(<span class="params">sep</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 因为如果这里sep传进来的是中文字，直接取长度是1，但其实Buffer的长度是3</span></span><br><span class="line">    <span class="keyword">let</span> len = Buffer.from(sep).length; <span class="comment">// 取sep的Buffer的长度， 这是分隔符的长度</span></span><br><span class="line">    <span class="keyword">let</span> offset = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> result = [];</span><br><span class="line">    <span class="keyword">let</span> current = <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">// 把找到的位置赋给current</span></span><br><span class="line">    <span class="keyword">while</span> ( (current = <span class="keyword">this</span>.indexOf(sep, offset)) !== <span class="number">-1</span>) &#123;</span><br><span class="line">        result.push(<span class="keyword">this</span>.slice(offset, current));</span><br><span class="line">        offset = current + len; <span class="comment">// 增加查找偏移量</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如line3没有分隔符了要把最后的取上</span></span><br><span class="line">    result.push(<span class="keyword">this</span>.slice(offset));</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(buffer.split(<span class="string">'\n'</span>));</span><br><span class="line"><span class="comment">// 执行结果：</span></span><br><span class="line">[ <span class="xml"><span class="tag">&lt;<span class="name">Buffer</span> <span class="attr">e5</span> <span class="attr">8a</span> <span class="attr">a0</span> <span class="attr">e8</span> <span class="attr">8f</span> <span class="attr">b2</span> <span class="attr">e5</span> <span class="attr">8a</span> <span class="attr">a0</span> <span class="attr">e8</span> <span class="attr">8f</span> <span class="attr">b2</span> <span class="attr">e5</span> <span class="attr">8a</span> <span class="attr">a0</span> <span class="attr">e8</span> <span class="attr">8f</span> <span class="attr">b2</span> <span class="attr">e5</span> <span class="attr">8a</span> <span class="attr">a0</span> <span class="attr">e8</span> <span class="attr">8f</span> <span class="attr">b2</span>&gt;</span>,</span></span><br><span class="line">  &lt;Buffer e5 8a a0 e8 8f b2 e5 8a a0 e8 8f b2 e5 8a a0 e8 8f b2 e5 8a a0 e8 8f b2 e5 8a a0 e8 8f b2&gt;,</span><br><span class="line">  &lt;Buffer e5 8a a0 e8 8f b2 e5 8a a0 e8 8f b2 e5 8a a0 e8 8f b2 e5 8a a0 e8 8f b2&gt; ]</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Nodejs</category>
      </categories>
  </entry>
  <entry>
    <title>前端面试题集锦</title>
    <url>/2019/09/24/Interview-question/</url>
    <content><![CDATA[<h2 id="ES6"><a href="#ES6" class="headerlink" title="ES6"></a>ES6</h2><h3 id="1"><a href="#1" class="headerlink" title="1)"></a>1)</h3><p><a href="https://buluo.qq.com/p/detail.html?bid=314687&amp;pid=3951568-1489992778&amp;from=share_qq" target="_blank" rel="noopener">https://buluo.qq.com/p/detail.html?bid=314687&amp;pid=3951568-1489992778&amp;from=share_qq</a></p>
<ul>
<li>async await</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> sleep = <span class="function">(<span class="params">timer</span>) =&gt;</span> <span class="keyword">new</span> <span class="built_in">Promise</span>( <span class="function">(<span class="params">resolve</span>)=&gt;</span>&#123;</span><br><span class="line">    setTimeout( resolve, timer * <span class="number">1000</span>)</span><br><span class="line">&#125;);</span><br><span class="line">(<span class="keyword">async</span> ()=&gt;&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)&#123;</span><br><span class="line">        <span class="keyword">await</span> sleep(<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">console</span>.log(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">await</span> sleep(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(i);</span><br><span class="line">&#125;)()</span><br><span class="line"><span class="comment">// 输出结果： -&gt;0-&gt;1-&gt;2-&gt;3-&gt;4-&gt;5</span></span><br></pre></td></tr></table></figure>

<a id="more"></a>

<ul>
<li>Promise.all</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> tasks = []; <span class="comment">// 这里存放异步操作的 Promise</span></span><br><span class="line"><span class="keyword">const</span> output = <span class="function">(<span class="params">i</span>) =&gt;</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">new</span> <span class="built_in">Date</span>, i);</span><br><span class="line">        resolve();</span><br><span class="line">    &#125;, <span class="number">1000</span> * i);</span><br><span class="line">&#125;);<span class="comment">// 生成全部的异步操作</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">    tasks.push(output(i));</span><br><span class="line">&#125;<span class="comment">// 异步操作完成之后，输出最后的 i</span></span><br><span class="line"><span class="built_in">Promise</span>.all(tasks).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">new</span> <span class="built_in">Date</span>, i);</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 输出结果： ,0-&gt;1-&gt;2-&gt;3-&gt;4-&gt;5</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>, 表示立即输出 &nbsp;&nbsp;&nbsp;&nbsp; -&gt;表示过一段时间再输出</p>
</blockquote>
<h2 id="js基础"><a href="#js基础" class="headerlink" title="js基础"></a>js基础</h2><h3 id="1-1"><a href="#1-1" class="headerlink" title="1)"></a>1)</h3><blockquote>
<p>以let/const声明的变量或常量，必需是经过对声明的赋值语句的求值后，才算初始化完成，创建时并不算初始化。如果以let声明的变量没有赋给初始值，那么就赋值给它undefined值。也就是经过初始化的完成，才代表着TDZ期间的真正结束，这些在作用域中的被声明的变量才能够正常地被访问。</p>
</blockquote>
<p>对于TDZ的解释：<a href="https://segmentfault.com/a/1190000008213835" target="_blank" rel="noopener">https://segmentfault.com/a/1190000008213835</a></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">x, y = function(</span>)</span>&#123;x = <span class="number">2</span>&#125;)&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"第一次"</span>, x); </span><br><span class="line">    y();</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"第二次"</span>, x);</span><br><span class="line">    <span class="keyword">var</span> x = <span class="number">3</span>;</span><br><span class="line">    y();</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"第三次"</span>, x);</span><br><span class="line">&#125;</span><br><span class="line">foo(x);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"第四次"</span>, x);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行结果 1131</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> x = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">x, y = function(</span>)</span>&#123;x = <span class="number">2</span>&#125;)&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"第一次"</span>, x); </span><br><span class="line">    y();</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"第二次"</span>, x);</span><br><span class="line">    <span class="comment">//var x = 3;</span></span><br><span class="line">    y();</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"第三次"</span>, x);</span><br><span class="line">&#125;</span><br><span class="line">foo(x);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"第四次"</span>, x);</span><br><span class="line"><span class="comment">// 执行结果 1221</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 分析：根据ES标准中的定义，如果参数存在默认值，则有三个环境 environment( environment in ES6 = scope in ES5). Outer environment / parameters environment / function body environment. parameters environment 可以访问自己和外层，不能访问函数体内的变量。函数体内可以修改 parameters env 里定义的 formal parameters 的值，不能重新定义（除非用var……）。</span></span><br><span class="line"><span class="comment">// 分析： 主要来说就是如果在foo函数体内用var声明了变量x的话，y里面的x和foo函数里的x就不是一个变量了。这个y函数会形成一个中间作用域</span></span><br></pre></td></tr></table></figure>

<p><a href="https://code.wileam.com/default-value-n-params-env/" target="_blank" rel="noopener">https://code.wileam.com/default-value-n-params-env/</a></p>
<h2 id="Webpack"><a href="#Webpack" class="headerlink" title="Webpack"></a>Webpack</h2><h3 id="1-tree-shaking-原理"><a href="#1-tree-shaking-原理" class="headerlink" title="1) tree shaking 原理"></a>1) tree shaking 原理</h3><blockquote>
<p>例如， 在 webpack 项目中，有一个入口文件，入口文件有很多依赖的模块，实际情况中，虽然依赖了某个模块，但其实只使用其中的某些功能。通过 tree-shaking，将没有使用的模块摇掉，这样来达到删除无用代码的目的。</p>
</blockquote>
<ul>
<li>Tree-shaking的本质是消除无用的js代码。</li>
<li>ES6模块依赖关系是确定的，和运行时的状态无关，可以进行可靠的静态分析，这就是tree-shaking的基础。<blockquote>
<p>所谓静态分析就是不执行代码，从字面量上对代码进行分析，ES6之前的模块化，比如我们可以动态require一个模块，只有执行后才知道引用的什么模块，这个就不能通过静态分析去做优化。<br>这是 ES6 modules 在设计时的一个重要考量，也是为什么没有直接采用 CommonJS，正是基于这个基础上，才使得 tree-shaking 成为可能，这也是为什么 rollup 和 webpack 2 都要用 ES6 module syntax 才能 tree-shaking。</p>
</blockquote>
</li>
</ul>
<p>文章：<a href="https://juejin.im/post/5a4dc842518825698e7279a9" target="_blank" rel="noopener">https://juejin.im/post/5a4dc842518825698e7279a9</a></p>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="1-如何在不增加中间变量的情况下，交换2个变量的值"><a href="#1-如何在不增加中间变量的情况下，交换2个变量的值" class="headerlink" title="1) 如何在不增加中间变量的情况下，交换2个变量的值"></a>1) 如何在不增加中间变量的情况下，交换2个变量的值</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// .ts</span></span><br><span class="line">namespace b&#123;</span><br><span class="line">    function swap&lt;A,B&gt;(tuple:[A,B]):[B,A]&#123;</span><br><span class="line">        <span class="keyword">return</span> [tuple[<span class="number">1</span>],tuple[<span class="number">0</span>]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> result = swap&lt;string,number&gt;([<span class="string">'jf'</span>,<span class="number">18</span>]);</span><br><span class="line">    <span class="built_in">console</span>.log(result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译后</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// .js</span></span><br><span class="line"><span class="keyword">var</span> b;</span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params">b</span>) </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">swap</span>(<span class="params">tuple</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> [tuple[<span class="number">1</span>], tuple[<span class="number">0</span>]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> result = swap([<span class="string">'jf'</span>, <span class="number">18</span>]);</span><br><span class="line">    <span class="built_in">console</span>.log(result);</span><br><span class="line">&#125;)(b || (b = &#123;&#125;));</span><br></pre></td></tr></table></figure>

<p>或者</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">1</span>, b = <span class="number">2</span>;</span><br><span class="line">[b, a] = [a, b];</span><br><span class="line"><span class="built_in">console</span>.log(b,a);<span class="comment">// 1  2</span></span><br></pre></td></tr></table></figure>

<p>React的setState是同步还是异步<br>immutable.js和pureComponent有什么关系<br>vue响应式的原理<br>webpack现在有100个入口，编了5分钟怎么办<br>101状态码是什么意思<br>302和304分别表示什么<br>async/defer的区别<br>css三角形怎么画<br>输入url到渲染都发生什么<br>最近的新技术都了解哪些</p>
]]></content>
      <categories>
        <category>面试题</category>
      </categories>
      <tags>
        <tag>面试题</tag>
      </tags>
  </entry>
  <entry>
    <title>React中遇到的问题</title>
    <url>/2019/09/24/React-Question/</url>
    <content><![CDATA[<h3 id="父-gt-子组件通讯"><a href="#父-gt-子组件通讯" class="headerlink" title="父=&gt;子组件通讯"></a>父=&gt;子组件通讯</h3><p>父组件：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//元素：</span></span><br><span class="line">&lt;child onRef=&#123;<span class="keyword">this</span>.onRef&#125; /&gt;</span><br><span class="line">&lt;p onClick=&#123;<span class="keyword">this</span>.click.bind(<span class="keyword">this</span>)&#125;&gt;父组件的点击事件&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/方法：</span></span><br><span class="line"><span class="regexp">click = （） =&gt;&#123;</span></span><br><span class="line"><span class="regexp">    this.child.childFunction()</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp">onRef = (ref) =&gt;&#123;</span></span><br><span class="line"><span class="regexp">     this.child=ref</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>

<a id="more"></a>

<p>子组件：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//方法：</span></span><br><span class="line">componentDidMount()&#123;</span><br><span class="line">    <span class="keyword">this</span>.props.onRef(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line">childFunction()&#123; &#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>工作中的BUG</tag>
      </tags>
  </entry>
  <entry>
    <title>Nodejs 模块 （三）</title>
    <url>/2019/09/24/Node-util-events/</url>
    <content><![CDATA[<h2 id="核心模块"><a href="#核心模块" class="headerlink" title="核心模块"></a>核心模块</h2><ul>
<li>node自带的模块</li>
</ul>
<h3 id="util"><a href="#util" class="headerlink" title="util"></a>util</h3><ul>
<li>util util.inherits</li>
<li>util.promisify</li>
</ul>
<h4 id="1）promisify"><a href="#1）promisify" class="headerlink" title="1）promisify"></a>1）promisify</h4><ul>
<li>ncp  拷贝的一个模块</li>
<li>先初始化环境   npm init</li>
<li>安装ncp yarn add ncp</li>
</ul>
<a id="more"></a>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> ncp = <span class="built_in">require</span>(<span class="string">'ncp'</span>); <span class="comment">// 第三方库</span></span><br><span class="line"><span class="keyword">let</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"><span class="comment">// 拷贝文件</span></span><br><span class="line">ncp(path.resolve(__dirname,<span class="string">"note.md"</span>), path.resolve(__dirname,<span class="string">"note1.md"</span>), err=&gt;&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>现在希望能转化成下面这种形式</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">(<span class="keyword">async</span>()=&gt;&#123;</span><br><span class="line">    <span class="keyword">await</span> ncp(path.resolve(__dirname,<span class="string">"note.md"</span>), path.resolve(__dirname,<span class="string">"note1.md"</span>))</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'拷贝成功'</span>);</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 引入util模块</span></span><br><span class="line"><span class="keyword">let</span> ncp = <span class="built_in">require</span>(<span class="string">'ncp'</span>); <span class="comment">// 第三方库</span></span><br><span class="line"><span class="keyword">let</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"><span class="keyword">let</span> util = <span class="built_in">require</span>(<span class="string">'util'</span>);</span><br><span class="line">ncp = util.promisify(ncp);</span><br><span class="line">(<span class="keyword">async</span>()=&gt;&#123;</span><br><span class="line">    <span class="keyword">await</span> ncp(path.resolve(__dirname,<span class="string">"note.md"</span>), path.resolve(__dirname,<span class="string">"note2.md"</span>))</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'拷贝成功'</span>);</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>

<p>手写原理</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> ncp = <span class="built_in">require</span>(<span class="string">'ncp'</span>); <span class="comment">// 第三方库</span></span><br><span class="line"><span class="keyword">let</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"><span class="keyword">let</span> util = <span class="built_in">require</span>(<span class="string">'util'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> promisify = <span class="function">(<span class="params">fn</span>) =&gt;</span> <span class="function">(<span class="params">...args</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>( <span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        fn(...args, err=&gt;&#123; <span class="comment">// 只针对node，因为只有node才是这种error-first的形式</span></span><br><span class="line">            <span class="keyword">if</span>(err) reject(err);</span><br><span class="line">            resolve();</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ncp = promisify(ncp);</span><br><span class="line">(<span class="keyword">async</span>()=&gt;&#123;</span><br><span class="line">    <span class="keyword">await</span> ncp(path.resolve(__dirname,<span class="string">"note.md"</span>), path.resolve(__dirname,<span class="string">"note3.md"</span>))</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'拷贝成功'</span>);</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>

<h4 id="2-inherits"><a href="#2-inherits" class="headerlink" title="2) inherits"></a>2) inherits</h4><p>node内部不是用es6写的 好多方法都是用es5来写的，  实现类的继承</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>  <span class="title">Parent</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 只继承公共方法</span></span><br><span class="line">Child.prototype.__proro__ = Parent.prototype;</span><br><span class="line"><span class="built_in">Reflect</span>.setPrototypeOf(Child.prototype, Parent.prototype);</span><br><span class="line">Child.prototype = <span class="built_in">Object</span>.create(Parent.prototype);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> &#123;inherits&#125; = <span class="built_in">require</span>(<span class="string">'util'</span>);</span><br><span class="line">inherits(Child, Parent); <span class="comment">// 这行和line10、11是等价的  继承公共属性</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以显示隐藏属性</span></span><br><span class="line"><span class="built_in">console</span>.log(util.inspect(<span class="built_in">Array</span>.prototype,&#123;<span class="attr">showHidden</span>:<span class="literal">true</span>&#125;));</span><br><span class="line"><span class="built_in">console</span>.log(util.isPrimitive);</span><br></pre></td></tr></table></figure>

<h3 id="events"><a href="#events" class="headerlink" title="events"></a>events</h3><ul>
<li>事件触发器</li>
</ul>
<h5 id="发布订阅模块"><a href="#发布订阅模块" class="headerlink" title="发布订阅模块"></a>发布订阅模块</h5><h5 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> EventEmitter = <span class="built_in">require</span>(<span class="string">'events'</span>);</span><br><span class="line"><span class="comment">// on emit</span></span><br><span class="line"><span class="keyword">let</span> e = <span class="keyword">new</span> EventEmitter();</span><br><span class="line"><span class="keyword">let</span> listener1 = <span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'哭'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> listener2 = <span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'逛街'</span>);</span><br><span class="line">&#125;</span><br><span class="line">e.on(<span class="string">"女生失恋"</span>, listener1);</span><br><span class="line">e.on(<span class="string">"女生失恋"</span>, listener2);</span><br><span class="line"><span class="comment">// 发布</span></span><br><span class="line">e.emit(<span class="string">"女生失恋"</span>);</span><br><span class="line"><span class="comment">// 哭   逛街</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1.events.js</span></span><br><span class="line"><span class="keyword">let</span> EventEmitter = <span class="built_in">require</span>(<span class="string">'events'</span>);</span><br><span class="line"><span class="keyword">let</span> util = <span class="built_in">require</span>(<span class="string">'util'</span>)</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Girl</span>(<span class="params"></span>)</span>&#123; <span class="comment">// 自己写个类</span></span><br><span class="line">&#125;</span><br><span class="line">util.inherits(Girl,EventEmitter);</span><br><span class="line"><span class="keyword">let</span> girl = <span class="keyword">new</span> Girl();</span><br><span class="line"><span class="comment">// on emit</span></span><br><span class="line"><span class="keyword">let</span> listener1 = <span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'哭'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> listener2 = <span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'逛街'</span>);</span><br><span class="line">&#125;</span><br><span class="line">girl.on(<span class="string">"女生失恋"</span>, listener1);</span><br><span class="line">girl.on(<span class="string">"女生失恋"</span>, listener2);</span><br><span class="line"><span class="comment">// 发布</span></span><br><span class="line">girl.emit(<span class="string">"女生失恋"</span>);</span><br><span class="line"><span class="comment">//哭   逛街</span></span><br></pre></td></tr></table></figure>

<h5 id="手写events模块"><a href="#手写events模块" class="headerlink" title="手写events模块"></a>手写events模块</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// events.js</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">EventEmitter</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>._events = <span class="built_in">Object</span>.create(<span class="literal">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// &#123;'name': [listener, listener]&#125;</span></span><br><span class="line">EventEmitter.prototype.on = <span class="function"><span class="keyword">function</span> (<span class="params">eventName, callback</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 不管任何人调动了on方法 都可以增加_events</span></span><br><span class="line">    <span class="keyword">if</span>( !<span class="keyword">this</span>._events) <span class="keyword">this</span>._events = <span class="built_in">Object</span>.create(<span class="literal">null</span>);</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span>._events[eventName])&#123;</span><br><span class="line">        <span class="keyword">this</span>._events[eventName].push(callback);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">this</span>._events[eventName] = [callback];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">EventEmitter.prototype.emit = <span class="function"><span class="keyword">function</span>(<span class="params">eventName, ...args</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span>._events[eventName])&#123;</span><br><span class="line">        <span class="keyword">this</span>._events[eventName].forEach(<span class="function"><span class="params">fn</span> =&gt;</span> &#123;</span><br><span class="line">            fn(...args);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">module</span>.exports = EventEmitter;</span><br><span class="line"><span class="comment">// 上面1.events.js中引入的是 require('./events');</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>Tips</p>
</blockquote>
<ul>
<li>Object.create(null);  &nbsp;&nbsp;这样创建的对象是没有属性的 可以直接在浏览器打印</li>
<li>{} 这样创建的对象有一堆属性</li>
</ul>
<h5 id="newListener"><a href="#newListener" class="headerlink" title="newListener"></a>newListener</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//let EventEmitter = require('./events');</span></span><br><span class="line"><span class="keyword">let</span> EventEmitter = <span class="built_in">require</span>(<span class="string">'events'</span>);</span><br><span class="line"><span class="keyword">let</span> util = <span class="built_in">require</span>(<span class="string">'util'</span>)</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Girl</span>(<span class="params"></span>)</span>&#123; <span class="comment">// 自己写个类</span></span><br><span class="line">&#125;</span><br><span class="line">util.inherits(Girl,EventEmitter);</span><br><span class="line"><span class="keyword">let</span> girl = <span class="keyword">new</span> Girl();</span><br><span class="line"></span><br><span class="line">girl.on(<span class="string">'newListener'</span>, (type)=&gt;&#123; <span class="comment">// 这个可以监听到用户做了哪些监听</span></span><br><span class="line">    <span class="built_in">console</span>.log(type);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> listener1 = <span class="function">(<span class="params">w</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'哭'</span>, w);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> listener2 = <span class="function">(<span class="params">w</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'逛街'</span>, w);</span><br><span class="line">&#125;</span><br><span class="line">girl.on(<span class="string">"女生失恋"</span>, listener1);</span><br><span class="line">girl.on(<span class="string">"女生失恋"</span>, listener2);</span><br><span class="line"><span class="comment">// 发布</span></span><br><span class="line">girl.emit(<span class="string">"女生失恋"</span>, <span class="string">'我'</span>);</span><br><span class="line"><span class="comment">/**打印结果</span></span><br><span class="line"><span class="comment">女生失恋</span></span><br><span class="line"><span class="comment">女生失恋</span></span><br><span class="line"><span class="comment">哭 我</span></span><br><span class="line"><span class="comment">逛街 我</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<h5 id="比如说现在想要监听失恋这个事件"><a href="#比如说现在想要监听失恋这个事件" class="headerlink" title="比如说现在想要监听失恋这个事件"></a>比如说现在想要监听失恋这个事件</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> EventEmitter = <span class="built_in">require</span>(<span class="string">'events'</span>);</span><br><span class="line"><span class="keyword">let</span> util = <span class="built_in">require</span>(<span class="string">'util'</span>)</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Girl</span>(<span class="params"></span>)</span>&#123; </span><br><span class="line">&#125;</span><br><span class="line">util.inherits(Girl,EventEmitter);</span><br><span class="line"><span class="keyword">let</span> girl = <span class="keyword">new</span> Girl();</span><br><span class="line"></span><br><span class="line">girl.on(<span class="string">'newListener'</span>, (type)=&gt;&#123; <span class="comment">// 这个可以监听到用户做了哪些监听</span></span><br><span class="line">    <span class="keyword">if</span>(type === <span class="string">'失恋'</span>)&#123;</span><br><span class="line">        girl.emit(type);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">girl.on(<span class="string">'失恋'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'监听到了 执行'</span>);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 这里没有监听到 因为先走的line8-12,line13-15还没有放到数组里， 执行顺序的问题</span></span><br></pre></td></tr></table></figure>

<h5 id="解决办法如下-nextTick"><a href="#解决办法如下-nextTick" class="headerlink" title="解决办法如下 nextTick"></a>解决办法如下 nextTick</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> EventEmitter = <span class="built_in">require</span>(<span class="string">'events'</span>);</span><br><span class="line"><span class="keyword">let</span> util = <span class="built_in">require</span>(<span class="string">'util'</span>)</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Girl</span>(<span class="params"></span>)</span>&#123; </span><br><span class="line">&#125;</span><br><span class="line">util.inherits(Girl,EventEmitter);</span><br><span class="line"><span class="keyword">let</span> girl = <span class="keyword">new</span> Girl();</span><br><span class="line"></span><br><span class="line">girl.on(<span class="string">'newListener'</span>, (type)=&gt;&#123;</span><br><span class="line">    <span class="keyword">if</span>(type === <span class="string">'失恋'</span>)&#123;</span><br><span class="line">        process.nextTick(<span class="function"><span class="params">()</span>=&gt;</span>&#123; <span class="comment">// 这里会等到同步代码 line15-17执行完之后再执行</span></span><br><span class="line">            girl.emit(type);</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">girl.on(<span class="string">'失恋'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'监听到了 执行'</span>);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 监听到了 执行</span></span><br></pre></td></tr></table></figure>

<h5 id="如果绑定2个失恋事件"><a href="#如果绑定2个失恋事件" class="headerlink" title="如果绑定2个失恋事件"></a>如果绑定2个失恋事件</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> EventEmitter = <span class="built_in">require</span>(<span class="string">'events'</span>);</span><br><span class="line"><span class="keyword">let</span> util = <span class="built_in">require</span>(<span class="string">'util'</span>)</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Girl</span>(<span class="params"></span>)</span>&#123; <span class="comment">// 自己写个类</span></span><br><span class="line">&#125;</span><br><span class="line">util.inherits(Girl,EventEmitter);</span><br><span class="line"><span class="keyword">let</span> girl = <span class="keyword">new</span> Girl();</span><br><span class="line"></span><br><span class="line">girl.on(<span class="string">'newListener'</span>, (type)=&gt;&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"1~"</span>);</span><br><span class="line">    <span class="keyword">if</span>(type === <span class="string">'失恋'</span>)&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"2~"</span>);</span><br><span class="line">        process.nextTick(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">"3~"</span>);</span><br><span class="line">            girl.emit(type);</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">girl.on(<span class="string">'失恋'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'监听到了 执行'</span>);</span><br><span class="line">&#125;)</span><br><span class="line">girl.on(<span class="string">'失恋'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'监听到了 执行'</span>);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">/*执行结果：</span></span><br><span class="line"><span class="comment">1~</span></span><br><span class="line"><span class="comment">2~</span></span><br><span class="line"><span class="comment">1~</span></span><br><span class="line"><span class="comment">2~</span></span><br><span class="line"><span class="comment">3~</span></span><br><span class="line"><span class="comment">监听到了 执行</span></span><br><span class="line"><span class="comment">监听到了 执行</span></span><br><span class="line"><span class="comment">3~</span></span><br><span class="line"><span class="comment">监听到了 执行</span></span><br><span class="line"><span class="comment">监听到了 执行</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>分析： line18绑定到数组中{‘失恋’：[fn]}，绑定一次执行一次line8，line21绑定到数组中{‘失恋’: [fn,fn]}，on绑定一次，line8执行一次，因为line12是异步的，同步执行完之后line12执行，刚才line8执行了2次(线程里存储了2个微任务)，所以line12这里也执行2次，这样一共就四次了。</p>
</blockquote>
<h5 id="once-解决"><a href="#once-解决" class="headerlink" title="once 解决"></a>once 解决</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> EventEmitter = <span class="built_in">require</span>(<span class="string">'events'</span>);</span><br><span class="line"><span class="keyword">let</span> util = <span class="built_in">require</span>(<span class="string">'util'</span>)</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Girl</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">&#125;</span><br><span class="line">util.inherits(Girl,EventEmitter);</span><br><span class="line"><span class="keyword">let</span> girl = <span class="keyword">new</span> Girl();</span><br><span class="line"></span><br><span class="line">girl.on(<span class="string">'newListener'</span>, (type)=&gt;&#123;</span><br><span class="line">    <span class="keyword">if</span>(type === <span class="string">'失恋'</span>)&#123;</span><br><span class="line">        process.nextTick(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">            girl.emit(type);</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">girl.once(<span class="string">'失恋'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'监听到了 执行'</span>);</span><br><span class="line">&#125;)</span><br><span class="line">girl.once(<span class="string">'失恋'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'监听到了 执行'</span>);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">/*执行结果</span></span><br><span class="line"><span class="comment">监听到了 执行</span></span><br><span class="line"><span class="comment">监听到了 执行</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h5 id="off-解除绑定"><a href="#off-解除绑定" class="headerlink" title="off 解除绑定"></a>off 解除绑定</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> EventEmitter = <span class="built_in">require</span>(<span class="string">'./events'</span>);</span><br><span class="line"><span class="keyword">let</span> util = <span class="built_in">require</span>(<span class="string">'util'</span>)</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Girl</span>(<span class="params"></span>)</span>&#123; </span><br><span class="line">&#125;</span><br><span class="line">util.inherits(Girl,EventEmitter);</span><br><span class="line"><span class="keyword">let</span> girl = <span class="keyword">new</span> Girl();</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> fn1 = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'监听到了 执行'</span>);</span><br><span class="line">&#125;</span><br><span class="line">girl.once(<span class="string">'失恋'</span>, fn1);</span><br><span class="line">girl.off(<span class="string">'失恋'</span>, fn1);</span><br><span class="line">girl.once(<span class="string">'失恋'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'监听到了 执行'</span>);</span><br><span class="line">&#125;)</span><br><span class="line">girl.emit(<span class="string">"失恋"</span>);</span><br><span class="line"><span class="comment">/*执行结果：</span></span><br><span class="line"><span class="comment">监听到了 执行</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h5 id="手写events-优化"><a href="#手写events-优化" class="headerlink" title="手写events 优化"></a>手写events 优化</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">EventEmitter</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>._events = <span class="built_in">Object</span>.create(<span class="literal">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// &#123;'name': [listener, listener]&#125;</span></span><br><span class="line">EventEmitter.prototype.on = <span class="function"><span class="keyword">function</span> (<span class="params">eventName, callback</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 不管任何人调动了on方法 都可以增加_events</span></span><br><span class="line">    <span class="keyword">if</span>( !<span class="keyword">this</span>._events) <span class="keyword">this</span>._events = <span class="built_in">Object</span>.create(<span class="literal">null</span>);</span><br><span class="line">    <span class="comment">// 监听绑定的事件 不是newLister就调用newListener</span></span><br><span class="line">    <span class="keyword">if</span>(eventName !== <span class="string">'newListener'</span>)&#123;</span><br><span class="line">        <span class="keyword">this</span>.emit(<span class="string">'newListener'</span>, eventName);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 当这里调用的事件不是newLister，是失恋，那就把'失恋'传到girl.on('newListener', fn(type))后面的那个方法里，type就是'失恋'，每次on事件，newListener就能监听到，存起来，然后执行</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span>._events[eventName])&#123;</span><br><span class="line">        <span class="keyword">this</span>._events[eventName].push(callback);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">this</span>._events[eventName] = [callback];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">EventEmitter.prototype.once = <span class="function"><span class="keyword">function</span>(<span class="params">eventName, callback</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 绑定 =&gt; 执行后 =&gt; 再删除</span></span><br><span class="line">    <span class="keyword">let</span> one = <span class="function"><span class="params">()</span>=&gt;</span>&#123; <span class="comment">// 2) 会触发one函数</span></span><br><span class="line">        callback(); <span class="comment">// 触发原有的逻辑</span></span><br><span class="line">        <span class="comment">// 删除自己</span></span><br><span class="line">        <span class="keyword">this</span>.off(eventName, one); <span class="comment">// 再将one删除掉</span></span><br><span class="line">    &#125;</span><br><span class="line">    one.l = callback;  <span class="comment">// 用自定义属性 保存原有的绑定函数</span></span><br><span class="line">    <span class="keyword">this</span>.on(eventName, one); <span class="comment">// 1) 先绑定</span></span><br><span class="line">&#125;</span><br><span class="line">EventEmitter.prototype.off = <span class="function"><span class="keyword">function</span>(<span class="params">eventName, callback</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span>._events[eventName])&#123;</span><br><span class="line">        <span class="keyword">this</span>._events[eventName] = <span class="keyword">this</span>._events[eventName].filter( <span class="function"><span class="params">fn</span>=&gt;</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> fn != callback &amp;&amp; fn.l !== callback;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">EventEmitter.prototype.emit = <span class="function"><span class="keyword">function</span>(<span class="params">eventName, ...args</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span>._events[eventName])&#123;</span><br><span class="line">        <span class="keyword">this</span>._events[eventName].forEach(<span class="function"><span class="params">fn</span> =&gt;</span> &#123;</span><br><span class="line">            fn(...args);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">module</span>.exports = EventEmitter;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>node事件绑定 核心模块<br>  on 、emit 、once 、newListener 、off</p>
</blockquote>
]]></content>
      <categories>
        <category>Nodejs</category>
      </categories>
  </entry>
  <entry>
    <title>Node-npm</title>
    <url>/2019/09/24/Node-npm/</url>
    <content><![CDATA[<h2 id="初始化包"><a href="#初始化包" class="headerlink" title="初始化包"></a>初始化包</h2><p>package.json </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm init</span><br></pre></td></tr></table></figure>

<h2 id="下载包"><a href="#下载包" class="headerlink" title="下载包"></a>下载包</h2><p>全局安装 在任意命令行下使用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm i http-server -g</span><br></pre></td></tr></table></figure>

<a id="more"></a>
<blockquote>
<p>可以在命令中使用</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/usr/local/bin/http-server -&gt; /usr/local/lib/node_modules/http-server/bin/http-server</span><br><span class="line">/usr/local/bin/hs -&gt; /usr/local/lib/node_modules/http-server/bin/http-server</span><br></pre></td></tr></table></figure>

<p>现在我在命令行里面http-server起这个服务，其实就是调取/usr/local/lib/node_modules/http-server/bin/http-server这个下的服务 line2是缩写 可以在命令行hs起服务</p>
<p>现在我要写一个全局包,npm link链接,创建快捷方式指向我的文件  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;bin&quot;: &#123;</span><br><span class="line">    &quot;lesson-zf&quot;: &quot;./bin/www&quot;,</span><br><span class="line">    &quot;lz&quot;:&quot;./bin/www&quot;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<ul>
<li>本地安装</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install jquery --save / -S</span><br><span class="line">npm install webpack --save-dev / -D</span><br></pre></td></tr></table></figure>

<p>默认不给- -save表示安装到当前的dependencies 表示是上线和开发的时候都需要<br>devDependencies 开发依赖 上线的时候不需要</p>
<blockquote>
<p>有一天把模块发布了 别人会安装你的发布的模块，如果你的模块被别人安装，你的模块中的dependencies会默认一起被下载,devDependencies不会下载的</p>
</blockquote>
<p><code>sudo npm cache clean --force</code>   如果按装包按了一半挂了，可以用这个清空看看</p>
<p>常见的依赖项<br>dependcies<br>devDepencies<br>npm install –production 可以只安装dependcies</p>
<p>peerDependencies  会提示你安装缺少的模块 默认要求带版本<br>bundleDependencies 放置后面打包项   npm pack打包<br>optionalDependencies 如果找不到 不会影响npm的下载</p>
<h2 id="版本问题"><a href="#版本问题" class="headerlink" title="版本问题"></a>版本问题</h2><ul>
<li>npm使用了 1.0.0  第一位如果变了 表示不兼容老代码 大规模的更新<br>第二位表示增加了一些功能<br>第三位 表示小的补丁</li>
</ul>
<blockquote>
<p>npm + git<br>npm version major minor patch 更改版本 并且可以同步 git tag</p>
</blockquote>
<p>npm采用了semver规范作为依赖版本管理方案。semver 约定一个包的版本号必须包含3个数字</p>
<ul>
<li>MAJOR 对应大的版本号迭代，做了不兼容旧版的修改时要更新 MAJOR 版本号</li>
<li>MINOR 对应小版本迭代，发生兼容旧版API的修改或功能更新时，更新MINOR版本号</li>
<li>PATCH 对应修订版本号，一般针对修复 BUG 的版本号</li>
</ul>
<table>
<thead>
<tr>
<th>range</th>
<th>含义</th>
<th>例</th>
</tr>
</thead>
<tbody><tr>
<td><code>^2.2.1</code></td>
<td>指定的 MAJOR 版本号下, 所有更新的版本</td>
<td>匹配 <code>2.2.3</code>, <code>2.3.0</code>; 不匹配 <code>1.0.3</code>, <code>3.0.1</code></td>
</tr>
<tr>
<td><code>~2.2.1</code></td>
<td>指定 MAJOR.MINOR 版本号下，所有更新的版本</td>
<td>匹配 <code>2.2.3</code>, <code>2.2.9</code> ; 不匹配 <code>2.3.0</code>, <code>2.4.5</code></td>
</tr>
<tr>
<td><code>&gt;=2.1</code></td>
<td>版本号大于或等于 <code>2.1.0</code></td>
<td>匹配 <code>2.1.2</code>, <code>3.1</code></td>
</tr>
<tr>
<td><code>&lt;=2.2</code></td>
<td>版本号小于或等于 <code>2.2</code></td>
<td>匹配 <code>1.0.0</code>, <code>2.2.1</code>, <code>2.2.11</code></td>
</tr>
<tr>
<td><code>1.0.0 - 2.0.0</code></td>
<td>版本号从 1.0.0 (含) 到 2.0.0 (含)</td>
<td>匹配 <code>1.0.0</code>, <code>1.3.4</code>, <code>2.0.0</code></td>
</tr>
</tbody></table>
<p>预发版：</p>
<ul>
<li>alpha(α)：预览版，或者叫内部测试版；一般不向外部发布，会有很多bug；一般只有测试人员使用。</li>
<li>beta(β)：测试版，或者叫公开测试版；这个阶段的版本会一直加入新的功能；在alpha版之后推出。</li>
<li>rc(release candidate)：最终测试版本；可能成为最终产品的候选版本，如果未出现问题则可发布成为正式版本。</li>
</ul>
<blockquote>
<p>你们项目如何发版</p>
</blockquote>
<h2 id="协议问题"><a href="#协议问题" class="headerlink" title="协议问题"></a>协议问题</h2><p><a href="http://www.ruanyifeng.com/blogimg/asset/201105/free_software_licenses.png" target="_blank" rel="noopener">http://www.ruanyifeng.com/blogimg/asset/201105/free_software_licenses.png</a></p>
<h2 id="scripts"><a href="#scripts" class="headerlink" title="scripts"></a>scripts</h2><p>scripts 配置执行的脚本 </p>
<p>1) 执行命令 echo xxx<br>2) 执行node_modules/.bin下的文件</p>
<p>当我在命令行执行npm run 的时候 他会把当前目录node_modules/.bin也拷贝到当前的系统的path中,所以npm run 可以执行.bin下的文件 （npm run env 试下，搜索path 可以看到当前目录下的bin放在了path环境下）</p>
<h2 id="npx"><a href="#npx" class="headerlink" title="npx"></a>npx</h2><p>可以直接执行node_modules/.bin文件 不需要在去配置scriprts<br>如果模块不存在可以安装 ,安装完是有后还会自己销毁,避免安装全局模块<br>比如：npm create-react-app project-name 这样create-react-app就会一直存在也没有版本更新<br>比如：npx create-react-app project-name 不会安装create-react-app 这样每次执行的都是最新的包</p>
<h2 id="发布"><a href="#发布" class="headerlink" title="发布"></a>发布</h2><p>发布包的时候 @vue/cli @vue/service<br>先切换到npm官方上  （npm配置文件  cat ~/.npmrc）<br>nrm可以切换源 nvm npm</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install nrm -g </span><br><span class="line">nrm ls</span><br><span class="line">nrm use npm</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Nodejs</category>
      </categories>
  </entry>
  <entry>
    <title>Nodejs 模块 （二）</title>
    <url>/2019/09/23/Node-Module-2/</url>
    <content><![CDATA[<h2 id="手写require-继上一篇-深入"><a href="#手写require-继上一篇-深入" class="headerlink" title="手写require 继上一篇 深入"></a>手写require 继上一篇 深入</h2><blockquote>
</blockquote>
<ul>
<li>node中js文件就是一个模块</li>
<li>为什么出现模块的概念 防止命名冲突、可以把同样的功能封装到一起</li>
<li>esModule commonjs规范（一个文件是一个模块，module.exports导出给别人使用，require来引用别人的模块）</li>
</ul>
<a id="more"></a>
<p>新建 a.json</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">"name"</span>:<span class="string">"加菲"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>b.js</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = <span class="string">'hello'</span>;</span><br></pre></td></tr></table></figure>

<p>手写require模块</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// node模块会按照后缀名查找.js文件是否存在，再查找.json文件</span></span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="keyword">const</span> vm = <span class="built_in">require</span>(<span class="string">'vm'</span>);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Module</span>(<span class="params">id</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.id = id;</span><br><span class="line">    <span class="keyword">this</span>.exports = &#123;&#125;; <span class="comment">//模块的结果</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">Module.wrapper = [</span><br><span class="line">    <span class="string">'(function(exports,module,require,__filename,__dirname)&#123;'</span>,</span><br><span class="line">    <span class="string">'&#125;)'</span></span><br><span class="line">]</span><br><span class="line">Module.extension = &#123;</span><br><span class="line">    <span class="string">'.js'</span>(<span class="built_in">module</span>)&#123; <span class="comment">// js文件需要将exports传入给用户，自己赋值</span></span><br><span class="line">        <span class="keyword">let</span> script = fs.readFileSync(<span class="built_in">module</span>.id, <span class="string">'utf8'</span>);</span><br><span class="line">        <span class="comment">// module.exports = 'hello';</span></span><br><span class="line">        <span class="keyword">let</span> fnStr = Module.wrapper[<span class="number">0</span>] + script + Module.wrapper[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">let</span> fn = vm.runInThisContext(fnStr); <span class="comment">// 让字符串变成js代码</span></span><br><span class="line">        <span class="comment">// b.js里面打印console.log(this); 结果：module.exports，所以这里的call中的this是module.exports; </span></span><br><span class="line">		<span class="comment">// b.js文件中可能会有其他的require，所以下面是req 其实也就是我手写的这个req</span></span><br><span class="line">        fn.call(<span class="built_in">module</span>.exports, <span class="built_in">module</span>, <span class="built_in">module</span>.exports, req, <span class="built_in">module</span>.id, path.dirname(<span class="built_in">module</span>.id));</span><br><span class="line">        <span class="comment">//call第一个参数是改变this指向</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">'.json'</span>(<span class="built_in">module</span>)&#123; <span class="comment">// 解析后 node默认会赋值</span></span><br><span class="line">        <span class="keyword">let</span> script = fs.readFileSync(<span class="built_in">module</span>.id, <span class="string">'utf8'</span>);</span><br><span class="line">        <span class="built_in">module</span>.exports = <span class="built_in">JSON</span>.parse(script);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 给你一个相对路径 解析成绝对路径</span></span><br><span class="line">Module.resolveFilename = <span class="function"><span class="keyword">function</span>(<span class="params">filename</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 把相对路径转化成绝对路径 默认会先判断是否是绝对路径</span></span><br><span class="line">    <span class="keyword">let</span> absPath = path.resolve(__dirname, filename);</span><br><span class="line">    <span class="keyword">let</span> flag = fs.existsSync(absPath);</span><br><span class="line">    <span class="keyword">let</span> current = absPath; <span class="comment">// 默认是当前路径</span></span><br><span class="line">    <span class="keyword">if</span>( !flag)&#123;</span><br><span class="line">        <span class="keyword">let</span> keys = <span class="built_in">Object</span>.keys(Module.extension);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i&lt; keys.length; i++)&#123;</span><br><span class="line">            current = absPath + keys[i]; <span class="comment">//当前找到的文件路径</span></span><br><span class="line">            <span class="keyword">let</span> flag = fs.existsSync(current);</span><br><span class="line">            <span class="keyword">if</span>(flag)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                current = <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>( !current)&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'文件不存在'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> current; <span class="comment">// 返回的文件路径</span></span><br><span class="line">&#125;</span><br><span class="line">Module.prototype.load = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 模块加载就是读取文件的内容</span></span><br><span class="line">    <span class="keyword">let</span> ext = path.extname(<span class="keyword">this</span>.id);</span><br><span class="line">    Module.extension[ext](<span class="keyword">this</span>); <span class="comment">// 根据不同的后缀 调用不同的处理方法</span></span><br><span class="line">&#125;</span><br><span class="line">Module._cache = &#123;&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">req</span>(<span class="params">filename</span>)</span>&#123;<span class="comment">// 自己实现了一个require方法</span></span><br><span class="line">    <span class="keyword">let</span> current = Module.resolveFilename(filename);</span><br><span class="line">    <span class="keyword">if</span>(Module._cache[current])&#123; <span class="comment">// 相同的文件路径只加载一次</span></span><br><span class="line">        <span class="keyword">return</span> Module._cache[current].exports;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> <span class="built_in">module</span> = <span class="keyword">new</span> Module(current); <span class="comment">// 产生了一个module</span></span><br><span class="line">    Module._cache[current] = <span class="built_in">module</span>;</span><br><span class="line">    <span class="built_in">module</span>.load();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">module</span>.exports; <span class="comment">// 默认导出module.exports对象</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// let json = req('./a');</span></span><br><span class="line"><span class="comment">// console.log('json:', json);</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> js = req(<span class="string">'./b'</span>);</span><br><span class="line">req(<span class="string">'./b'</span>); <span class="comment">// 相同文件路径只缓存一次 line65</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'js:'</span>, js);</span><br></pre></td></tr></table></figure>

<ul>
<li>node中的模块分3类 文件模块 第三方模块（需要安装） 内置模块 fs path…</li>
<li>模块的查找路径：<br>现在查找的是b.js，如果有一个b的文件夹 ，先查找文件，找不到再找文件夹</li>
<li>第三方模块查找：<br>比如说：require(‘commander’);  他会找当前文件夹下的node_modules，再找同名的文件（commander），如果有package.json下{main:’xxx’}，那就会找入口文件main对应的文件，再找index.js,再找index.json，找不到会向上级的node_modules查找，直到根目录，根目录也找不到就报错；</li>
</ul>
]]></content>
      <categories>
        <category>Nodejs</category>
      </categories>
  </entry>
  <entry>
    <title>Nodejs中的全局变量、属性</title>
    <url>/2019/09/23/Node-argv/</url>
    <content><![CDATA[<blockquote>
<p>浏览器中有window对象   this默认就是指的window，浏览器无法直接访问global对象 所以需要window来代理<br>在node中可以直接访问global</p>
</blockquote>
<h3 id="全局变量"><a href="#全局变量" class="headerlink" title="全局变量"></a>全局变量</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 下面的a现在就是全局变量</span></span><br><span class="line">global.a = <span class="number">1</span>; </span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// let不会声明到全局作用域下</span></span><br><span class="line"><span class="keyword">let</span> b = <span class="number">2</span>;</span><br><span class="line"><span class="built_in">console</span>.log(global.b); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>

<a id="more"></a>
<p>node的特点：每个文件都是一个模块，模块外面包了一个匿名函数(module,exports,require,<strong>__</strong>dirname, <strong>____</strong>filename)</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="keyword">this</span> === global); <span class="comment">// false </span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">this</span> === <span class="built_in">module</span>.exports); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>想要打印global可以直接打印 global , 也可以如下 默认是global调用的</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>);</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>

<h3 id="全局属性"><a href="#全局属性" class="headerlink" title="全局属性"></a>全局属性</h3><p>global中的属性叫全局属性 、 module,exports,require,<strong>__</strong>dirname,<strong>__</strong>filename 叫全局对象</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 打印global中的属性</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.keys(global));</span><br></pre></td></tr></table></figure>

<p>全局属性：</p>
<ul>
<li>process 进程 可以开启很多个线程</li>
<li>Buffer 缓存区 读取文件 内存中的数据都是二进制的 默认代表二进制数据 Buffer是16进制的</li>
<li>clearInterval setInterval  宏任务</li>
<li>clearTimeout  setTimeout   宏任务</li>
<li>clearImmediate  setImmediate(浏览器中IE下才有) 宏任务</li>
</ul>
<hr>
<h4 id="process"><a href="#process" class="headerlink" title="process"></a>process</h4><p>1）process.platform // 平台  mac =&gt; darwin   window =&gt; win32<br>2）process.argv 代表用户传递的参数 默认有2个参数，前2个参数没有意义</p>
<ul>
<li>一般执行node 可以直接右键Run Code（需要安装插件）这样执行相当于node+文件名 执行</li>
<li>通过命令+文件名+参数 就可以用argv传参  参数取值process.argv.slice(2) 从第二个参数开始取</li>
</ul>
<p>commander：命令行的管家 帮你提供–help ,必须先安装  在命令行 执行该文件 node XXX [option]</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> program = <span class="built_in">require</span>(<span class="string">'commander'</span>);</span><br><span class="line"><span class="keyword">const</span> chalk = <span class="built_in">require</span>(<span class="string">'chalk'</span>);</span><br><span class="line"><span class="comment">// 解析用户的参数 默认提供--help</span></span><br><span class="line">program <span class="comment">// 配置命令 我输入命令后 要执行一些内容</span></span><br><span class="line">    .command(<span class="string">'create'</span>)</span><br><span class="line">    .alias(<span class="string">'c'</span>)</span><br><span class="line">    .description(<span class="string">'create project'</span>)</span><br><span class="line">    .action(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'create project'</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">program <span class="comment">//配置属性 给代码传递参数</span></span><br><span class="line">    .option(<span class="string">'-p, --port &lt;val&gt;'</span>,<span class="string">'set port'</span>)</span><br><span class="line">    .version(<span class="string">'1.0.0'</span>)</span><br><span class="line">program.on(<span class="string">'--help'</span>,()=&gt;&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'\r\nExamples'</span>)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'  node 1.js --help'</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'  node 1.js create '</span>+chalk.green(<span class="string">'project'</span>))</span><br><span class="line">&#125;).parse(process.argv);</span><br><span class="line"><span class="comment">// chalk 粉笔</span></span><br><span class="line"><span class="built_in">console</span>.log(program);</span><br></pre></td></tr></table></figure>

<p>3）chdir     cwd()( current working directory  当前工作目录)]</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(path.resolve()); <span class="comment">// 解析出一个绝对路径 和下面一样</span></span><br><span class="line"><span class="built_in">console</span>.log(process.cwd()); <span class="comment">// 在哪里执行文件 目录就是哪里 代表的就是执行的文件的目录</span></span><br></pre></td></tr></table></figure>

<p>4）env 环境变量</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(process.env); <span class="comment">// 可以根据环境变量的不同执行不同的结果</span></span><br></pre></td></tr></table></figure>

<p>5）nextTick   node中的微任务  Vue.nextTick</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 微任务</span></span><br><span class="line"><span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'then'</span>);</span><br><span class="line">&#125;)</span><br><span class="line">process.nextTick(<span class="function"><span class="params">()</span>=&gt;</span>&#123; <span class="comment">// node中的微任务</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'nextTick'</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// nextTick   then</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Nodejs</category>
      </categories>
  </entry>
  <entry>
    <title>Homework</title>
    <url>/2019/09/23/Homework/</url>
    <content><![CDATA[<h4 id="作业1"><a href="#作业1" class="headerlink" title="作业1"></a>作业1</h4><ul>
<li>反柯里化  实现</li>
<li>flat  实现</li>
<li>Array.prototype.reduce  模拟</li>
</ul>
<h4 id="作业2"><a href="#作业2" class="headerlink" title="作业2"></a>作业2</h4><ul>
<li>写一篇关于http的文章 1) 借鉴别人的文章  http 不安全 https</li>
<li>koa原理  ( 把koa源码看一下 用逼格最高代码来实现一版koa   reduce =&gt; compose)<br>1) compose方法 如何用async+await来重写<br>2) compose next方法如何 避免多次调用<br>3) ctx.body 没有赋值 如何处理</li>
</ul>
]]></content>
      <categories>
        <category>其他</category>
      </categories>
  </entry>
  <entry>
    <title>ES6 理论知识</title>
    <url>/2019/09/23/ES6/</url>
    <content><![CDATA[<h2 id="1-关于函数"><a href="#1-关于函数" class="headerlink" title="1 关于函数"></a>1 关于函数</h2><ul>
<li><p>什么是高阶函数？</p>
<p>  把函数作为参数或者返回值是函数</p>
</li>
<li><p>柯里化函数(函数更加具体，核心像bind，可以保留参数)   =&gt;  思考：反柯里化(让函数的调用方式变大)<br>  Object.prototype.toString.call 像这里toString需要在对象的原型上调用，我们希望哪里都可以调用，这就是反柯里化，然函数的调用变大 需要百度</p>
</li>
<li><p>AOP(装饰模式) 将函数进行包装</p>
<p>  AOP(面向切面编程)的主要作用是把一些跟核心业务逻辑无关的功能抽离出来，其实就是给原函数增加一层，不用管原函数内部实现</p>
</li>
<li><p>发布订阅（发布者和订阅两者是没有关系的，可以做解耦） 观察者模式（核心是基于发布订阅的，将观察者放到被观察者上面，当被观察者发送变化了会通知观察者  events on emit）</p>
<a id="more"></a>

</li>
</ul>
<h2 id="2-promise"><a href="#2-promise" class="headerlink" title="2 promise"></a>2 promise</h2><ul>
<li>promise 中的链式调用如何中断 ?</li>
<li>Promise.finally实现原理？</li>
<li>Promise有哪些优缺点？<br>  优点：解决异步并发问题Promise.all ；链式调用<br>  缺点：还是基于回调的；promise无法终止 new Promise立即执行的，只能说抛弃这次结果 </li>
<li>promise.race的原理</li>
<li>generator &amp; co</li>
<li>async + await 语法糖</li>
</ul>
<h2 id="3-ES6"><a href="#3-ES6" class="headerlink" title="3 ES6"></a>3 ES6</h2><ul>
<li>let &amp; const (1.没有变量提升 2.不会污染全局作用域 3.不能重复声明 4.拥有自己的作用域{}) import提升到当前代码顶部</li>
<li>Symbol 第六种基本数据类型 独一无二 11种symbol的定义方式 元编程</li>
<li>spread 深拷贝 数据类型的判断</li>
<li>set &amp; map（weakMap）去重 （交集 并集 差集）  V8引擎的垃圾回收  公开课视频</li>
<li>definedProperty proxy、reflect （数据劫持 代理）</li>
<li>ES6中的模块化（静态导入/ 动态导入） import export</li>
</ul>
<blockquote>
<p>拓展js中的数据结构</p>
</blockquote>
<h2 id="继续"><a href="#继续" class="headerlink" title="继续"></a>继续</h2><ul>
<li><p>es6中的类（类的继承（公有 实例上的属性）、静态属性、静态方法(static)、super关键词）</p>
</li>
<li><p>装饰器的应用</p>
</li>
<li><p>arrowfunc 箭头函数 (没有this，没有arguments，没有原型)</p>
</li>
<li><p>compose方法  reduce map filter some every find findIndex 应用</p>
</li>
<li><p>模板字符串 (模板引擎的实现原理)</p>
</li>
</ul>
]]></content>
      <categories>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title>Nodejs 知识梳理</title>
    <url>/2019/09/23/Nodejs/</url>
    <content><![CDATA[<h4 id="node-是一个js-的运行时-js-BOM-DOM-ECMASCRIPT-gt-node中只有ECMASCRIPT-模块"><a href="#node-是一个js-的运行时-js-BOM-DOM-ECMASCRIPT-gt-node中只有ECMASCRIPT-模块" class="headerlink" title="node 是一个js 的运行时 js BOM DOM ECMASCRIPT =&gt; node中只有ECMASCRIPT + 模块"></a>node 是一个js 的运行时 js BOM DOM ECMASCRIPT =&gt; node中只有ECMASCRIPT + 模块</h4><ul>
<li>import export babel-&gt; commonjs mjs</li>
<li>node 干什么？ 写些脚本(比如说webpack，都是用node写的) 中间层 服务端渲染（vue react）可以实现前后端分离 可以解决前端跨域问题、数据处理</li>
<li>实现高性能的web服务</li>
</ul>
<a id="more"></a>
<h4 id="浏览器事件环和node事件环"><a href="#浏览器事件环和node事件环" class="headerlink" title="浏览器事件环和node事件环"></a>浏览器事件环和node事件环</h4><p>v10+执行的效果是一样的。给每个宏任务对应的都配置了一个队列 timer poll check (每个执行完后清空一次微任务)</p>
<h4 id="进程和线程的区别-node中的进程"><a href="#进程和线程的区别-node中的进程" class="headerlink" title="进程和线程的区别 (node中的进程)"></a>进程和线程的区别 (node中的进程)</h4><ul>
<li>node执行一旦报错整个都会断掉，现在电脑都是多核 node可以开启多个子进程，监听同一个服务，其中一个挂了还能继续 pm2</li>
<li>一个进程中可以有多个线程，比如渲染线程、JS 引擎线程、HTTP 请求线程等等</li>
<li>进程表示一个程序，线程是进程中的单位  主线程只有一个 </li>
<li>1个进程可以占用1核cpu</li>
<li>多线程在单核cpu中其实也是顺序执行的，不过系统可以帮你切换哪个执行而已，没有提高速度</li>
<li>多个cpu的话就可以在多个cpu中同时执行</li>
</ul>
<blockquote>
<p>单线程优点：解决切换上下文时间,没有锁的问题（因为只有一个线程，不会两个线程操作同一个文件）,节省内存（切换上下文，多线程感觉是同一时间干了好多事，其实不是，你做一点，他再做一点，其实是多个线程不停的切换）</p>
</blockquote>
<blockquote>
<p>node是单线程的 主进程，再开多个子进程，里面包含着一个线程</p>
</blockquote>
<p>单线程<br><img src="https://jiafei2333.github.io/html/images/Single-Thread.png" alt></p>
<p>多线程<br><img src="https://jiafei2333.github.io/html/images/Multi-threading.png" alt></p>
<h4 id="node中的全局对象-可以直接调用的"><a href="#node中的全局对象-可以直接调用的" class="headerlink" title="node中的全局对象  (可以直接调用的)"></a>node中的全局对象  (可以直接调用的)</h4><ul>
<li>process，buffer</li>
<li>process.cwd() 可以改变 process.nextTick process.pid <strong>process.argv</strong> commander <strong>process.env</strong> 环境变量</li>
<li>require,exports,module,__filename,__dirname (可以直接在模块内部被访问)</li>
</ul>
<h4 id="node中的模块"><a href="#node中的模块" class="headerlink" title="node中的模块"></a>node中的模块</h4><ul>
<li>模块分类 ES6module,commonjs规范 amd,cmd,umd</li>
<li>commonjs规范  <ul>
<li>一个文件就是一个模块</li>
<li>如果模块想给别人使用 module.exports  /  exports 同一个对象但是最终导出的是module.exports </li>
<li>如果想使用这个模块 require (同步读取文件，包一个自执行函数，vm.runInthisContext,传入export对象，最终返回的是exports 对象，所以就可以拿到其他模块的内容)</li>
</ul>
</li>
<li>模块的查找规范<ul>
<li>第三方模块 module.paths</li>
<li>如果文件和文件夹重名 先取文件，文件不能取到，找文件夹 package.json =&gt; main =&gt; index.js</li>
</ul>
</li>
</ul>
<h3 id="node中模块的分类"><a href="#node中模块的分类" class="headerlink" title="node中模块的分类"></a>node中模块的分类</h3><ul>
<li>核心模块  require(‘moduleName’)<ul>
<li>fs fs.readFileSync ReadFile fs.existsSync fs.access</li>
<li>vm vm.runInThisContext</li>
<li>path path.resolve() join extname basename dirname (process.cwd())</li>
<li>util util.inherits util.promisify (转化成promise) async + await</li>
<li>events on(addListener) once(绑定一次) off(关闭绑定) newListener emit</li>
<li>发布订阅优势  解耦合</li>
</ul>
</li>
<li>文件模块/自定义模块 (同步读取文件，包一个自执行函数，vm.runInthisContext,传入export对象，最终返回的是exports 对象，所以就可以拿到其他模块的内容)</li>
<li>第三方模块 module.paths<ul>
<li>commander , chalk , mime 1.jpg </li>
</ul>
</li>
</ul>
<blockquote>
<p>如果文件和文件夹重名 先取文件，文件不能取到，找文件夹 package.json =&gt; main =&gt; index.js</p>
</blockquote>
]]></content>
      <categories>
        <category>Nodejs</category>
      </categories>
  </entry>
  <entry>
    <title>Nodejs 模块 （一）</title>
    <url>/2019/09/23/Node-Module/</url>
    <content><![CDATA[<h3 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h3><blockquote>
<p>es模块、commonjs模块</p>
</blockquote>
<ul>
<li>它们的特点都是一样的 每个文件都是一个模块<br>commonjs只是一个规范<br>1)每个文件都是一个模块<br>2)如果要使用 就需要require<br>3)如果要给别人用 就需要module.exports</li>
</ul>
<p>怎么实现模块化？  防止命名冲突<br>命名空间  无法彻底解决命名问题<br>自执行函数  node让js拥有了在服务端执行的能力，可以读写文件</p>
<hr>
<a id="more"></a>
<h3 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h3><p>新建usea.js、 a.js</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// a.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="string">'hello'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">(function()&#123;</span></span><br><span class="line"><span class="comment">    module.exports = 'hello';</span></span><br><span class="line"><span class="comment">    return module.exports;</span></span><br><span class="line"><span class="comment">&#125;)</span></span><br><span class="line"><span class="comment">// 虽然只写了line1，但是node内部会包装成line5-8自执行函数</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// usea.js</span><br><span class="line">let a = require(&apos;./a&apos;);</span><br></pre></td></tr></table></figure>

<p>这里require进来a文件相当于如下:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">module</span>.exports = <span class="string">'hello'</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">module</span>.exports;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>

<blockquote>
<p>怎么实现模块化的 传进来一个匿名函数，让函数执行，拿到它导出来的结果 就可以了</p>
</blockquote>
<p>node之所以能实现CommonJS规范，靠的是文件读写，将a文件读出来，加上自执行这个函数 一执行就好了。</p>
<h3 id="fs模块"><a href="#fs模块" class="headerlink" title="fs模块"></a>fs模块</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line">fs.readFileSync</span><br><span class="line"><span class="comment">// 判断文件是否存在</span></span><br><span class="line">fs.accessSync(<span class="string">'.gitgore'</span>); <span class="comment">// 如果不存在抛出异常</span></span><br></pre></td></tr></table></figure>

<h3 id="path模块"><a href="#path模块" class="headerlink" title="path模块"></a>path模块</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>); <span class="comment">// 专门处理路径的模块</span></span><br><span class="line"><span class="built_in">console</span>.log(path.resolve(<span class="string">'./a.js'</span>)); <span class="comment">// Users/jiafei/Desktop/node-test/a.js</span></span><br><span class="line"><span class="comment">// 它会从当前的跟路径下查找</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(__dirname); <span class="comment">// /Users/jiafei/Desktop/node-test/8.eventLoop </span></span><br><span class="line"><span class="comment">// 当前路径</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(path.resolve(__dirname, <span class="string">'./a.js'</span>)); <span class="comment">// /Users/jiafei/Desktop/node-test/8.eventLoop/a.js</span></span><br><span class="line"><span class="comment">//这样就能获取到当前路径下</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(path.resolve(__dirname, <span class="string">'./a.js'</span>, <span class="string">'b.js'</span>));<span class="comment">// /Users/jiafei/Desktop/node-test/8.eventLoop/a.js/b.js</span></span><br></pre></td></tr></table></figure>

<h4 id="resolve-amp-join"><a href="#resolve-amp-join" class="headerlink" title="resolve &amp; join"></a>resolve &amp; join</h4><p>join 就是单纯的拼路径</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">console.log(path.resolve(&apos;a&apos;, &apos;b&apos;)); //  /Users/jiafei/Desktop/node-test/a/b</span><br><span class="line">console.log(path.join(&apos;a&apos;, &apos;b&apos;)); // a/b</span><br></pre></td></tr></table></figure>

<p>加 __dirname</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(path.resolve(__dirname, <span class="string">'a'</span>, <span class="string">'b'</span>)); </span><br><span class="line"><span class="comment">// /Users/jiafei/Desktop/node-test/8.eventLoop/a/b</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(path.join(__dirname, <span class="string">'a'</span>, <span class="string">'b'</span>));</span><br><span class="line"><span class="comment">// /Users/jiafei/Desktop/node-test/8.eventLoop/a/b</span></span><br></pre></td></tr></table></figure>

<p>加 /</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// resolve出来的肯定是个绝对路径   join就是以/拼接</span></span><br><span class="line"><span class="built_in">console</span>.log(path.resolve(__dirname, <span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'/'</span>)); </span><br><span class="line"><span class="comment">// /Users/jiafei/Desktop/node-test/8.eventLoop/a/b</span></span><br><span class="line"><span class="comment">// /</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(path.join(__dirname, <span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'/'</span>));</span><br><span class="line"><span class="comment">// /Users/jiafei/Desktop/node-test/8.eventLoop/a/b/</span></span><br><span class="line"><span class="comment">// 有/ 只能用join</span></span><br></pre></td></tr></table></figure>

<p>其他</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(path.extname(<span class="string">'main.js'</span>));<span class="comment">// .js</span></span><br><span class="line"><span class="built_in">console</span>.log(path.basename(<span class="string">'main.js'</span>, <span class="string">'.js'</span>)); <span class="comment">// main</span></span><br><span class="line"><span class="built_in">console</span>.log(path.dirname(__dirname)); <span class="comment">// /Users/jiafei/Desktop/ zhufeng 获取父路径</span></span><br></pre></td></tr></table></figure>

<h3 id="vm模块"><a href="#vm模块" class="headerlink" title="vm模块"></a>vm模块</h3><p>它提供了一个沙箱环境(一个安全的环境，不会影响其它)</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">require</span>(<span class="string">'vm'</span>); <span class="comment">// 虚拟机模块</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*这里 引入a</span></span><br><span class="line"><span class="comment">let a = require('./a');</span></span><br><span class="line"><span class="comment">其实就是把 module.exports = 'hello';这段代码拿过来 ，套一个函数 </span></span><br><span class="line"><span class="comment">(function()&#123;</span></span><br><span class="line"><span class="comment">    module.exports = 'hello';</span></span><br><span class="line"><span class="comment">    return module.exports;</span></span><br><span class="line"><span class="comment">&#125;)</span></span><br><span class="line"><span class="comment">其实套完函数 它还是一个字符串 让一个字符串执行 </span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>让字符串执行 new Function \ eval \ vm</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">eval</span>(<span class="string">'console.log(a)'</span>);  <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

<p>这时a.js中的代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 供沙箱示例</span></span><br><span class="line"><span class="built_in">console</span>.log(b);</span><br><span class="line"><span class="built_in">module</span>.exports = <span class="string">'hello'</span>;</span><br></pre></td></tr></table></figure>

<p>usea.js</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// let b = XX；</span></span><br><span class="line"><span class="comment">// q这里的值就是引入的a.js中沙箱实例的代码</span></span><br><span class="line"><span class="keyword">let</span> q = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(b);</span><br><span class="line">    <span class="built_in">module</span>.exports = <span class="string">'hello'</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">module</span>.exports;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 如果这时usea模块line1 有 let b = XX；那就是line3-7这个模块拿到了usea模块的b的值，那乱了，希望的是a模块不能拿到外部的值</span></span><br><span class="line"><span class="keyword">let</span> vm = <span class="built_in">require</span>(<span class="string">'vm'</span>);</span><br><span class="line">vm.runInThisContext(<span class="string">'console.log(b)'</span>); <span class="comment">// ReferenceError: b is not defined</span></span><br></pre></td></tr></table></figure>

<h3 id="文件读写"><a href="#文件读写" class="headerlink" title="文件读写"></a>文件读写</h3><p>手写require模块</p>
<p>a.js</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// (function(exports,module,require)&#123;</span></span><br><span class="line">    <span class="built_in">module</span>.exports = <span class="string">'hello'</span>;</span><br><span class="line"><span class="comment">//&#125;)</span></span><br><span class="line"><span class="comment">// 这里其实内部是这样的</span></span><br></pre></td></tr></table></figure>

<p>usea.js</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="keyword">const</span> vm = <span class="built_in">require</span>(<span class="string">'vm'</span>);</span><br><span class="line"><span class="keyword">const</span> wrapper = [ <span class="comment">// module 和exports是什么关系   export是module的属性</span></span><br><span class="line">    <span class="string">'(function(exports,module,require)&#123;'</span>,</span><br><span class="line">    <span class="string">'&#125;)'</span></span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Module</span>(<span class="params">absPath</span>)</span>&#123; <span class="comment">// 创建模块</span></span><br><span class="line">    <span class="keyword">this</span>.id = absPath;</span><br><span class="line">    <span class="keyword">this</span>.exports = &#123;&#125;;</span><br><span class="line">&#125;</span><br><span class="line">Module.prototype.load = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// console.log(this.id); // 文件路径</span></span><br><span class="line">    <span class="keyword">let</span> script = fs.readFileSync(<span class="keyword">this</span>.id, <span class="string">'utf8'</span>);</span><br><span class="line">    <span class="comment">// module.exports = 'hello';</span></span><br><span class="line">    <span class="comment">// 现在取到内容了在外面加自执行函数</span></span><br><span class="line">    <span class="keyword">let</span> fnStr = wrapper[<span class="number">0</span>] + script + wrapper[<span class="number">1</span>];</span><br><span class="line">    <span class="comment">// 让字符串执行</span></span><br><span class="line">    <span class="keyword">let</span> fn = vm.runInThisContext(fnStr);</span><br><span class="line">    fn(<span class="keyword">this</span>.exports, <span class="keyword">this</span>, req); <span class="comment">// 让拼出的函数执行</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.exports); <span class="comment">// 上面这行fn函数执行了，那就是a文件里把值传给了exports 打印</span></span><br><span class="line">    <span class="comment">// hello</span></span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">req</span>(<span class="params">file</span>) </span>&#123;  <span class="comment">// ./a.js</span></span><br><span class="line">    <span class="comment">// 1) 把当前这个文件读取出来  把相对路径转化成绝对路径</span></span><br><span class="line">    <span class="keyword">let</span> absPath = path.resolve(__dirname, file);</span><br><span class="line">    <span class="comment">// /Users/jiafei/Desktop/node-test/8.eventLoop/a2</span></span><br><span class="line">    <span class="comment">// 加载一个模块 模块就是要有一个exports属性</span></span><br><span class="line">    <span class="comment">// 2) 创建一个模块</span></span><br><span class="line">    <span class="keyword">let</span> <span class="built_in">module</span> = <span class="keyword">new</span> Module(absPath); <span class="comment">// 创建了一个模块</span></span><br><span class="line">    <span class="comment">// 3）加载模块</span></span><br><span class="line">    <span class="built_in">module</span>.load();</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">module</span>.exports;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> a = req(<span class="string">'./a2.js'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"a:"</span>, a); <span class="comment">// a: hello</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>源码 require() 核心逻辑</p>
</blockquote>
<ul>
<li>Module._resolveFilename 解析文件名字  获取文件绝对路径</li>
<li>module.load(filename); 加载模块</li>
<li>fs.readFileSync(filename, ‘utf8’); 同步的读取文件内容</li>
<li>加函数</li>
<li>让函数执行 module.exports 传入给用户  用户会给module.exports赋值</li>
<li>把module.exports返回</li>
</ul>
]]></content>
      <categories>
        <category>Nodejs</category>
      </categories>
  </entry>
  <entry>
    <title>JavaScript基础知识梳理</title>
    <url>/2019/09/17/Points/</url>
    <content><![CDATA[<h2 id="for…of-amp-for…in"><a href="#for…of-amp-for…in" class="headerlink" title="for…of &amp; for…in"></a>for…of &amp; for…in</h2><h3 id="for…of"><a href="#for…of" class="headerlink" title="for…of"></a>for…of</h3><blockquote>
<p>mdn上的解释：for…of语句在可迭代对象（包括 Array，Map，Set，String，TypedArray，arguments 对象等等）上创建一个迭代循环，调用自定义迭代钩子，并为每个不同属性的值执行语句</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> o <span class="keyword">of</span> foo()) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(o);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 1 2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> str = <span class="string">'abcd'</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">of</span> str) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// "a"  "b"  "c"  "d"</span></span><br></pre></td></tr></table></figure>

<a id="more"></a>
<h3 id="for…in"><a href="#for…in" class="headerlink" title="for…in"></a>for…in</h3><blockquote>
<p>mdn上的解释：for…in语句以任意顺序遍历一个对象的除Symbol以外的可枚举属性。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;<span class="attr">a</span>:<span class="number">1</span>, <span class="attr">b</span>:<span class="number">2</span>, <span class="attr">c</span>:<span class="number">3</span>&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> prop <span class="keyword">in</span> obj) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(prop);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// "a" "b" "c"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 也可以遍历数组</span></span><br><span class="line"><span class="keyword">let</span> arr = [<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i <span class="keyword">in</span> arr)&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(i, arr[i])</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// "0" 3</span></span><br><span class="line"><span class="comment">// "1" 4</span></span><br><span class="line"><span class="comment">// "2" 5</span></span><br></pre></td></tr></table></figure>

<p>示例</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//for of  for in </span></span><br><span class="line"><span class="keyword">let</span> arr = [<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>];</span><br><span class="line"><span class="comment">//迭代每一项的值，一般适用于数组 或者 </span></span><br><span class="line"><span class="comment">//for of 是用来迭代那些实现了迭代器功能的对象</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> item <span class="keyword">of</span> arr)&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(item); <span class="comment">// a b c</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> item <span class="keyword">in</span> arr)&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(item); <span class="comment">// 0 1 2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> obj = &#123;<span class="attr">name</span>:<span class="string">'zhufeng'</span>,<span class="attr">age</span>:<span class="number">10</span>&#125;</span><br><span class="line"><span class="comment">//for in 是 迭代对的属性的</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> item <span class="keyword">in</span> obj)&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(item); <span class="comment">// name   age</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Array-from-amp-…"><a href="#Array-from-amp-…" class="headerlink" title="Array.from  &amp;  …"></a>Array.from  &amp;  …</h2><h2 id="Array-对数组的操作"><a href="#Array-对数组的操作" class="headerlink" title="Array 对数组的操作"></a>Array 对数组的操作</h2><h3 id="slice"><a href="#slice" class="headerlink" title="slice"></a>slice</h3><blockquote>
<p>slice() 方法返回一个新的数组对象，这一对象是一个由 begin 和 end 决定的原数组的浅拷贝（包括 begin，不包括end）。原始数组不会被改变。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> animals = [<span class="string">'ant'</span>, <span class="string">'bison'</span>, <span class="string">'camel'</span>, <span class="string">'duck'</span>, <span class="string">'elephant'</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(animals.slice(<span class="number">2</span>));</span><br><span class="line"><span class="comment">//  Array ["camel", "duck", "elephant"]</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(animals.slice(<span class="number">2</span>, <span class="number">4</span>));</span><br><span class="line"><span class="comment">//  Array ["camel", "duck"]</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(animals.slice(<span class="number">1</span>, <span class="number">5</span>));</span><br><span class="line"><span class="comment">//  Array ["bison", "camel", "duck", "elephant"]</span></span><br></pre></td></tr></table></figure>

<h3 id="split"><a href="#split" class="headerlink" title="split"></a>split</h3><blockquote>
<p>split() 方法使用指定的分隔符字符串将一个String对象分割成字符串数组，以将字符串分隔为子字符串，以确定每个拆分的位置。 </p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">'The quick brown fox jumps over the lazy dog.'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> words = str.split(<span class="string">' '</span>);</span><br><span class="line"><span class="built_in">console</span>.log(words[<span class="number">3</span>]);</span><br><span class="line"><span class="comment">// expected output: "fox"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> chars = str.split(<span class="string">''</span>);</span><br><span class="line"><span class="built_in">console</span>.log(chars);</span><br><span class="line"><span class="comment">// expected output: "k"</span></span><br></pre></td></tr></table></figure>

<h3 id="pop-、unshift、shift"><a href="#pop-、unshift、shift" class="headerlink" title="pop 、unshift、shift"></a>pop 、unshift、shift</h3><p>pop</p>
<h3 id="includes"><a href="#includes" class="headerlink" title="includes"></a>includes</h3><h3 id="concat"><a href="#concat" class="headerlink" title="concat"></a>concat</h3><p>concat() 方法用于合并两个或多个数组。此方法不会更改现有数组，而是返回一个新数组</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> array1 = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>];</span><br><span class="line"><span class="keyword">const</span> array2 = [<span class="string">'d'</span>, <span class="string">'e'</span>, <span class="string">'f'</span>, <span class="string">'a];</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">console.log(array1.concat(array2));</span></span><br><span class="line"><span class="string">// expected output: Array ["a", "b", "c", "d", "e", "f"]</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>js基础</category>
      </categories>
  </entry>
  <entry>
    <title>Generator & async await</title>
    <url>/2019/09/16/Generator/</url>
    <content><![CDATA[<p>生成器 生成迭代器的 </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 返回值叫迭代器</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> * <span class="title">read</span>(<span class="params"></span>)</span>&#123; <span class="comment">// 这个叫生成器函数</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="number">1</span>; <span class="comment">//产出</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// iterator 迭代器</span></span><br><span class="line"><span class="keyword">let</span> it = read();</span><br><span class="line"><span class="built_in">console</span>.log(it);</span><br><span class="line"><span class="built_in">console</span>.log(it.next());</span><br><span class="line"><span class="built_in">console</span>.log(it.next());</span><br><span class="line"><span class="built_in">console</span>.log(it.next());</span><br><span class="line"><span class="built_in">console</span>.log(it.next());</span><br><span class="line"><span class="comment">// 可以把上面都执行下  每次执行到yield都会停一下，执行next()才会继续走</span></span><br></pre></td></tr></table></figure>

<a id="more"></a>
<p>将类数组转化成数组</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 类数组的定义： 1 索引 2 长度</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log([...arguments]); <span class="comment">// 这里相当于把类数组通过...展开 在放在一个[]数组里</span></span><br><span class="line">&#125;</span><br><span class="line">add(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>); <span class="comment">// [ 1, 2, 3, 4 ]</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log([...&#123;<span class="number">0</span>:<span class="number">1</span>, <span class="number">1</span>:<span class="number">2</span>&#125;]); </span><br><span class="line">&#125;</span><br><span class="line">add(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>);</span><br><span class="line"><span class="comment">// 运行如上这个line8 报错 TypeError: &#123;(intermediate value)(intermediate value)&#125; is not iterable </span></span><br><span class="line"><span class="comment">// 因为 ... 或者for of 运行它们 必须要提供一个生成器方法  知识点：for of</span></span><br></pre></td></tr></table></figure>

<p>如果想要可用 如下 提供一个方法</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log([...&#123;<span class="number">0</span>:<span class="number">1</span>, <span class="number">1</span>:<span class="number">2</span>, [<span class="built_in">Symbol</span>.iterator]()&#123;</span><br><span class="line">        <span class="comment">// 迭代器 是有next方法 而且执行后 需要返回value，done</span></span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            next()&#123;</span><br><span class="line">                <span class="keyword">return</span> &#123;<span class="attr">value</span>: <span class="number">1</span>, <span class="attr">done</span>: <span class="literal">true</span>&#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;&#125;]); </span><br><span class="line">&#125;</span><br><span class="line">add(); <span class="comment">// []</span></span><br></pre></td></tr></table></figure>

<p>继续完善</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log([...&#123;</span><br><span class="line">        <span class="number">0</span>:<span class="number">1</span>, </span><br><span class="line">        <span class="number">1</span>:<span class="number">2</span>, </span><br><span class="line">        length: <span class="number">2</span>,</span><br><span class="line">        [<span class="built_in">Symbol</span>.iterator]()&#123; <span class="comment">// 迭代器</span></span><br><span class="line">            <span class="keyword">let</span> len = <span class="keyword">this</span>.length;</span><br><span class="line">            <span class="keyword">let</span> index = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">return</span> &#123;</span><br><span class="line">                next:<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">                    <span class="comment">// 这里面谁调这个next 肯定是line6这个函数去掉它的对象next</span></span><br><span class="line">                    <span class="comment">// 这个对象叫it  所以是it.next 所以这里用箭头函数</span></span><br><span class="line">                    <span class="comment">// index++  第一次的值是0 即line3 所以这里是++</span></span><br><span class="line">                    <span class="comment">// done 这里用index和当前的len相比 如果相等了就终止了</span></span><br><span class="line">                    <span class="keyword">return</span> &#123;<span class="attr">value</span>: <span class="keyword">this</span>[index++], <span class="attr">done</span>: index === len+<span class="number">1</span>&#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;&#125;]); </span><br><span class="line">&#125;</span><br><span class="line">add(); <span class="comment">// [ 1, 2 ]</span></span><br></pre></td></tr></table></figure>

<p>继续完善 将迭代器 改为生成器</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log([...&#123;</span><br><span class="line">        <span class="number">0</span>:<span class="number">1</span>, </span><br><span class="line">        <span class="number">1</span>:<span class="number">2</span>, </span><br><span class="line">        <span class="number">2</span>:<span class="number">3</span>,</span><br><span class="line">        length: <span class="number">3</span>,</span><br><span class="line">        [<span class="built_in">Symbol</span>.iterator]: <span class="function"><span class="keyword">function</span> * (<span class="params"></span>)</span>&#123; <span class="comment">// 生成器函数返回的就是迭代器 它会把每次返回的结果都放在这个数组里</span></span><br><span class="line">            <span class="keyword">let</span> index = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (index !== <span class="keyword">this</span>.length) &#123;</span><br><span class="line">                <span class="keyword">yield</span> <span class="keyword">this</span>[index++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// [Symbol.iterator]()&#123; // 迭代器</span></span><br><span class="line">        <span class="comment">//     let len = this.length;</span></span><br><span class="line">        <span class="comment">//     let index = 0;</span></span><br><span class="line">        <span class="comment">//     return &#123;</span></span><br><span class="line">        <span class="comment">//         next:()=&gt;&#123;</span></span><br><span class="line">        <span class="comment">//             // 这里面谁调这个next 肯定是line13这个函数去掉它的对象next</span></span><br><span class="line">        <span class="comment">//             // 这个对象叫it  所以是it.next 所以这里用箭头函数</span></span><br><span class="line">        <span class="comment">//             // index++  第一次的值是0 即line39 所以这里是++</span></span><br><span class="line">        <span class="comment">//             // done 这里用index和当前的len相比 如果相等了就终止了</span></span><br><span class="line">        <span class="comment">//             return &#123;value: this[index++], done: index === len+1&#125;</span></span><br><span class="line">        <span class="comment">//         &#125;</span></span><br><span class="line">        <span class="comment">//     &#125;</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">    &#125;]); </span><br><span class="line">&#125;</span><br><span class="line">add(); <span class="comment">// [ 1, 2, 3 ]</span></span><br></pre></td></tr></table></figure>

<p>… 会调这里的line7 Symbol.iterator方法，没这方法就不会循环</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 比如说</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> key <span class="keyword">of</span> &#123;<span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span>&#125;)&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 这样对象就会报错，因为它没有Symbol.iterator 方法，把这个方法加上就可以循环了</span></span><br><span class="line"><span class="comment">// line7-12与line13-25是一样的，建议写上面的，下面的太复杂了，每次line10 yield的时候就是调line17next方法 2个方法性质是一样的</span></span><br></pre></td></tr></table></figure>

<p>可以在console.log里面打印[] 查看数组有Symbol.iterator 迭代器</p>
<hr>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">read</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> a = <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(a);</span><br><span class="line">    <span class="keyword">let</span> b = <span class="keyword">yield</span> <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(b);</span><br><span class="line">    <span class="keyword">let</span> c = <span class="keyword">yield</span> <span class="number">3</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(c);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> it = read();</span><br><span class="line"><span class="built_in">console</span>.log(it.next());</span><br><span class="line"><span class="built_in">console</span>.log(it.next());</span><br><span class="line"><span class="built_in">console</span>.log(it.next());</span><br><span class="line"><span class="built_in">console</span>.log(it.next());</span><br></pre></td></tr></table></figure>

<p>如图所示为执行顺序：</p>
<p><img src="https://jiafei2333.github.io/html/images/yield-1.png" alt title="yield"></p>
<p>执行结果:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> &#123; <span class="attr">value</span>: <span class="number">1</span>, <span class="attr">done</span>: <span class="literal">false</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span> <span class="literal">undefined</span></span><br><span class="line">   &#123; <span class="attr">value</span>: <span class="number">2</span>, <span class="attr">done</span>: <span class="literal">false</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="number">3.</span> <span class="literal">undefined</span></span><br><span class="line">   &#123; <span class="attr">value</span>: <span class="number">3</span>, <span class="attr">done</span>: <span class="literal">false</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="number">4.</span> <span class="literal">undefined</span></span><br><span class="line">   &#123; <span class="attr">value</span>: <span class="literal">undefined</span>, <span class="attr">done</span>: <span class="literal">true</span> &#125;</span><br></pre></td></tr></table></figure>

<p>所以打印出来这里的a是undefined 要想a有值，可以如下</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">read</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> a = <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(a);</span><br><span class="line">    <span class="keyword">let</span> b = <span class="keyword">yield</span> <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(b);</span><br><span class="line">    <span class="keyword">let</span> c = <span class="keyword">yield</span> <span class="number">3</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(c);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> it = read();</span><br><span class="line"><span class="built_in">console</span>.log(it.next()); <span class="comment">// next 第一次传参没有意义</span></span><br><span class="line"><span class="built_in">console</span>.log(it.next(<span class="string">'aa'</span>)); <span class="comment">// 这个'aa' 传给上一次yield的返回值 这里就是a</span></span><br><span class="line"><span class="built_in">console</span>.log(it.next(<span class="string">'bb'</span>));</span><br><span class="line"><span class="built_in">console</span>.log(it.next(<span class="string">'cc'</span>));</span><br><span class="line"><span class="comment">// 执行结果：</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	&#123; value: 1, done: false &#125;</span></span><br><span class="line"><span class="comment">	aa</span></span><br><span class="line"><span class="comment">	&#123; value: 2, done: false &#125;</span></span><br><span class="line"><span class="comment">	bb</span></span><br><span class="line"><span class="comment">	&#123; value: 3, done: false &#125;</span></span><br><span class="line"><span class="comment">	cc</span></span><br><span class="line"><span class="comment">	&#123; value: undefined, done: true &#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>现在我想要第二次调用的时候报错 如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">read</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> a = <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">console</span>.log(a);</span><br><span class="line">        <span class="keyword">let</span> b = <span class="keyword">yield</span> <span class="number">2</span>;</span><br><span class="line">        <span class="built_in">console</span>.log(b);</span><br><span class="line">        <span class="keyword">let</span> c = <span class="keyword">yield</span> <span class="number">3</span>;</span><br><span class="line">        <span class="built_in">console</span>.log(c);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'err:'</span>,error);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> it = read();</span><br><span class="line"><span class="built_in">console</span>.log(it.next());</span><br><span class="line">it.throw(<span class="string">'抛出错误'</span>);</span><br><span class="line"><span class="comment">// 执行结果：</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	&#123; value: 1, done: false &#125;</span></span><br><span class="line"><span class="comment">	err: 抛出错误</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>现在理解了上面的原理之后 ，现在我们来读取文件内容</p>
<h5 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h5><p>现在在name.txt里面放“age.txt” , age.txt文件里面放“18”</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>).promises;</span><br><span class="line"><span class="comment">// 希望先读name.txt 再读age.txt</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> * <span class="title">read</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> content = <span class="keyword">yield</span> fs.readFile(__dirname + <span class="string">'/name.txt'</span>, <span class="string">'utf8'</span>); </span><br><span class="line">    <span class="keyword">let</span> age = <span class="keyword">yield</span> fs.readFile(__dirname + <span class="string">'/'</span> +content, <span class="string">'utf8'</span>);</span><br><span class="line">    <span class="keyword">return</span> age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> it = read();</span><br></pre></td></tr></table></figure>

<p>这里代码从哪里走到哪里 如图  这里面yield的值 是后面产生的value ，value产生的是个promise</p>
<p><img src="https://jiafei2333.github.io/html/images/yield-2.png" alt title="yield"></p>
<p>现在只考虑then成功的情况</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>).promises;</span><br><span class="line"><span class="function"><span class="keyword">function</span> * <span class="title">read</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> content = <span class="keyword">yield</span> fs.readFile(__dirname + <span class="string">'/name.txt'</span>, <span class="string">'utf8'</span>); </span><br><span class="line">    <span class="keyword">let</span> age = <span class="keyword">yield</span> fs.readFile(__dirname + <span class="string">'/'</span> +content, <span class="string">'utf8'</span>);</span><br><span class="line">    <span class="keyword">return</span> age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> it = read();</span><br><span class="line"></span><br><span class="line">it.next().value.then(<span class="function"><span class="params">data</span>=&gt;</span>&#123; <span class="comment">// 这步就是上图红色框起来的部分</span></span><br><span class="line">    <span class="comment">// data 这个data就是name.tx里面装的age.txt</span></span><br><span class="line">    <span class="comment">//it.next(data); 这一步就是把data传给了上面的content变量；并且走了yield fs.readFile(content, 'utf8'); 这步</span></span><br><span class="line">    it.next(data).value.then(<span class="function"><span class="params">data</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="comment">// 这里的data就是age.txt里面存放的18 现在要把18赋值给age</span></span><br><span class="line">        <span class="keyword">let</span> r = it.next(data);</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"r:"</span>,r); <span class="comment">// r: &#123; value: '18', done: true &#125;</span></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h4 id="co库"><a href="#co库" class="headerlink" title="co库"></a>co库</h4><p>安装yarn add co  可以去github上看下这个库</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>).promises;</span><br><span class="line"><span class="function"><span class="keyword">function</span> * <span class="title">read</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> content = <span class="keyword">yield</span> fs.readFile(__dirname + <span class="string">'/name.txt'</span>, <span class="string">'utf8'</span>); </span><br><span class="line">    <span class="keyword">let</span> age = <span class="keyword">yield</span> fs.readFile(__dirname + <span class="string">'/'</span> +content, <span class="string">'utf8'</span>);</span><br><span class="line">    <span class="comment">//比如新增一行 如下</span></span><br><span class="line">    <span class="keyword">let</span> xx = <span class="keyword">yield</span> &#123;<span class="attr">age</span>:age + <span class="number">10</span>&#125;;</span><br><span class="line">    <span class="comment">//return age;</span></span><br><span class="line">    <span class="keyword">return</span> xx;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> co = <span class="built_in">require</span>(<span class="string">'co'</span>);</span><br><span class="line">co(read()).then(<span class="function"><span class="params">data</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'co:'</span>,data); <span class="comment">// co: &#123; age: '1810' &#125;</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>手写co的实现原理</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>).promises;</span><br><span class="line"><span class="function"><span class="keyword">function</span> * <span class="title">read</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> content = <span class="keyword">yield</span> fs.readFile(__dirname + <span class="string">'/name.txt'</span>, <span class="string">'utf8'</span>); </span><br><span class="line">    <span class="keyword">let</span> age = <span class="keyword">yield</span> fs.readFile(__dirname + <span class="string">'/'</span> +content, <span class="string">'utf8'</span>);</span><br><span class="line">    <span class="keyword">let</span> xx = <span class="keyword">yield</span> &#123;<span class="attr">age</span>:age + <span class="number">10</span>&#125;;</span><br><span class="line">    <span class="keyword">return</span> xx;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">co</span>(<span class="params">it</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 因为co这里用了then所以是返回一个promise</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">        <span class="comment">// 异步迭代 需要先提供一个next方法</span></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">next</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">            <span class="keyword">let</span> &#123;value, done&#125; = it.next(data);</span><br><span class="line">            <span class="keyword">if</span>(!done)&#123;</span><br><span class="line">                <span class="comment">// 这里的value 是指 fs.readFile(__dirname + '/name.txt', 'utf8'); </span></span><br><span class="line">		<span class="comment">// 这一串返回的，但是不一定是promise line5就不是，所以要让它变成promise</span></span><br><span class="line">                <span class="built_in">Promise</span>.resolve(value).then(<span class="function"><span class="params">data</span>=&gt;</span>&#123;</span><br><span class="line">                    <span class="comment">//it.next(data);</span></span><br><span class="line">                    next(data);</span><br><span class="line">                &#125;,err=&gt;&#123;</span><br><span class="line">                    <span class="built_in">console</span>.log(err);</span><br><span class="line">                &#125;)</span><br><span class="line"></span><br><span class="line">            &#125;<span class="keyword">else</span>&#123; <span class="comment">// done是true 已完成</span></span><br><span class="line">                resolve(value);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        next();</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line">co(read()).then(<span class="function"><span class="params">data</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'co:'</span>,data);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h4 id="async-await"><a href="#async-await" class="headerlink" title="async await"></a>async await</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>).promises;</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">read</span>(<span class="params"></span>) </span>&#123; <span class="comment">// async 函数返回的是promise</span></span><br><span class="line">    <span class="keyword">let</span> content = <span class="keyword">await</span> fs.readFile(__dirname + <span class="string">'/name.txt'</span>, <span class="string">'utf8'</span>); </span><br><span class="line">    <span class="keyword">let</span> age = <span class="keyword">await</span> fs.readFile(__dirname + <span class="string">'/'</span> +content, <span class="string">'utf8'</span>);</span><br><span class="line">    <span class="keyword">let</span> xx = <span class="keyword">await</span> &#123;<span class="attr">age</span>:age + <span class="number">10</span>&#125;;</span><br><span class="line">    <span class="keyword">return</span> xx;</span><br><span class="line">&#125;</span><br><span class="line">read().then(<span class="function"><span class="params">data</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"async await:"</span>, data);</span><br><span class="line">&#125;,err=&gt;&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"err:"</span>, err);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// read()里面有错，line11都可以捕获到</span></span><br></pre></td></tr></table></figure>

<p>还可以这样捕获错误</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>).promises;</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">read</span>(<span class="params"></span>) </span>&#123; <span class="comment">// async 函数返回的是promise</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> content = <span class="keyword">await</span> fs.readFile(__dirname + <span class="string">'/name.txt'</span>, <span class="string">'utf8'</span>); </span><br><span class="line">        <span class="keyword">let</span> age = <span class="keyword">await</span> fs.readFile(__dirname + <span class="string">'/'</span> +content, <span class="string">'utf8'</span>);</span><br><span class="line">        <span class="keyword">let</span> xx = <span class="keyword">await</span> &#123;<span class="attr">age</span>:age + <span class="number">10</span>&#125;;</span><br><span class="line">        <span class="keyword">return</span> xx;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"error:"</span>, error);</span><br><span class="line">        <span class="comment">//return 1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">read().then(<span class="function"><span class="params">data</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"async await:"</span>, data); </span><br><span class="line">    <span class="comment">//如果line4-7捕获到错误 这里返回undefined  line10注释打开，这里就返回1</span></span><br><span class="line">&#125;,err=&gt;&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"err:"</span>, err);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>async + await 其实是generator + co的语法糖</p>
]]></content>
      <categories>
        <category>ES6</category>
      </categories>
  </entry>
  <entry>
    <title>EventLoop (浏览器 & node)</title>
    <url>/2019/09/16/EventLoop/</url>
    <content><![CDATA[<h3 id="宏任务微任务"><a href="#宏任务微任务" class="headerlink" title="宏任务微任务"></a>宏任务微任务</h3><ul>
<li><p>微任务： promise.then ，MutationObserver，process.nextTick</p>
</li>
<li><p>宏任务：script ，ajax ， 事件，requestAnimationFrame， setTimeout ，setInterval ，setImmediate （ie下），MessageChannel ，I/O ，UI rendering。</p>
</li>
</ul>
<blockquote>
<p>微任务 会比宏任务快，js中会先执行script脚</p>
</blockquote>
<a id="more"></a>
<h3 id="浏览器"><a href="#浏览器" class="headerlink" title="浏览器"></a>浏览器</h3><ul>
<li>线程、进程。 计算机调度任务的最小单位是进程。</li>
<li>js是单线程的 指的是进程中只有一个主线程，指的是主线程执行是单线程的 如果在其中调用了像ajax、setTimeout会再开辟一条线程</li>
<li>渲染线程（样式）和js线程是互斥的 </li>
<li>script脚本执行 （宏任务）</li>
<li>异步代码需要等待同步代码执行完毕 </li>
<li>宏任务：script，ajax，事件&nbsp;&nbsp;&nbsp;&nbsp;    微任务： promise.then</li>
</ul>
<p><img src="https://jiafei2333.github.io/html/images/eventLoop-browser.png" alt title="浏览器事件循环"></p>
<blockquote>
<p>当主线程全部执行完毕后 清空微任务 会取出一个宏任务，放到主线程中 =&gt; 执行完毕 继续清空微任务 =&gt; 无线循环 </p>
</blockquote>
<h4 id="1-顺序问题"><a href="#1-顺序问题" class="headerlink" title="1) 顺序问题"></a>1) 顺序问题</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">1</span>)</span><br><span class="line">&#125;, <span class="number">100</span>);</span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 上面这段代码永远也不会执行到line1-3 同步代码没有执行完</span></span><br></pre></td></tr></table></figure>

<p>这里面根本走不到异步代码，什么时候走呢，当整个主线程执行完毕之后 浏览器会开辟一条单独的线程去扫描②中的方法有没有好（click点击会产生函数、定时器时间到达会产生函数、ajax返回结果会产生函数），时间一到就会放到③队列中，比如当定时器第一个成功了会放到宏队列中 </p>
<h5 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<p>按照执行顺序 谁先到时间 谁先放到队列中 打印结果 1 2</p>
<p>当主站代码执行完毕之后 取出第一个宏任务放到主站（①）里执行，执行完之后 在取第二个宏任务，放到主站中，一个一个取。</p>
<h5 id="示例：-1"><a href="#示例：-1" class="headerlink" title="示例："></a>示例：</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="number">3</span>);</span><br><span class="line">    &#125;, <span class="number">0</span>);</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"><span class="comment">// 执行结果 ： 1 2 3</span></span><br></pre></td></tr></table></figure>

<h4 id="2-微任务和宏任务执行顺序问题"><a href="#2-微任务和宏任务执行顺序问题" class="headerlink" title="2) 微任务和宏任务执行顺序问题"></a>2) 微任务和宏任务执行顺序问题</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line"><span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">2</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">3</span>); </span><br><span class="line"><span class="comment">// 执行结果：132</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">3</span>);</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"><span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">2</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 执行结果：2 3</span></span><br></pre></td></tr></table></figure>

<p>当代码执行的时候会有宏任务和微任务，遇到微任务时会将微任务直接放到微任务队列，当主站代码执行完毕之后，会将微任务队列中的代码全部清空，再取出一个宏任务放到主线程执行</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'time1'</span>);</span><br><span class="line">    <span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'then3'</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'time2'</span>);</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"><span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'then1'</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'then2'</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 执行结果： then1  then2  time1  then3  time2</span></span><br></pre></td></tr></table></figure>

<p>当前主栈全部执行完毕后 清空微任务 ，会取出一个宏任务 -&gt;  执行完毕后 继续清空微任务 -&gt; 无线循环</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// vue 为什么要提供一个 $nextTick 不是每次一改数据就更新视图 会做一个缓存机制把多次更改缓存到一起，一起刷新视图</span></span><br><span class="line"><span class="comment">// 14课时 01：00：45 vue源码 nextTick</span></span><br><span class="line"><span class="keyword">this</span>.$nextTick(callback);</span><br><span class="line"><span class="keyword">this</span>.$nextTick(callback);</span><br><span class="line"><span class="keyword">this</span>.$nextTick(callback);</span><br><span class="line"><span class="keyword">this</span>.$nextTick(callback);</span><br><span class="line"><span class="keyword">this</span>.$nextTick(callback);</span><br><span class="line"><span class="comment">// [callback, callback,callback,callback,callback]</span></span><br></pre></td></tr></table></figure>

<h5 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async1</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'async1 start'</span>)</span><br><span class="line">    <span class="keyword">await</span> async2()</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'async1 end'</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async2</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'async2'</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'script start'</span>)</span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'setTimeout'</span>) </span><br><span class="line">&#125;,<span class="number">0</span>)  </span><br><span class="line">async1();</span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'promise1'</span>)</span><br><span class="line">    resolve();</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'promise2'</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'script end'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">执行结果：</span></span><br><span class="line"><span class="comment">script start</span></span><br><span class="line"><span class="comment">async1 start</span></span><br><span class="line"><span class="comment">async2</span></span><br><span class="line"><span class="comment">promise1</span></span><br><span class="line"><span class="comment">script end</span></span><br><span class="line"><span class="comment">async1 end</span></span><br><span class="line"><span class="comment">promise2</span></span><br><span class="line"><span class="comment">setTimeout</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">分析：</span><br><span class="line"><span class="comment">// line3 注意这里await后面接的是promise 所以下面的line4是在回调里面</span></span><br><span class="line"><span class="comment">// line 3、4相当于 浏览器的解析</span></span><br><span class="line"><span class="comment">// async2().then(()=&gt;&#123;</span></span><br><span class="line"><span class="comment">//     console.log('async1 end');</span></span><br><span class="line"><span class="comment">// &#125;)</span></span><br></pre></td></tr></table></figure>

<hr>
<h3 id="Nodejs"><a href="#Nodejs" class="headerlink" title="Nodejs"></a>Nodejs</h3><blockquote>
<p>浏览器事件环是V8引擎提供的， 新版本node11和浏览器基本一样，node里是自己实现的事件环</p>
</blockquote>
<h3 id="node中的事件环"><a href="#node中的事件环" class="headerlink" title="node中的事件环"></a>node中的事件环</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">    ┌───────────────────────┐</span><br><span class="line">┌─&gt; │        timers         │ 本阶段执行setTimeout() 和 setInterval()   []</span><br><span class="line">│   └──────────┬────────────┘</span><br><span class="line">│   ┌──────────┴────────────┐</span><br><span class="line">│   │     I/O callbacks     │ 这个阶段执行一些诸如TCP错误之类的系统操作的回调 （一般用不到,可忽略）</span><br><span class="line">│   └──────────┬────────────┘</span><br><span class="line">│   ┌──────────┴────────────┐</span><br><span class="line">│   │     idle, prepare     │ 只node内部使用（可忽略）</span><br><span class="line">│   └──────────┬────────────┘      ┌───────────────┐</span><br><span class="line">│   ┌──────────┴────────────┐      │   incoming:   │</span><br><span class="line">│   │         poll(轮询)     |  &lt;───┤  connections, │ 获取新的 I/O 事件,查找已经到时的定时器</span><br><span class="line">│   └──────────┬────────────┘      │   data, etc.  │</span><br><span class="line">│   ┌──────────┴────────────┐      └───────────────┘</span><br><span class="line">│   │        check          │ setImmediate()</span><br><span class="line">│   └──────────┬────────────┘</span><br><span class="line">│   ┌──────────┴────────────┐</span><br><span class="line">└──-┤    close callbacks    │ 关闭事件的回调 socket.close事件 （目前接触不到）</span><br><span class="line">    └──────────────────────—┘</span><br></pre></td></tr></table></figure>

<p><img src="https://jiafei2333.github.io/html/images/eventLoop-node.png" alt title="Nodejs事件循环"></p>
<h4 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h4><p>1)<br>node中 setImmediate 相当于没有设置时间的setTimeout 不过它们执行的时间段不同<br>根据调用的上下文</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">   <span class="built_in">console</span>.log(<span class="string">'setTimeout'</span>);</span><br><span class="line">&#125;, );</span><br><span class="line">setImmediate(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'setImmediate'</span>);</span><br><span class="line"> &#125;, );</span><br><span class="line"><span class="comment">// 执行结果：setImmediate   setTimeout || setTimeout   setImmediate</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>它们的执行顺序受node的性能影响 因为有可能主站执行完成后 setTimeout的时间还没到 则会先执行setImmediate</p>
</blockquote>
<p>2)</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line">fs.readFile(<span class="string">'./gitignore'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="comment">// 根据调用的上下文</span></span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'setTimeout'</span>);</span><br><span class="line">     &#125;, );</span><br><span class="line">     setImmediate(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">         <span class="built_in">console</span>.log(<span class="string">'setImmediate'</span>);</span><br><span class="line">      &#125;, );</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 这里就肯定先执行 setImmediate 再setTimeout</span></span><br><span class="line"><span class="comment">// setImmediate如果在I/O之后会立即执行</span></span><br></pre></td></tr></table></figure>

<p>3)</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'timer'</span>+<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'then1'</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'then2'</span>);</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'timer'</span>+<span class="number">2</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">浏览器执行结果：</span></span><br><span class="line"><span class="comment">then2</span></span><br><span class="line"><span class="comment">timer1</span></span><br><span class="line"><span class="comment">then1</span></span><br><span class="line"><span class="comment">timer2</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Nodejs</category>
      </categories>
  </entry>
  <entry>
    <title>类中的装饰器</title>
    <url>/2019/09/16/Class-Decorator/</url>
    <content><![CDATA[<h4 id="装饰器-装饰模式"><a href="#装饰器-装饰模式" class="headerlink" title="装饰器 装饰模式"></a>装饰器 装饰模式</h4><p>在执行类之前可以进行包装</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">@type</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// type(Animal)</span></span><br><span class="line"><span class="comment">// 类似于这样 可以当做是它的语法糖</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 默认会调用这个type并且把Animal传过来</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">type</span>(<span class="params">Constructor</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(Constructor);  <span class="comment">// webpack环境运行</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// class Animal &#123;&#125;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">@type1</span><br><span class="line">@type2</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">type1</span>(<span class="params">Constructor</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">1</span>); </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">type2</span>(<span class="params">Constructor</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 打印 2 1  执行顺序 先走最近的</span></span><br></pre></td></tr></table></figure>

<a id="more"></a>
<p>对类进行扩展 也可以传参</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">@type1(<span class="string">'哺乳1'</span>) </span><br><span class="line">@type2(<span class="string">'哺乳2'</span>) </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">type1</span>(<span class="params">Constructor</span>)</span>&#123;</span><br><span class="line">    Constructor.type1 = <span class="string">'哺乳类1'</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">type2</span>(<span class="params">Constructor</span>)</span>&#123;</span><br><span class="line">    Constructor.type2 = <span class="string">'哺乳类2'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>装饰器必须是个函数  只能修饰类 （类中的属性 类中的方法）:参数分别是 类的原型 装饰的key 和key对应的属性</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">@type1(<span class="string">'哺乳1'</span>) <span class="comment">// 之前type1是个函数 现在type1执行之后的结果是个函数</span></span><br><span class="line">@type2(<span class="string">'哺乳2'</span>) <span class="comment">// 这里就是把Animal传给了这个函数的返回值 所以line8放置参数Constructor</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">type1</span>(<span class="params">type1</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'t1'</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">Constructor</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'inner t1'</span>);</span><br><span class="line">        Constructor.type1 = type1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">type2</span>(<span class="params">type2</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'t2'</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">Constructor</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'inner t2'</span>);</span><br><span class="line">        Constructor.type1 = type2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 执行顺序  t1 =&gt; t2 =&gt; inner t2 =&gt; inner t1</span></span><br></pre></td></tr></table></figure>

<h4 id="类"><a href="#类" class="headerlink" title="类"></a>类</h4><h5 id="类中的属性"><a href="#类中的属性" class="headerlink" title="类中的属性"></a>类中的属性</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span></span>&#123;</span><br><span class="line">    PI = <span class="number">3.14</span>; <span class="comment">// 这样写表示实例上的属性</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> c = <span class="keyword">new</span> Circle();</span><br><span class="line">c.PI = <span class="number">3.15</span>;</span><br><span class="line"><span class="built_in">console</span>.log(c); <span class="comment">// 3.15</span></span><br></pre></td></tr></table></figure>

<p>现在我希望不能更改这个值</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span></span>&#123;</span><br><span class="line">    @readonly PI = <span class="number">3.14</span>;</span><br><span class="line">    a()&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">readonly</span>(<span class="params">CirclePropertype, key, descriptor</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(CirclePropertype, key, descriptor);</span><br><span class="line">    <span class="comment">// 这里Circle还没执行完 才执行到line2 所以line8这样写调取不到 用定时器来执行下</span></span><br><span class="line">    <span class="comment">//console.log(CirclePropertype === Circle.prototype);</span></span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">         <span class="built_in">console</span>.log(CirclePropertype === Circle.prototype); <span class="comment">// true</span></span><br><span class="line">     &#125;, );</span><br><span class="line">    <span class="built_in">console</span>.log(descriptor.initializer()); <span class="comment">// 3.14  调取descriptor中的initializer返回的就是value的值</span></span><br><span class="line">    <span class="comment">//  现在希望是只读的</span></span><br><span class="line">    descriptor.writable = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> c = <span class="keyword">new</span> Circle();</span><br><span class="line">c.PI = <span class="number">3.15</span>;</span><br><span class="line"><span class="built_in">console</span>.log(c); <span class="comment">// PI 3.14</span></span><br></pre></td></tr></table></figure>

<h5 id="类中的方法"><a href="#类中的方法" class="headerlink" title="类中的方法"></a>类中的方法</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span></span>&#123;</span><br><span class="line">    say()&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'说话'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> c = <span class="keyword">new</span> Circle();</span><br><span class="line">c.say(); <span class="comment">// 说话</span></span><br></pre></td></tr></table></figure>

<p>现在希望在说话前做些其他的事情</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span></span>&#123;</span><br><span class="line">    @before</span><br><span class="line">    say()&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'说话'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">before</span>(<span class="params">CirclePropertype, key, descriptor</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(CirclePropertype, key, descriptor);</span><br><span class="line">    <span class="comment">// 通过打印可以看到 这里 descriptor.value 指的是say方法</span></span><br><span class="line">    <span class="keyword">let</span> oldSay = descriptor.value; <span class="comment">// 函数劫持  这个是原有的方法</span></span><br><span class="line">    descriptor.value = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="comment">// 将函数原有的逻辑进行包装</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"todo"</span>);</span><br><span class="line">        oldSay();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> c = <span class="keyword">new</span> Circle();</span><br><span class="line">c.say(); <span class="comment">// todo  说话</span></span><br></pre></td></tr></table></figure>

<p>装饰器 实验型语法 目前node不支持</p>
<p>拓展 mixin 混合</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 常见用法</span></span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    name: <span class="string">'加菲'</span>,</span><br><span class="line">    age: <span class="number">18</span></span><br><span class="line">&#125;</span><br><span class="line">@mixin(obj)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">School</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mixin</span>(<span class="params">obj</span>)</span>&#123; </span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">Constructor</span>)</span>&#123; <span class="comment">// Constructor 就是school</span></span><br><span class="line">        <span class="built_in">Object</span>.assign(Constructor.prototype, obj);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> school = <span class="keyword">new</span> School;</span><br><span class="line"><span class="built_in">console</span>.log(school.name, school.age); <span class="comment">// 加菲 18</span></span><br></pre></td></tr></table></figure>

<h5 id="重写原型方法"><a href="#重写原型方法" class="headerlink" title="重写原型方法"></a>重写原型方法</h5><p>希望调用数组的方法 实现视图的更新</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> update = <span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'更新'</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> arr = [];</span><br><span class="line"><span class="keyword">let</span> oldProto = <span class="built_in">Array</span>.prototype; <span class="comment">// 保留数组原有的原型</span></span><br><span class="line"><span class="keyword">let</span> proto = <span class="built_in">Object</span>.create(oldProto); <span class="comment">// 创建了一个新proto</span></span><br><span class="line">[<span class="string">'push'</span>,<span class="string">'unshift'</span>,<span class="string">'shift'</span>].forEach(<span class="function"><span class="params">method</span>=&gt;</span>&#123;</span><br><span class="line">    proto[method] = <span class="function"><span class="keyword">function</span>(<span class="params">...args</span>)</span>&#123;</span><br><span class="line">        update();</span><br><span class="line">        oldProto[method].call(<span class="keyword">this</span>,...args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">observer</span>(<span class="params">obj</span>)</span>&#123; <span class="comment">// 只将我们传入的数组中的方法重写</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">Array</span>.isArray(obj))&#123;</span><br><span class="line">        obj.__proto__ = proto</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">observer(arr);</span><br><span class="line">arr.push(<span class="number">1</span>);</span><br><span class="line"><span class="built_in">console</span>.log(arr);</span><br><span class="line">[].push(<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>)</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>ES6</category>
      </categories>
  </entry>
  <entry>
    <title>ES6-Class 类</title>
    <url>/2019/09/12/ES6-Class/</url>
    <content><![CDATA[<p><strong>__</strong>proto______ 指向所属类的原型  浏览器中 (1).<strong>__</strong>proto________打印下<br>prototype 所有类都有一个prototype属性<br>constructor prototype.constructor 每个类的原型上都有这个属性</p>
<h5 id="继承-继承公共属性-nbsp-nbsp-nbsp-nbsp-继承实例上的属性"><a href="#继承-继承公共属性-nbsp-nbsp-nbsp-nbsp-继承实例上的属性" class="headerlink" title="继承: 继承公共属性 &nbsp;&nbsp;&nbsp;&nbsp;继承实例上的属性"></a>继承: 继承公共属性 &nbsp;&nbsp;&nbsp;&nbsp;继承实例上的属性</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 每个类上都有constructor 放置实例上的属性</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span></span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>()&#123;</span><br><span class="line">        <span class="keyword">this</span>.type = <span class="string">'哺乳类'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> animal = <span class="keyword">new</span> Animal();</span><br><span class="line"><span class="built_in">console</span>.log(animal); <span class="comment">// Animal &#123; type: '哺乳类' &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(animal.hasOwnProperty(<span class="string">'type'</span>));<span class="comment">// true 实例上的属性</span></span><br></pre></td></tr></table></figure>

<a id="more"></a>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span></span>&#123;</span><br><span class="line">    type = <span class="string">'哺乳类'</span>; <span class="comment">// 这个写法本质上和上面是一样的，只是这里node不支持，要运行用浏览器的console执行即可</span></span><br><span class="line">    say()&#123; <span class="comment">// 放到了原型上  相当于之前的 Animal.prototype.say</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"this:"</span>, <span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> animal = <span class="keyword">new</span> Animal();</span><br><span class="line"><span class="keyword">let</span> say = animal.say;</span><br><span class="line">say(); <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 类似于react中</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span></span>&#123;</span><br><span class="line">    type = <span class="string">'哺乳类'</span>; </span><br><span class="line">	<span class="comment">// 这个写法本质上和上面是一样的，只是这里es6不支持，加了.babelrc中的 插件    </span></span><br><span class="line">	<span class="comment">// ["@babel/plugin-proposal-class-properties", &#123; "loose" : true &#125;], 然后再运行webpack环境即可</span></span><br><span class="line">    say()&#123; <span class="comment">// 放到了原型上  相当于之前的 Animal.prototype.say</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"this:"</span>, <span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    render()&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">onClick</span>=<span class="string">&#123;this.say.bind(this)&#125;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 这里line20要加bind</span></span><br><span class="line"><span class="comment">// 所以在上面的情况 line8将原型中的say方法拿出来，在es6中默认this就是undefined</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span></span>&#123;</span><br><span class="line">    type = <span class="string">'哺乳类'</span>;</span><br><span class="line">    say()&#123; <span class="comment">// 放到了原型上  相当于之前的 Animal.prototype.say</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"this:"</span>, <span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> animal = <span class="keyword">new</span> Animal(); <span class="comment">// 如果将类中的方法拿出来用必须绑定this,否则默认指向undefined</span></span><br><span class="line"><span class="keyword">let</span> say = animal.say.bind(animal);</span><br><span class="line">say(); <span class="comment">// this: Animal &#123;type: "哺乳类"&#125;</span></span><br></pre></td></tr></table></figure>

<h5 id="有时候要定义个原型上的属性-Animal-prototype-a-1"><a href="#有时候要定义个原型上的属性-Animal-prototype-a-1" class="headerlink" title="有时候要定义个原型上的属性 Animal.prototype.a = 1;"></a>有时候要定义个原型上的属性 Animal.prototype.a = 1;</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span></span>&#123;</span><br><span class="line">    type = <span class="string">'哺乳类'</span>; <span class="comment">// 实例上的属性</span></span><br><span class="line">    <span class="comment">// a = 1; // 这样是定义到实例上了，所以不能这样写</span></span><br><span class="line">    <span class="keyword">get</span> a()&#123; <span class="comment">// Object.defineProperty</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>; <span class="comment">// 等同于 Animal.prototype.a = 1;</span></span><br><span class="line">    &#125;</span><br><span class="line">    say()&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"this:"</span>, <span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> animal = <span class="keyword">new</span> Animal();</span><br><span class="line"><span class="keyword">let</span> say = animal.say.bind(animal);</span><br><span class="line">say();  <span class="comment">// this: Animal &#123;type: "哺乳类"&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(animal.a); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

<h5 id="静态属性"><a href="#静态属性" class="headerlink" title="静态属性"></a>静态属性</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span></span>&#123;</span><br><span class="line">    type = <span class="string">'哺乳类'</span>; </span><br><span class="line">    <span class="comment">// a = 1;</span></span><br><span class="line">    <span class="keyword">get</span> a()&#123; </span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>; </span><br><span class="line">    &#125;</span><br><span class="line">    say()&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"this:"</span>, <span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 静态属性 定义到类上的属性</span></span><br><span class="line">    <span class="keyword">static</span> flag = <span class="string">'动物'</span>; <span class="comment">// es6中是不支持这样等号赋值的，因为加了插件 </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> animal = <span class="keyword">new</span> Animal();</span><br><span class="line"><span class="built_in">console</span>.log(Animal.flag); <span class="comment">// 动物</span></span><br><span class="line"><span class="built_in">console</span>.log(animal.__proto__.constructor.flag); <span class="comment">// 动物</span></span><br></pre></td></tr></table></figure>

<h5 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span></span>&#123;</span><br><span class="line">    <span class="comment">// type = '哺乳类'; // 这行也不支持</span></span><br><span class="line">    <span class="keyword">get</span> a()&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    say()&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"this:"</span>, <span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 静态方法</span></span><br><span class="line">    <span class="keyword">static</span> flag()&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'动物'</span></span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> animal = <span class="keyword">new</span> Animal();</span><br><span class="line"><span class="built_in">console</span>.log(Animal.flag()); <span class="comment">// 动物</span></span><br><span class="line"><span class="built_in">console</span>.log(animal.__proto__.constructor.flag); <span class="comment">// 动物</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果不想要方法 就想是属性 如下：</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span></span>&#123;</span><br><span class="line">    <span class="comment">// type = '哺乳类';</span></span><br><span class="line">    <span class="keyword">get</span> a()&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    say()&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"this:"</span>, <span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 静态属性</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">get</span> flag()&#123; </span><br><span class="line">        <span class="keyword">return</span> <span class="string">'动物'</span></span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> animal = <span class="keyword">new</span> Animal(); </span><br><span class="line"><span class="built_in">console</span>.log(Animal.flag); <span class="comment">// 动物</span></span><br></pre></td></tr></table></figure>

<h5 id="类之间的继承"><a href="#类之间的继承" class="headerlink" title="类之间的继承"></a>类之间的继承</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 现在我希望Tiger继承Animal中的constructor实例上的属性和原型上的方法（say）</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span></span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>()&#123;</span><br><span class="line">        <span class="keyword">this</span>.type = <span class="string">'哺乳类'</span></span><br><span class="line">    &#125;</span><br><span class="line">    say()&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'说话'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// call + Object.create() + Object.setPrototypeof 下面的继承用了这3个方法</span></span><br><span class="line"><span class="comment">// call（继承实例属性） 在子类中调用父类的构造函数  </span></span><br><span class="line"><span class="comment">// Object.create() 继承公有属性</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tiger</span> <span class="keyword">extends</span> <span class="title">Animal</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> tiger = <span class="keyword">new</span> Tiger();</span><br><span class="line"><span class="built_in">console</span>.log(tiger);</span><br></pre></td></tr></table></figure>

<p>打印结果：<br><img src="https://jiafei2333.github.io/html/images/es6-extends-1.png" alt title="定义对象"></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// __proto__ 指向所属类的原型</span></span><br><span class="line">tiger.__proto__ === Tiger.prototype    <span class="comment">//true</span></span><br><span class="line">Tiger.prototype.__proto__ === Animal.prototype   <span class="comment">//true</span></span><br><span class="line"><span class="comment">// instanceof</span></span><br><span class="line">tiger <span class="keyword">instanceof</span> Tiger|Animal|<span class="built_in">Object</span>   <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>将类之间继承的代码 粘贴 =&gt; 打开babeljs.io =&gt; Try it out =&gt; 将内容复制进去 右边显示的就是转换成的es5代码 =&gt; 复制到新文件test.js中 =&gt; 在把代码格式化下如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// test.js</span></span><br><span class="line"><span class="meta">"use strict"</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_typeof</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">Symbol</span> === <span class="string">"function"</span> &amp;&amp; <span class="keyword">typeof</span> <span class="built_in">Symbol</span>.iterator === <span class="string">"symbol"</span>) &#123;</span><br><span class="line">        _typeof = <span class="function"><span class="keyword">function</span> <span class="title">_typeof</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">typeof</span> obj;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        _typeof = <span class="function"><span class="keyword">function</span> <span class="title">_typeof</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> obj &amp;&amp; <span class="keyword">typeof</span> <span class="built_in">Symbol</span> === <span class="string">"function"</span> &amp;&amp; obj.constructor === <span class="built_in">Symbol</span> &amp;&amp; obj !== <span class="built_in">Symbol</span>.prototype ? <span class="string">"symbol"</span>: <span class="keyword">typeof</span> obj;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> _typeof(obj);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_possibleConstructorReturn</span>(<span class="params">self, call</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (call &amp;&amp; (_typeof(call) === <span class="string">"object"</span> || <span class="keyword">typeof</span> call === <span class="string">"function"</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> call;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> _assertThisInitialized(self);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_assertThisInitialized</span>(<span class="params">self</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (self === <span class="keyword">void</span> <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">ReferenceError</span>(<span class="string">"this hasn't been initialised - super() hasn't been called"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> self;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_getPrototypeOf</span>(<span class="params">o</span>) </span>&#123;</span><br><span class="line">    _getPrototypeOf = <span class="built_in">Object</span>.setPrototypeOf ? <span class="built_in">Object</span>.getPrototypeOf: <span class="function"><span class="keyword">function</span> <span class="title">_getPrototypeOf</span>(<span class="params">o</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> o.__proto__ || <span class="built_in">Object</span>.getPrototypeOf(o);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> _getPrototypeOf(o);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_inherits</span>(<span class="params">subClass, superClass</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> superClass !== <span class="string">"function"</span> &amp;&amp; superClass !== <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">"Super expression must either be null or a function"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    subClass.prototype = <span class="built_in">Object</span>.create(superClass &amp;&amp; superClass.prototype, &#123;</span><br><span class="line">        <span class="keyword">constructor</span>: &#123;</span><br><span class="line">            value: subClass,</span><br><span class="line">            writable: <span class="literal">true</span>,</span><br><span class="line">            configurable: <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);  <span class="comment">//Tiger.__proto__ = Animal</span></span><br><span class="line">    <span class="keyword">if</span> (superClass) _setPrototypeOf(subClass, superClass);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_setPrototypeOf</span>(<span class="params">o, p</span>) </span>&#123;</span><br><span class="line">    _setPrototypeOf = <span class="built_in">Object</span>.setPrototypeOf ||</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">_setPrototypeOf</span>(<span class="params">o, p</span>) </span>&#123;</span><br><span class="line">        o.__proto__ = p;</span><br><span class="line">        <span class="keyword">return</span> o;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> _setPrototypeOf(o, p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_instanceof</span>(<span class="params">left, right</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (right != <span class="literal">null</span> &amp;&amp; <span class="keyword">typeof</span> <span class="built_in">Symbol</span> !== <span class="string">"undefined"</span> &amp;&amp; right[<span class="built_in">Symbol</span>.hasInstance]) &#123;</span><br><span class="line">        <span class="keyword">return</span> !! right[<span class="built_in">Symbol</span>.hasInstance](left);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> left <span class="keyword">instanceof</span> right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_classCallCheck</span>(<span class="params">instance, Constructor</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!_instanceof(instance, Constructor)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">"Cannot call a class as a function"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_defineProperties</span>(<span class="params">target, props</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; props.length; i++) &#123;</span><br><span class="line">        <span class="keyword">var</span> descriptor = props[i];</span><br><span class="line">        descriptor.enumerable = descriptor.enumerable || <span class="literal">false</span>;</span><br><span class="line">        descriptor.configurable = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">"value"</span> <span class="keyword">in</span> descriptor) descriptor.writable = <span class="literal">true</span>;</span><br><span class="line">        <span class="built_in">Object</span>.defineProperty(target, descriptor.key, descriptor);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_createClass</span>(<span class="params">Constructor, protoProps, staticProps</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (protoProps) _defineProperties(Constructor.prototype, protoProps);</span><br><span class="line">    <span class="keyword">if</span> (staticProps) _defineProperties(Constructor, staticProps);</span><br><span class="line">    <span class="keyword">return</span> Constructor;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> Animal =</span><br><span class="line"><span class="comment">/*#__PURE__*/</span></span><br><span class="line"><span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">Animal</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        _classCallCheck(<span class="keyword">this</span>, Animal);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.type = <span class="string">'哺乳类'</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    _createClass(Animal, [&#123; <span class="comment">// 创建类</span></span><br><span class="line">        key: <span class="string">"say"</span>,</span><br><span class="line">        value: <span class="function"><span class="keyword">function</span> <span class="title">say</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'说话'</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Animal;</span><br><span class="line">&#125; (); </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> Tiger =</span><br><span class="line"><span class="comment">/*#__PURE__*/</span></span><br><span class="line"><span class="function"><span class="keyword">function</span>(<span class="params">_Animal</span>) </span>&#123;</span><br><span class="line">    _inherits(Tiger, _Animal); <span class="comment">// 实现了子类继承父类原型上的方法</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">Tiger</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        _classCallCheck(<span class="keyword">this</span>, Tiger); <span class="comment">// 判断是否是 Tiger()这样调用的</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> _possibleConstructorReturn(<span class="keyword">this</span>, </span><br><span class="line">            <span class="comment">// Object.getPrototypeOf</span></span><br><span class="line">            <span class="comment">// Tiger.__proto__ = Animal   Animal.apply(tiger)</span></span><br><span class="line">            _getPrototypeOf(Tiger).apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Tiger;</span><br><span class="line">&#125; (Animal);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> tiger = <span class="keyword">new</span> Tiger();</span><br><span class="line"><span class="built_in">console</span>.log(tiger);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 大致看下</span></span><br><span class="line"><span class="comment">// line38_inherits 继承  line42 子类继承父类 子类的prototype 、 Object.create</span></span><br><span class="line"><span class="comment">// 现在来看下子类的Tiger line114-127    看下line115   line118有个_classCallCheck</span></span><br></pre></td></tr></table></figure>

<p>刚才看了内部实现 这里面 Tiger.<strong>__</strong>proto__ = Animal<br>静态方法、属性在es6中也会被子类继承</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span></span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>()&#123;</span><br><span class="line">        <span class="keyword">this</span>.type = <span class="string">'哺乳类'</span></span><br><span class="line">    &#125;</span><br><span class="line">    say()&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'说话'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> flag = <span class="number">1</span>;</span><br><span class="line">&#125;   </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tiger</span> <span class="keyword">extends</span> <span class="title">Animal</span></span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>()&#123;</span><br><span class="line">        <span class="keyword">super</span>(); <span class="comment">// 调用super 相当于 Animal.call(tiger)</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> tiger = <span class="keyword">new</span> Tiger();</span><br></pre></td></tr></table></figure>

<p>当new的时候传参</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 当new的时候传参</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span></span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(name)&#123; <span class="comment">// #4</span></span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.type = <span class="string">'哺乳类'</span></span><br><span class="line">    &#125;</span><br><span class="line">    say()&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'说话'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> flag = <span class="number">1</span>;</span><br><span class="line">&#125;   </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tiger</span> <span class="keyword">extends</span> <span class="title">Animal</span></span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(name)&#123; <span class="comment">// #1</span></span><br><span class="line">        <span class="keyword">super</span>(name); <span class="comment">//#2    调用super 相当于 Animal.call(tiger, name) #3</span></span><br><span class="line">        <span class="comment">//这里super指的是父类Animal</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> getAnimal()&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">super</span>.flag); <span class="comment">// super指的是父类</span></span><br><span class="line">    &#125;</span><br><span class="line">    say()&#123; <span class="comment">// 自己也有一个say方法</span></span><br><span class="line">        <span class="keyword">super</span>.say(); <span class="comment">// super 指的是 父类的原型</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> tiger = <span class="keyword">new</span> Tiger(<span class="string">'老虎'</span>);</span><br><span class="line">Tiger.getAnimal(); <span class="comment">// 1</span></span><br><span class="line">tiger.say(); <span class="comment">// 说话</span></span><br><span class="line"><span class="comment">//  static get / set super extends</span></span><br><span class="line"><span class="comment">// es6类怎么实现继承的？</span></span><br><span class="line"><span class="comment">// 这里可以再看下 test.js  _defineProperties   _createClass</span></span><br><span class="line"><span class="comment">// call + Object.create() 实现的继承</span></span><br><span class="line"><span class="comment">// Object.setPrototypeof 链的关联</span></span><br><span class="line"><span class="comment">// 通过Object.defineProperty 实现原型+静态属性 方法的定义</span></span><br></pre></td></tr></table></figure>

<h5 id="new的原理-未完待续"><a href="#new的原理-未完待续" class="headerlink" title="new的原理  未完待续"></a>new的原理  未完待续</h5>]]></content>
      <categories>
        <category>ES6</category>
      </categories>
  </entry>
  <entry>
    <title>模板引擎</title>
    <url>/2019/09/12/Template/</url>
    <content><![CDATA[<h4 id="如何实现一个模板引擎？"><a href="#如何实现一个模板引擎？" class="headerlink" title="如何实现一个模板引擎？"></a>如何实现一个模板引擎？</h4><p>常见模板引擎 ejs jade handlerbar underscore  nunjunks </p>
<a id="more"></a>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 模板 template.html</span></span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;meta charset=<span class="string">"utf-8"</span>&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">	&lt;title&gt;模板&lt;<span class="regexp">/title&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;%=name%&gt;</span><br><span class="line">    &lt;%=age%&gt;</span><br><span class="line">&lt;<span class="regexp">/body&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>html&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// yarn add ejs</span></span><br><span class="line"><span class="keyword">let</span> ejs = <span class="built_in">require</span>(<span class="string">'ejs'</span>);</span><br><span class="line"><span class="keyword">let</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="comment">// fs.readFile异步   fs.readFileSync同步</span></span><br><span class="line"><span class="keyword">let</span> template = fs.readFileSync(__dirname+<span class="string">'/template.html'</span>, <span class="string">'utf8'</span>);</span><br><span class="line"><span class="keyword">let</span> r = ejs.render(template, &#123;<span class="attr">name</span>: <span class="string">'jiafei'</span>, <span class="attr">age</span>: <span class="number">18</span>&#125;); <span class="comment">// 给模板提供一个name 返回的是渲染后的字符串</span></span><br><span class="line"><span class="built_in">console</span>.log(r);</span><br><span class="line"><span class="comment">/*****</span></span><br><span class="line"><span class="comment">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="comment">&lt;html&gt;</span></span><br><span class="line"><span class="comment">&lt;meta charset="utf-8"&gt;</span></span><br><span class="line"><span class="comment">&lt;head&gt;</span></span><br><span class="line"><span class="comment">	&lt;title&gt;模板&lt;/title&gt;</span></span><br><span class="line"><span class="comment">&lt;/head&gt;</span></span><br><span class="line"><span class="comment">&lt;body&gt;</span></span><br><span class="line"><span class="comment">    jiafei</span></span><br><span class="line"><span class="comment">    18</span></span><br><span class="line"><span class="comment">&lt;/body&gt;</span></span><br><span class="line"><span class="comment">&lt;/html&gt;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>自己实现一个模板引擎</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 模板 template.html</span></span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=<span class="string">"en"</span>&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=<span class="string">"UTF-8"</span>&gt;</span><br><span class="line">    &lt;meta name=<span class="string">"viewport"</span> content=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span><br><span class="line">    &lt;meta http-equiv=<span class="string">"X-UA-Compatible"</span> content=<span class="string">"ie=edge"</span>&gt;</span><br><span class="line">    &lt;title&gt;Document&lt;<span class="regexp">/title&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &#123;%<span class="keyword">if</span>(<span class="literal">false</span>)&#123;%&#125; </span><br><span class="line">        hello</span><br><span class="line">    &#123;%&#125;<span class="keyword">else</span>&#123;%&#125;</span><br><span class="line">        world</span><br><span class="line">    &#123;%&#125;%&#125;</span><br><span class="line">    &#123;%arr.forEach(<span class="function"><span class="params">item</span>=&gt;</span>&#123;%&#125;</span><br><span class="line">        &lt;li&gt;&#123;&#123;item&#125;&#125;&lt;<span class="regexp">/li&gt;</span></span><br><span class="line"><span class="regexp">    &#123;%&#125;)%&#125;</span></span><br><span class="line"><span class="regexp">&lt;/</span>body&gt;</span><br><span class="line">&lt;<span class="regexp">/html&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> fs = <span class="built_in">require</span>(<span class="string">"fs"</span>);</span><br><span class="line"><span class="keyword">let</span> template = fs.readFileSync(__dirname+<span class="string">"/template.html"</span>, <span class="string">"utf8"</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">render</span>(<span class="params">templateStr, obj</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// &#123;&#123;name&#125;&#125;</span></span><br><span class="line">  <span class="keyword">let</span> head = <span class="string">'let str = "";\r\n'</span>;</span><br><span class="line">  head += <span class="string">"with(xxx)&#123;\r\n"</span>;</span><br><span class="line">  <span class="keyword">let</span> content = <span class="string">"str += `"</span>;  <span class="comment">// 取值</span></span><br><span class="line">  templateStr = templateStr.replace(<span class="regexp">/\&#123;\&#123;(.+?)\&#125;\&#125;/g</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"$&#123;"</span> + <span class="built_in">arguments</span>[<span class="number">1</span>] + <span class="string">"&#125;"</span>;</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="comment">// 解析语法</span></span><br><span class="line">  content += templateStr.replace(<span class="regexp">/\&#123;\%(.+?)\%\&#125;/g</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"`\r\n"</span> + <span class="built_in">arguments</span>[<span class="number">1</span>] + <span class="string">"\r\nstr+=`"</span>;</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">let</span> tail = <span class="string">"`\r\n&#125;\r\n return str;"</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"Str:"</span>,  head + content + tail);</span><br><span class="line">  <span class="comment">// 产生函数</span></span><br><span class="line">  <span class="keyword">let</span> fn = <span class="keyword">new</span> <span class="built_in">Function</span>(<span class="string">"xxx"</span>, head + content + tail);</span><br><span class="line">  <span class="keyword">return</span> fn(obj);</span><br><span class="line">  <span class="comment">// return templateStr.replace(/\&#123;\&#123;(.+?)\&#125;\&#125;/g,function()&#123;</span></span><br><span class="line">  <span class="comment">//     return obj[arguments[1]]</span></span><br><span class="line">  <span class="comment">// &#125;);</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 模板引擎的实现原理是: 1) with语法 2） new Function</span></span><br><span class="line"><span class="keyword">let</span> r = render(template, &#123; <span class="attr">arr</span>: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>] &#125;);</span><br><span class="line"><span class="built_in">console</span>.log(r);</span><br><span class="line"></span><br><span class="line"><span class="comment">/********</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="comment">&lt;html lang="en"&gt;</span></span><br><span class="line"><span class="comment">&lt;head&gt;</span></span><br><span class="line"><span class="comment">    &lt;meta charset="UTF-8"&gt;</span></span><br><span class="line"><span class="comment">    &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt;</span></span><br><span class="line"><span class="comment">    &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt;</span></span><br><span class="line"><span class="comment">    &lt;title&gt;Document&lt;/title&gt;</span></span><br><span class="line"><span class="comment">&lt;/head&gt;</span></span><br><span class="line"><span class="comment">&lt;body&gt;</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">        world</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">        &lt;li&gt;1&lt;/li&gt;</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">        &lt;li&gt;2&lt;/li&gt;</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">        &lt;li&gt;3&lt;/li&gt;</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">&lt;/body&gt;</span></span><br><span class="line"><span class="comment">&lt;/html&gt;</span></span><br><span class="line"><span class="comment">***/</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>Tips 模板引擎实现原理 （最简单的正则替换）  </p>
</blockquote>
<ul>
<li>1) with语法 </li>
<li>2） new Function 将字符串转化成函数 </li>
<li>3） 字符串拼接</li>
</ul>
]]></content>
      <categories>
        <category>其他</category>
      </categories>
  </entry>
  <entry>
    <title>箭头函数 & reduce & compose</title>
    <url>/2019/09/11/Arrow-Funtion/</url>
    <content><![CDATA[<h4 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h4><blockquote>
<p>特点：没有this arguments prototype ，没有就向上找</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// node中没有window 代码在浏览器中执行 </span></span><br><span class="line"><span class="keyword">let</span> fn = <span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="comment">// console.log(arguments); </span></span><br><span class="line">	<span class="comment">// 报错：VM364:2 Uncaught ReferenceError: arguments is not defined</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>); <span class="comment">// window</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// console.log(fn(1,2,3));</span></span><br></pre></td></tr></table></figure>

<a id="more"></a>
<p>面试题：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1.</span></span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    a: <span class="number">1</span>,</span><br><span class="line">    fn()&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">obj.fn(); </span><br><span class="line"><span class="comment">// 执行结果： 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.</span></span><br><span class="line"><span class="keyword">let</span> a = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    a: <span class="number">1</span>,</span><br><span class="line">    fn()&#123; <span class="comment">// this =&gt; obj</span></span><br><span class="line">        setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="comment">// this =&gt; window    其实是window.setTimeout</span></span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">"a:"</span>, <span class="keyword">this</span>.a);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">obj.fn();</span><br><span class="line"><span class="comment">// 执行结果： undefined</span></span><br><span class="line"><span class="comment">// line12 let声明的变量不会放到全局上 所以windowh上没有a 取不到</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//  3. 将setTimeout中变成箭头函数</span></span><br><span class="line"><span class="keyword">let</span> a = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    a: <span class="number">1</span>,</span><br><span class="line">    fn()&#123; <span class="comment">// this =&gt; obj</span></span><br><span class="line">        setTimeout(<span class="function"><span class="params">()</span>=&gt;</span> &#123; <span class="comment">// 这里就没有this了，往上找 找到line29 从而解决this问题</span></span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">"a:"</span>, <span class="keyword">this</span>.a);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">obj.fn(); </span><br><span class="line"><span class="comment">// 执行结果： 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. 将fn变成箭头函数</span></span><br><span class="line"><span class="keyword">let</span> a = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    a: <span class="number">1</span>,</span><br><span class="line">    fn: <span class="function"><span class="params">()</span>=&gt;</span>&#123; <span class="comment">// 这里就没有this了，往上找 </span></span><br><span class="line">        setTimeout(<span class="function"><span class="params">()</span>=&gt;</span> &#123; <span class="comment">// 这里就没有this了，往上找 </span></span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">"a:"</span>, <span class="keyword">this</span>.a);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">obj.fn();</span><br><span class="line"><span class="comment">// 执行结果： undefined</span></span><br></pre></td></tr></table></figure>

<p>不能再扩展原型</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> fn = <span class="function"><span class="params">()</span>=&gt;</span>&#123;&#125;</span><br><span class="line"><span class="built_in">console</span>.log(fn.prototype); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>

<h4 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h4><p>forEach filter map find findIndex some every reduce</p>
<h5 id="some-amp-every"><a href="#some-amp-every" class="headerlink" title="some &amp; every"></a>some &amp; every</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//some() 方法测试数组中是不是有元素通过了被提供的函数测试。它返回的是一个Boolean类型的值。</span></span><br><span class="line"><span class="keyword">var</span> array = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">var</span> even = <span class="function"><span class="keyword">function</span>(<span class="params">element</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(element)</span><br><span class="line">  <span class="keyword">return</span> element % <span class="number">2</span> === <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(array.some(even));</span><br><span class="line"><span class="comment">// 1 2 true 有一个通过就停止循环</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// every() 方法测试一个数组内的所有元素是否都能通过某个指定函数的测试。它返回一个布尔值。</span></span><br><span class="line"><span class="keyword">var</span> array = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">var</span> even = <span class="function"><span class="keyword">function</span>(<span class="params">element</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(element)</span><br><span class="line">  <span class="keyword">return</span> element % <span class="number">2</span> === <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(array.some(even));</span><br><span class="line"><span class="comment">// 1 false  有一个false就停止</span></span><br></pre></td></tr></table></figure>

<h5 id="reduce"><a href="#reduce" class="headerlink" title="reduce"></a>reduce</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>].reduce(<span class="function">(<span class="params">pre, curr, index, arr</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(pre, curr, index, arr)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 执行结果：</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">1</span> [ <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> ]</span><br><span class="line"><span class="literal">undefined</span> <span class="number">3</span> <span class="number">2</span> [ <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> ]</span><br><span class="line"><span class="literal">undefined</span> <span class="number">4</span> <span class="number">3</span> [ <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> ]</span><br><span class="line"><span class="literal">undefined</span> <span class="number">5</span> <span class="number">4</span> [ <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> ]</span><br><span class="line"><span class="comment">// 这里pre为undefined 是因为pre又可写为acc，代表上一次调用回调时返回的累积值，这里line2没有做累计</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> total = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>].reduce(<span class="function">(<span class="params">pre, curr, index, arr</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(pre, curr, index, arr)</span><br><span class="line">    <span class="keyword">return</span> pre + curr;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(total);</span><br><span class="line"><span class="comment">// 执行结果:</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">1</span> [ <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> ]</span><br><span class="line"><span class="number">3</span> <span class="number">3</span> <span class="number">2</span> [ <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> ]</span><br><span class="line"><span class="number">6</span> <span class="number">4</span> <span class="number">3</span> [ <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> ]</span><br><span class="line"><span class="number">10</span> <span class="number">5</span> <span class="number">4</span> [ <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> ]</span><br><span class="line"><span class="number">15</span></span><br><span class="line"></span><br><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>].reduce(<span class="function">(<span class="params">pre, curr, index, arr</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(pre, curr, index, arr)</span><br><span class="line">&#125;,<span class="number">100</span>)</span><br><span class="line"><span class="comment">// 执行结果：</span></span><br><span class="line"><span class="number">100</span> <span class="number">1</span> <span class="number">0</span> [ <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> ]</span><br><span class="line"><span class="literal">undefined</span> <span class="number">2</span> <span class="number">1</span> [ <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> ]</span><br><span class="line"><span class="literal">undefined</span> <span class="number">3</span> <span class="number">2</span> [ <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> ]</span><br><span class="line"><span class="literal">undefined</span> <span class="number">4</span> <span class="number">3</span> [ <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> ]</span><br><span class="line"><span class="literal">undefined</span> <span class="number">5</span> <span class="number">4</span> [ <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> ]</span><br></pre></td></tr></table></figure>

<p> 示例 收敛<br> <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">let</span> total = [&#123;<span class="attr">price</span>: <span class="number">1</span>, <span class="attr">count</span>: <span class="number">5</span>&#125;, &#123;<span class="attr">price</span>: <span class="number">2</span>, <span class="attr">count</span>: <span class="number">5</span>&#125;, &#123;<span class="attr">price</span>: <span class="number">3</span>, <span class="attr">count</span>: <span class="number">6</span>&#125;].reduce( <span class="function">(<span class="params">acc, curr, index, arr</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> acc + curr.price * curr.count;</span><br><span class="line">&#125;, <span class="number">0</span>); <span class="comment">// 这里这个0就代表初始值 即第一项</span></span><br><span class="line"><span class="built_in">console</span>.log(total); <span class="comment">// 33</span></span><br></pre></td></tr></table></figure></p>
<p>示例 数组扁平化</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>,[<span class="number">2</span>,[<span class="number">3</span>,[<span class="number">4</span>,[<span class="number">5</span>]]]]];</span><br><span class="line"><span class="built_in">console</span>.log(arr.toString(), <span class="keyword">typeof</span> arr.toString()); <span class="comment">// 这样的方式不行 数据类型string</span></span><br><span class="line"><span class="comment">// 1,2,3,4,5 string</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// flat</span></span><br><span class="line"><span class="built_in">console</span>.log( [<span class="number">1</span>,[<span class="number">2</span>,[<span class="number">3</span>,[<span class="number">4</span>,[<span class="number">5</span>]]]]].flat(<span class="number">10</span>)); <span class="comment">// 10指嵌套10项都打开</span></span><br><span class="line"><span class="comment">// [1, 2, 3, 4, 5]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 用reduce写一下</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(<span class="built_in">Array</span>.prototype, <span class="string">'flat'</span>, &#123;</span><br><span class="line">    value: <span class="function"><span class="keyword">function</span>(<span class="params">depth = <span class="number">1</span></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.reduce(<span class="function"><span class="keyword">function</span> (<span class="params">flat, toFlatten</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> flat.concat((<span class="built_in">Array</span>.isArray(toFlatten) &amp;&amp; (depth&gt;<span class="number">1</span>)) ? toFlatten.flat(depth<span class="number">-1</span>) : toFlatten);</span><br><span class="line">      &#125;, []);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(</span><br><span class="line">  [<span class="number">1</span>, [<span class="number">2</span>], [<span class="number">3</span>, [[<span class="number">4</span>]]]].flat(<span class="number">2</span>)</span><br><span class="line">);</span><br><span class="line"><span class="comment">// [ 1, 2, 3, [ 4 ] ]</span></span><br></pre></td></tr></table></figure>

<p><a href="https://stackoverflow.com/questions/50993498/flat-is-not-a-function-whats-wrong" target="_blank" rel="noopener">https://stackoverflow.com/questions/50993498/flat-is-not-a-function-whats-wrong</a></p>
<p>示例 函数的组合 compose (redux源码)</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">a,b</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">len</span>(<span class="params">str</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> str.length;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addCurrency</span>(<span class="params">val</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'$'</span> + val;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 现在想把这3个函数组合起来</span></span><br><span class="line"><span class="keyword">let</span> r = addCurrency(len(sum(<span class="string">'abc'</span>, <span class="string">'bed'</span>)));</span><br><span class="line"><span class="built_in">console</span>.log(r); <span class="comment">// $6</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 自己写下compose</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">a,b</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">len</span>(<span class="params">str</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> str.length;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addCurrency</span>(<span class="params">val</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'$'</span> + val;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">compose</span>(<span class="params">...args</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">...values</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">let</span> fn = args.pop(); <span class="comment">// 取到最后一个方法 即sum</span></span><br><span class="line">        <span class="keyword">return</span> args.reduceRight( <span class="function">(<span class="params">prev, curr</span>) =&gt;</span> &#123; <span class="comment">// reduceRight反向</span></span><br><span class="line">            <span class="keyword">return</span> curr(prev); <span class="comment">// 把上一次计算的结果再传递给下一个函数</span></span><br><span class="line">			<span class="comment">// 注意：这里不能return curr(prev(...values));这样写</span></span><br><span class="line">        &#125;,fn(...values));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 优化成箭头函数</span></span><br><span class="line"><span class="keyword">const</span> compose = <span class="function">(<span class="params">...args</span>) =&gt;</span> <span class="function">(<span class="params">...values</span>) =&gt;</span> &#123;</span><br><span class="line">	<span class="keyword">let</span> fn = args.pop(); </span><br><span class="line">	<span class="keyword">return</span> args.reduceRight( <span class="function">(<span class="params">prev, curr</span>) =&gt;</span> curr(prev) ,fn(...values));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> r = compose(addCurrency, len, sum)(<span class="string">'abc'</span>, <span class="string">'bed'</span>);</span><br><span class="line"><span class="comment">// 这个compose是个高阶函数 compose(addCurrency, len, sum)返回一个函数</span></span><br><span class="line"><span class="comment">// 这里的执行顺序是('abc', 'bed')里面的值先传给sum, sum('abc', 'bed')的值再传给len....</span></span><br></pre></td></tr></table></figure>

<p>上面的写法是因为知道有reduceRight 可以反向 现在正向来写</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">a,b</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">len</span>(<span class="params">str</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> str.length;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addCurrency</span>(<span class="params">val</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'$'</span> + val;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">compose</span>(<span class="params">...args</span>)</span>&#123; <span class="comment">// len, sum</span></span><br><span class="line">    <span class="keyword">return</span> args.reduce( <span class="function">(<span class="params">prev, curr</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">...values</span>)</span>&#123; <span class="comment">// 'abc', 'bed'</span></span><br><span class="line">            <span class="keyword">return</span> prev(curr(...values));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// es6箭头函数优化</span></span><br><span class="line"><span class="keyword">const</span> compose = <span class="function">(<span class="params">...args</span>) =&gt;</span> args.reduce( <span class="function">(<span class="params">prev, curr</span>) =&gt;</span> <span class="function">(<span class="params">...values</span>) =&gt;</span> prev(curr(...values)));</span><br><span class="line"><span class="comment">// redux中compose的源码  github redux =&gt; src =&gt; compose.ts =&gt; 最下面</span></span><br><span class="line"><span class="comment">// return funcs.reduce((a, b) =&gt; (...args: any) =&gt; a(b(...args)))</span></span><br><span class="line"><span class="keyword">let</span> r = compose(addCurrency,len, sum)(<span class="string">'abc'</span>, <span class="string">'bed'</span>); </span><br><span class="line"><span class="built_in">console</span>.log(r);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>compose 组合多个函数 这个是redux compose的原理</p>
</blockquote>
<hr>
<h4 id="作业"><a href="#作业" class="headerlink" title="作业"></a>作业</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>反柯里化</span><br><span class="line"><span class="number">2.</span>flat （reduce）</span><br><span class="line"><span class="number">3.</span><span class="built_in">Array</span>.prototype.reduce  实现reduce原理</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>ES6</category>
      </categories>
  </entry>
  <entry>
    <title>常见的数据结构</title>
    <url>/2019/09/11/Data-Structure/</url>
    <content><![CDATA[<p>队列 栈 链表 集合 hash表 树 图</p>
<h5 id="1-队列-先进先出-（排队）"><a href="#1-队列-先进先出-（排队）" class="headerlink" title="1) 队列 先进先出 （排队）"></a>1) 队列 先进先出 （排队）</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Queue</span></span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>()&#123;</span><br><span class="line">        <span class="keyword">this</span>.queue = [];</span><br><span class="line">    &#125;</span><br><span class="line">    enqueue(element)&#123;</span><br><span class="line">        <span class="keyword">this</span>.queue.push(element);</span><br><span class="line">    &#125;</span><br><span class="line">    dequeue()&#123;</span><br><span class="line">        <span class="keyword">this</span>.queue.shift();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> queue = <span class="keyword">new</span> Queue();</span><br><span class="line">queue.enqueue(<span class="number">1</span>);</span><br><span class="line">queue.enqueue(<span class="number">2</span>);</span><br><span class="line">queue.dequeue();</span><br><span class="line"><span class="built_in">console</span>.log(queue.queue); <span class="comment">// [ 2 ]</span></span><br></pre></td></tr></table></figure>

<a id="more"></a>
<h5 id="2）栈-先进后出-（喝水）"><a href="#2）栈-先进后出-（喝水）" class="headerlink" title="2）栈 先进后出 （喝水）"></a>2）栈 先进后出 （喝水）</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stack</span></span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>()&#123;</span><br><span class="line">        <span class="keyword">this</span>.stack = [];</span><br><span class="line">    &#125;</span><br><span class="line">    put(element)&#123;</span><br><span class="line">        <span class="keyword">this</span>.stack.push(element);</span><br><span class="line">    &#125;</span><br><span class="line">    pop()&#123;</span><br><span class="line">        <span class="keyword">this</span>.stack.pop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> stack = <span class="keyword">new</span> Stack();</span><br><span class="line">stack.put(<span class="number">1</span>);</span><br><span class="line">stack.put(<span class="number">2</span>);</span><br><span class="line">stack.pop();</span><br><span class="line"><span class="built_in">console</span>.log(stack.stack); <span class="comment">// [ 1 ]</span></span><br></pre></td></tr></table></figure>

<h5 id="3-链表-单项链表-双向链表-循环链表"><a href="#3-链表-单项链表-双向链表-循环链表" class="headerlink" title="3) 链表 ( 单项链表 双向链表 循环链表)"></a>3) 链表 ( 单项链表 双向链表 循环链表)</h5><p>操作数据不需要破坏数据的原有结构<br>现在实现单向链表</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 描述：整个链表是一个类 每个节点也是一个类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123; <span class="comment">// 代表链表中的某一个节点</span></span><br><span class="line">    <span class="keyword">constructor</span>(element)&#123;</span><br><span class="line">        <span class="keyword">this</span>.value = element;</span><br><span class="line">        <span class="keyword">this</span>.next = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LinkList</span></span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>()&#123;</span><br><span class="line">        <span class="keyword">this</span>.head = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">this</span>.length = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    insert(position, element)&#123;</span><br><span class="line">        <span class="keyword">let</span> node = <span class="keyword">new</span> Node(element);</span><br><span class="line">        <span class="keyword">if</span>(!<span class="keyword">this</span>.head)&#123;</span><br><span class="line">            <span class="keyword">this</span>.head = node;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">let</span> index = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">let</span> current = <span class="keyword">this</span>.head;</span><br><span class="line">            <span class="keyword">let</span> prev = <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">while</span> (index++ &lt; position) &#123;</span><br><span class="line">                prev = current;</span><br><span class="line">                current = current.next;</span><br><span class="line">            &#125;</span><br><span class="line">            prev.next = node;</span><br><span class="line">            node.next = current;</span><br><span class="line">        &#125;</span><br><span class="line">        this.length ++;</span><br><span class="line">    &#125;</span><br><span class="line">    append(element)&#123;</span><br><span class="line">        let node = new Node(element);</span><br><span class="line">        if(!this.head)&#123;</span><br><span class="line">            this.head = node;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            // 这里 为了找到链的最后一个 让它的next指向当前node</span><br><span class="line">            let index = 0; // 从0项开始查找</span><br><span class="line">            let current = this.head; // 先把链表的头拿出来 开始查找</span><br><span class="line">            while (++index &lt; this.length) &#123;</span><br><span class="line">                current = current.next; // 如果当前不是最后一项就把这个人的下一项继续查找</span><br><span class="line">            &#125;</span><br><span class="line">            current.next = node;</span><br><span class="line">        &#125;</span><br><span class="line">        this.length ++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">let ll = new LinkList();</span><br><span class="line">console.log("----1----");</span><br><span class="line">ll.append(1); //这里这个append是自定义的方法，表示向链表中加入节点</span><br><span class="line">console.log(JSON.stringify(ll))</span><br><span class="line">console.log("----2----");</span><br><span class="line">ll.append(2);</span><br><span class="line">console.log(JSON.stringify(ll))</span><br><span class="line">console.log("----3----");</span><br><span class="line">ll.append(3);</span><br><span class="line">console.log(JSON.stringify(ll))</span><br><span class="line">/*</span><br><span class="line">执行结果：</span><br><span class="line">----1----</span><br><span class="line">&#123;"head":&#123;"value":1,"next":null&#125;,"length":1&#125;</span><br><span class="line">----2----</span><br><span class="line">&#123;"head":&#123;"value":1,"next":&#123;"value":2,"next":null&#125;&#125;,"length":2&#125;</span><br><span class="line">----3----</span><br><span class="line">&#123;"head":&#123;"value":1,"next":&#123;"value":2,"next":&#123;"value":3,"next":null&#125;&#125;&#125;,"length":3&#125;</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">let ll = new LinkList();</span><br><span class="line">ll.append(1); //这里这个append是自定义的方法，表示向链表中加入节点</span><br><span class="line">ll.append(2);</span><br><span class="line">ll.append(3);</span><br><span class="line">ll.insert(1,100); // 往1和2之间插</span><br><span class="line">console.log(JSON.stringify(ll));</span><br><span class="line">// 执行结果：</span><br><span class="line">// &#123;"head":&#123;"value":1,"next":&#123;"value":100,"next":&#123;"value":2,"next":&#123;"value":3,"next":null&#125;&#125;&#125;&#125;,"length":4&#125;</span><br></pre></td></tr></table></figure>

<p>Array是一块顺序的内存，增加值的时候内存要移动，链表的话不用改变原本的数据位置</p>
<h5 id="4）-集合-放置不能重复的项"><a href="#4）-集合-放置不能重复的项" class="headerlink" title="4） 集合 放置不能重复的项"></a>4） 集合 放置不能重复的项</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">set</span> = new Set();</span><br><span class="line"><span class="keyword">set</span>.add(1);</span><br><span class="line"><span class="keyword">set</span>.add(2);</span><br><span class="line"><span class="keyword">set</span>.add(3);</span><br><span class="line">console.log(<span class="keyword">set</span>); // Set &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;</span><br><span class="line"><span class="comment">// Set的特点是key value 相同</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Set</span></span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>()&#123;</span><br><span class="line">        <span class="keyword">this</span>.set = &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    add(element)&#123;</span><br><span class="line">        <span class="keyword">if</span>( !<span class="keyword">this</span>.set.hasOwnProperty(element))&#123; <span class="comment">// 不能重复</span></span><br><span class="line">            <span class="keyword">this</span>.set[element] = element;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> <span class="keyword">set</span> = new Set();</span><br><span class="line"><span class="keyword">set</span>.add(1);</span><br><span class="line"><span class="keyword">set</span>.add(1);</span><br><span class="line"><span class="keyword">set</span>.add(2);</span><br><span class="line">console.log(<span class="keyword">set</span>); // Set &#123; <span class="keyword">set</span>: &#123; <span class="string">'1'</span>: <span class="number">1</span>, <span class="string">'2'</span>: <span class="number">2</span> &#125; &#125;</span><br><span class="line"><span class="comment">// 感觉还是跟原来的不太一样 es6里面的set、map看一下</span></span><br></pre></td></tr></table></figure>

<h5 id="5-Map-hash表-图"><a href="#5-Map-hash表-图" class="headerlink" title="5) Map hash表 图"></a>5) Map hash表 图</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">map.set(<span class="string">'abc'</span>, <span class="number">123</span>);</span><br><span class="line">map.set(<span class="string">'bbb'</span>, <span class="number">456</span>);</span><br><span class="line"><span class="comment">// 这里组成的是一张表，abc对应的是123.bbb对应的是456</span></span><br><span class="line"><span class="built_in">console</span>.log(map.get(<span class="string">'abc'</span>)); <span class="comment">// 123</span></span><br><span class="line"><span class="built_in">console</span>.log(map.size); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<p>取的时候通过map.get(‘abc’)可以马上拿到123<br>特点：性能高，而且它不是索引，可以放字符串，数组的话只能放索引，而且它取值的时候可以通过key直接取出来 ，模拟hash如下：<br><img src="https://jiafei2333.github.io/html/images/set-hash.png" alt title="hash"></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Map</span></span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>()&#123;</span><br><span class="line">        <span class="keyword">this</span>.arr = [];</span><br><span class="line">    &#125;</span><br><span class="line">    calc(key)&#123;</span><br><span class="line">        <span class="keyword">let</span> total = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; key.length; i++)&#123;</span><br><span class="line">            total += key[i].charCodeAt();<span class="comment">//ASCII</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> total % <span class="number">100</span>;</span><br><span class="line">        <span class="comment">// % 代表如果这个表我最多能存100个（0-99项），想要存10个就%10</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">set</span>(key, value)&#123;</span><br><span class="line">        key = <span class="keyword">this</span>.calc(key);</span><br><span class="line">        <span class="keyword">this</span>.arr[key] = value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">get</span>(key)&#123;</span><br><span class="line">        key = <span class="keyword">this</span>.calc(key);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.arr[key];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 这里将key（'abc','bbb'）的值转成索引存到数组里面，然后通过key去数组里面找;</span></span><br><span class="line"><span class="comment">// 如果第一项就%出来是99项，那数组前面就都是空项了，所以这个hash表有个特点：松散，如果重复的话可以再加个链表，可以hash+链表的结构存储</span></span><br><span class="line"><span class="comment">// 特点取值快 而且es6已经提供了，可以直接使用</span></span><br><span class="line"><span class="comment">// 运行如下：</span></span><br><span class="line"><span class="keyword">let</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">map.set(<span class="string">'abc'</span>, <span class="number">123</span>);</span><br><span class="line">map.set(<span class="string">'bbb'</span>, <span class="number">456</span>);</span><br><span class="line"><span class="built_in">console</span>.log(map.get(<span class="string">'abc'</span>)); <span class="comment">// 456</span></span><br><span class="line"><span class="built_in">console</span>.log(map); <span class="comment">// Map &#123; arr: [ &lt;94 empty items&gt;, 456 ] &#125;</span></span><br></pre></td></tr></table></figure>

<h5 id="6）-二叉树-二叉查找树"><a href="#6）-二叉树-二叉查找树" class="headerlink" title="6） 二叉树 (二叉查找树)"></a>6） 二叉树 (二叉查找树)</h5><p>数据存储方式 小的放左边 大的放右边<br>树的的遍历 递归 查找<br><img src="https://jiafei2333.github.io/html/images/binary-tree.png" alt title="二叉树"></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123; <span class="comment">// 一个一个的节点</span></span><br><span class="line">    <span class="keyword">constructor</span>(element)&#123;</span><br><span class="line">        <span class="keyword">this</span>.element = element;</span><br><span class="line">        <span class="keyword">this</span>.left = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">this</span>.right = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tree</span></span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>()&#123;</span><br><span class="line">        <span class="keyword">this</span>.root = <span class="literal">null</span>; <span class="comment">// 树的跟</span></span><br><span class="line">    &#125;</span><br><span class="line">    insert(root, newNode)&#123;</span><br><span class="line">        <span class="keyword">if</span>(newNode.element &lt; root.element)&#123;</span><br><span class="line">            <span class="keyword">if</span>(root.left == <span class="literal">null</span>)&#123;</span><br><span class="line">                root.left = newNode;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">this</span>.insert(root.left, newNode);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(root.right == <span class="literal">null</span>)&#123;</span><br><span class="line">                root.right = newNode;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">this</span>.insert(root.right, newNode);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    add(element)&#123;</span><br><span class="line">        <span class="keyword">let</span> node = <span class="keyword">new</span> Node(element);</span><br><span class="line">        <span class="keyword">if</span>( !<span class="keyword">this</span>.root)&#123;</span><br><span class="line">            <span class="keyword">this</span>.root = node;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.insert(<span class="keyword">this</span>.root, node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> tree = <span class="keyword">new</span> Tree;</span><br><span class="line">tree.add(<span class="number">100</span>);</span><br><span class="line"><span class="built_in">console</span>.log(tree); <span class="comment">//Tree &#123; root: Node &#123; element: 100, left: null, right: null &#125; &#125;</span></span><br><span class="line">tree.add(<span class="number">60</span>);</span><br><span class="line">tree.add(<span class="number">150</span>);</span><br><span class="line"><span class="built_in">console</span>.log(tree);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">JSON</span>.stringify(tree));</span><br><span class="line"><span class="comment">// &#123;"root":&#123;"element":100,"left":&#123;"element":60,"left":null,"right":null&#125;,"right":&#123;"element":150,"left":null,"right":null&#125;&#125;&#125;</span></span><br></pre></td></tr></table></figure>

<p>红黑树<br>图 树之间的节点产生关联  邻接表   可以稍微了解下</p>
]]></content>
      <categories>
        <category>js基础</category>
      </categories>
  </entry>
  <entry>
    <title>用es5来模拟es6中的class</title>
    <url>/2019/09/11/ES5-Class/</url>
    <content><![CDATA[<h4 id="1-new的原理"><a href="#1-new的原理" class="headerlink" title="1) new的原理"></a>1) new的原理</h4><p>es5中没有类 用构造函数来模拟类</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Animal</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// es5中的类可以当做函数来调用 ，es6中不行</span></span><br></pre></td></tr></table></figure>

<p>首先来判断是否是通过new来调用的</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Animal</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>( !(<span class="keyword">this</span> <span class="keyword">instanceof</span> Animal))&#123;</span><br><span class="line">        <span class="keyword">throw</span>  <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'NOT NEW'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Animal(); // Error: NOT NEW</span></span><br><span class="line"><span class="keyword">new</span> Animal();</span><br></pre></td></tr></table></figure>

<a id="more"></a>
<h4 id="2-在类中有2种属性-一种是实例上的属性-一种是公共属性"><a href="#2-在类中有2种属性-一种是实例上的属性-一种是公共属性" class="headerlink" title="2) 在类中有2种属性 一种是实例上的属性 一种是公共属性"></a>2) 在类中有2种属性 一种是实例上的属性 一种是公共属性</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Animal</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>( !(<span class="keyword">this</span> <span class="keyword">instanceof</span> Animal))&#123;</span><br><span class="line">        <span class="keyword">throw</span>  <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'NOT NEW'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.name = &#123;<span class="attr">name</span>: <span class="string">'加菲'</span>&#125;;</span><br><span class="line">    <span class="keyword">this</span>.age = <span class="number">18</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> a1 = <span class="keyword">new</span> Animal();</span><br><span class="line"><span class="keyword">let</span> a2 = <span class="keyword">new</span> Animal();</span><br><span class="line"><span class="built_in">console</span>.log(a1, a2); <span class="comment">// Animal &#123; name: &#123; name: '加菲' &#125;, age: 18 &#125; Animal &#123; name: &#123; name: '加菲' &#125;, age: 18 &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(a1.name === a2.name); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p>所以 name、age这些属性都是实例上的属性，每个实例都独自的有这些属性</p>
<p>公共属性：一般会加到这个类（Animal）的原型上</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Animal</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>( !(<span class="keyword">this</span> <span class="keyword">instanceof</span> Animal))&#123;</span><br><span class="line">        <span class="keyword">throw</span>  <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'NOT NEW'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.name = &#123;<span class="attr">name</span>: <span class="string">'加菲'</span>&#125;;</span><br><span class="line">    <span class="keyword">this</span>.age = <span class="number">18</span>;</span><br><span class="line">&#125;</span><br><span class="line">Animal.prototype.say = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'说话'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> a1 = <span class="keyword">new</span> Animal();</span><br><span class="line"><span class="keyword">let</span> a2 = <span class="keyword">new</span> Animal();</span><br><span class="line"><span class="built_in">console</span>.log(a1.say === a2.say); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(a1.__proto__ === Animal.prototype); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(a1.__proto__.constructor === Animal); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(a1.__proto__.__proto__ === <span class="built_in">Object</span>.prototype); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.__proto__); <span class="comment">// null</span></span><br><span class="line"><span class="comment">// 一般情况下 最要不要操作__proto__ 有些浏览器不兼容IE</span></span><br><span class="line"><span class="comment">// 这里增加原型链知识点 可以参考《原型链 &amp; 继承》这篇</span></span><br></pre></td></tr></table></figure>

<h4 id="3）-类的继承：-继承实例上的属性、公共属性"><a href="#3）-类的继承：-继承实例上的属性、公共属性" class="headerlink" title="3） 类的继承： 继承实例上的属性、公共属性"></a>3） 类的继承： 继承实例上的属性、公共属性</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Animal</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.type = <span class="string">'哺乳动物'</span>;</span><br><span class="line">&#125;</span><br><span class="line">Animal.prototype.say = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'我是动物'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Tiger</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    Animal.call(<span class="keyword">this</span>); <span class="comment">// 调用父类的构造函数 并且让this指向子类即可</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> tiger = <span class="keyword">new</span> Tiger(<span class="string">"老虎"</span>);</span><br><span class="line"><span class="comment">//Tiger.prototype.__proto__ = Animal.prototype; // 功能与下面这行等同</span></span><br><span class="line"><span class="built_in">Object</span>.setPrototypeOf(Tiger.prototype, Animal.prototype); <span class="comment">// es6语法就是指定了链的指向</span></span><br><span class="line"><span class="built_in">console</span>.log(tiger.type); <span class="comment">// 哺乳动物</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Object.create</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Animal</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.type = <span class="string">'哺乳动物'</span>;</span><br><span class="line">&#125;</span><br><span class="line">Animal.prototype.say = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'我是动物'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Tiger</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    Animal.call(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> tiger = <span class="keyword">new</span> Tiger(<span class="string">"老虎"</span>);</span><br><span class="line">Tiger.prototype = <span class="built_in">Object</span>.create(Animal.prototype, &#123;<span class="attr">constructor</span>:&#123;<span class="attr">value</span>: Tiger&#125;&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(tiger.type); <span class="comment">// 哺乳动物</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>ES6</category>
      </categories>
  </entry>
  <entry>
    <title>原型链 & 继承</title>
    <url>/2019/09/09/Prototype-Extends/</url>
    <content><![CDATA[<h2 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h2><h3 id="1-定义对象的几种方法"><a href="#1-定义对象的几种方法" class="headerlink" title="1)定义对象的几种方法"></a>1)定义对象的几种方法</h3><p><img src="https://jiafei2333.github.io/html/images/Object-1.png" alt title="定义对象"></p>
<a id="more"></a>
<p>结果打印：</p>
<p><img src="https://jiafei2333.github.io/html/images/Object-2.png" alt title="定义对象"></p>
<h3 id="2）原型链"><a href="#2）原型链" class="headerlink" title="2）原型链"></a>2）原型链</h3><p><img src="https://jiafei2333.github.io/html/images/Prototype-Chain.png" alt title="原型链"></p>
<p>① 只要是对象就是实例；<br>② new 函数  就叫做构造函数；<br>③ 函数在声明的时候都js会给一个属性prototype 指向原型对象<br>④<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;M.prototype.construct === M<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;obj3.<strong>__</strong>proto____ === M.prototype<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;obj3.constructor === M<br>⑤ Object.prototype是整个原型链的顶端<br>⑥ 如果我想增加一个say方法，可以直接在M方法上 this.say=function(){}增加，这样每个实例都会拷贝一份say方法，如果嫌占内存没必要，也可以在M的原型链增加，继而实例也是可以找到这个方法的。也就是说，任何一个实例对象通过原型链找到它上面的原型对象，原型对象上面的方法和属性都是被实例所共享的（原理）。</p>
<p><img src="https://jiafei2333.github.io/html/images/Object-3.png" alt title="say方法"></p>
<p>⑦只有函数有prototype 实例对象有<strong>__</strong>proto______，但是函数也有<strong>__</strong>proto______（因为它也是一个对象） M.<strong>__</strong>proto____ === Function.prototype 就是说 M的构造函数是Function 也可以说M这个普通的函数是构造函数Function的一个实例对象</p>
<h3 id="3）instanceof"><a href="#3）instanceof" class="headerlink" title="3）instanceof"></a>3）instanceof</h3><p>①左边 实例对象    instanceof   右边 构造函数<br><img src="https://jiafei2333.github.io/html/images/instanceof-1.pn.png" alt title="instanceof原理"></p>
<p>② 原理：判断这个实例对象是不是构造函数的实例，其实是 判断左侧实例对象的<strong>__</strong>proto____ 和 构造函数的prototype指向的是不是同一个引用  在同一条原型链上就可以</p>
<p><img src="https://jiafei2333.github.io/html/images/instanceof-2.png" alt title="instanceof打印结果"></p>
<p>所以也可以说obj3是Object的实例 同一条原型链上都可以;<br>通过 obj3.<strong>__</strong>proto____.constructor === M | obj3.constructor === M； 通过constructor可以来精确的判断是不是哪个实例</p>
<h3 id="4-new-运算符"><a href="#4-new-运算符" class="headerlink" title="4)new 运算符"></a>4)new 运算符</h3><p>new 关键字会进行如下操作：</p>
<p>1、创建一个空的JavaScript对象（即{}）；<br>2、将函数的 prototype 赋值给对象的 <strong>proto</strong>属性 ；<br>3、调用函数，并将步骤1新创建的对象作为函数的this上下文 ；<br>4、如果该函数没有返回值或者返回值不是对象，则返回创建的对象，如果返回值是对象，则直接返回该对象。</p>
<p>JS引擎执行这句代码时，在内部做了很多工作，用伪代码模拟其工作流程如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> Person(<span class="string">"John"</span>) = &#123;</span><br><span class="line">  <span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line">	obj.__proto__ = Person.prototype; <span class="comment">// 此时便建立了obj对象的原型链： obj-&gt;Person.prototype-&gt;Object.prototype-&gt;null</span></span><br><span class="line">	<span class="keyword">var</span> result = Person.call(obj,<span class="string">"John"</span>); <span class="comment">// 相当于obj.Person("John")</span></span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">typeof</span> result === <span class="string">'object'</span> ? result : obj; <span class="comment">// 如果无返回值或者返回一个非对象值，则将obj返回作为新对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>相关文章：<br><a href="https://juejin.im/post/5d65e03b6fb9a06b2c32a00c" target="_blank" rel="noopener">https://juejin.im/post/5d65e03b6fb9a06b2c32a00c</a><br><a href="https://juejin.im/post/5b397b526fb9a00e5d7999a4" target="_blank" rel="noopener">https://juejin.im/post/5b397b526fb9a00e5d7999a4</a></p>
<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><h3 id="1）构造函数继承"><a href="#1）构造函数继承" class="headerlink" title="1）构造函数继承"></a>1）构造函数继承</h3><p><img src="https://jiafei2333.github.io/html/images/Extends-1.png" alt title="构造函数"></p>
<p>打印结果：</p>
<p><img src="https://jiafei2333.github.io/html/images/Extends-3.png" alt title="打印结果"></p>
<p>这里可以看到，没有继承父类的say方法</p>
<p><img src="https://jiafei2333.github.io/html/images/Extends-2.png" alt title="打印结果"></p>
<p>原理：通过构造函数实现继承（call）<br>缺点：父类上的属性在构造函数里的都可以继承，但父类原型对象上的方法Parent.prototype 继承不到。</p>
<h3 id="2）原型链继承"><a href="#2）原型链继承" class="headerlink" title="2）原型链继承"></a>2）原型链继承</h3><p><img src="https://jiafei2333.github.io/html/images/Extends-5.png" alt title="原型链继承"></p>
<p>打印结果：</p>
<p><img src="https://jiafei2333.github.io/html/images/Extends-6.png" alt title="打印结果"></p>
<p>缺点:</p>
<p><img src="https://jiafei2333.github.io/html/images/Extends-7.png" alt title="原型链继承缺点"></p>
<p><img src="https://jiafei2333.github.io/html/images/Extends-8.png" alt title="原型链继承缺点打印"></p>
<p>总结： 当实例多个对象时，改变其中一个 另一个也改变。原因 这2个实例引用的原型对象是共用的。</p>
<h3 id="3）组合方式"><a href="#3）组合方式" class="headerlink" title="3）组合方式"></a>3）组合方式</h3><p><img src="https://jiafei2333.github.io/html/images/Extends-9.png" alt title="组合方式"></p>
<p>打印结果：</p>
<p><img src="https://jiafei2333.github.io/html/images/Extends-10.png" alt title="组合方式打印结果"></p>
<p>缺点：上图红色框中构造函数执行了2次，执行一次父类的属性子类已经有了</p>
<h3 id="4）Object-create"><a href="#4）Object-create" class="headerlink" title="4）Object.create"></a>4）Object.create</h3><p><img src="https://jiafei2333.github.io/html/images/Object.create-Picture.png" alt></p>
<p>上面代码中，<code>Object.create</code> 方法以A对象为原型，生成了B对象。B继承了A的所有属性和方法。</p>
<p>实际上，<code>Object.create</code> 方法可以用下面的代码代替.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Object</span>.create = <span class="function"><span class="keyword">function</span> (<span class="params">obj</span>) </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">    F.prototype = obj;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> F();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>上面代码表明，<code>Object.create</code> 方法的实质是新建一个空的构造函数 <code>F</code> ，然后让 <code>F.prototype</code> 属性指向参数对象 <code>obj</code> ，最后返回一个 <code>F</code> 的实例，从而实现让该实例继承 <code>obj</code> 的属性。</p>
<p>或者</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Object</span>.create = <span class="function"><span class="keyword">function</span>(<span class="params">obj</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> B = &#123;&#125;;</span><br><span class="line">    <span class="built_in">Object</span>.setPrototypeOf(B, obj);</span><br><span class="line">    <span class="keyword">return</span> B;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>或者</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Object</span>.create = <span class="function"><span class="keyword">function</span>(<span class="params">obj</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> B = &#123;&#125;;</span><br><span class="line">    B.__proto__ = obj;</span><br><span class="line">    <span class="keyword">return</span> B;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>object.create方法生成的新对象，动态继承了原型。在原型上添加或修改任何方法，会立刻反映在新对象之上。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj1 = &#123; <span class="attr">p</span>: <span class="number">1</span> &#125;;</span><br><span class="line"><span class="keyword">var</span> obj2 = <span class="built_in">Object</span>.create(obj1);</span><br><span class="line"></span><br><span class="line">obj1.p = <span class="number">2</span>;</span><br><span class="line">obj2; <span class="comment">// &#123;&#125;</span></span><br><span class="line">obj2.p <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，修改对象原型obj1会影响到实例对象obj2。</p>
<h4 id="Object-create-第一个参数"><a href="#Object-create-第一个参数" class="headerlink" title="Object.create 第一个参数"></a>Object.create 第一个参数</h4><blockquote>
<p>如果想要生成一个不继承任何属性（比如没有toString和valueOf方法）的对象，可以将 <code>Object.create</code>的参数设为 null。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = <span class="built_in">Object</span>.create(<span class="literal">null</span>);</span><br></pre></td></tr></table></figure>

<h4 id="Object-create-第二个参数"><a href="#Object-create-第二个参数" class="headerlink" title="Object.create 第二个参数"></a>Object.create 第二个参数</h4><blockquote>
<p>除了对象的原型，<code>Object.create</code> 方法还可以接受第二个参数。该参数是一个属性描述对象，它所描述的对象属性，会添加到实例对象，作为该对象自身的属性。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = <span class="built_in">Object</span>.create(&#123;&#125;, &#123;</span><br><span class="line">  p1: &#123;</span><br><span class="line">    value: <span class="number">123</span>,</span><br><span class="line">    enumerable: <span class="literal">true</span>,</span><br><span class="line">    configurable: <span class="literal">true</span>,</span><br><span class="line">    writable: <span class="literal">true</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  p2: &#123;</span><br><span class="line">    value: <span class="string">'abc'</span>,</span><br><span class="line">    enumerable: <span class="literal">true</span>,</span><br><span class="line">    configurable: <span class="literal">true</span>,</span><br><span class="line">    writable: <span class="literal">true</span>,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">var</span> obj = <span class="built_in">Object</span>.create(&#123;&#125;);</span><br><span class="line">obj.p1 = <span class="number">123</span>;</span><br><span class="line">obj.p2 = <span class="string">'abc'</span>;</span><br></pre></td></tr></table></figure>

<p><a href="https://juejin.im/post/5a9ce60b6fb9a028cc60b69c" target="_blank" rel="noopener">Object.create 原文链接</a></p>
]]></content>
      <categories>
        <category>js基础</category>
      </categories>
  </entry>
  <entry>
    <title>ES6模块</title>
    <url>/2019/09/06/esModule/</url>
    <content><![CDATA[<h4 id="es6模块化"><a href="#es6模块化" class="headerlink" title="es6模块化"></a>es6模块化</h4><p>面试会问到 怎么使用es6模块  esModule模块（es6）  commonjs模块(node模块)<br>尽量不要混用<br>import 导入  export导出  每个文件都是一个模块<br>现在新建一个a模块 （a.js）</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;c, b&#125; <span class="keyword">from</span> <span class="string">'./a'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(c, b); <span class="comment">// 1 2</span></span><br></pre></td></tr></table></figure>

<a id="more"></a>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// index.js</span></span><br><span class="line"><span class="keyword">import</span> _, &#123;c, b&#125; <span class="keyword">from</span> <span class="string">'./a'</span>; <span class="comment">// 导入的不是一个值 是一个接口</span></span><br><span class="line">setInterval(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(c, b); <span class="comment">// 每次获取的值都会随着接口中的内容变化而变化</span></span><br><span class="line">&#125;, <span class="number">1000</span>);</span><br><span class="line"><span class="built_in">console</span>.log(_); </span><br><span class="line"><span class="comment">// 这里对应的就是export default的值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// a.js</span></span><br><span class="line"><span class="keyword">let</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">let</span> b = <span class="number">2</span>;</span><br><span class="line">setInterval(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    a++</span><br><span class="line">&#125;, <span class="number">1000</span>);</span><br><span class="line"><span class="keyword">export</span> &#123; <span class="comment">// 这个指导出的是变量 接口 例如这个定时器能够一直导出</span></span><br><span class="line">    a <span class="keyword">as</span> c,</span><br><span class="line">    b</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="string">'hello'</span>; <span class="comment">// 这个指导出具体的值</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">打印结果：</span></span><br><span class="line"><span class="comment">hello</span></span><br><span class="line"><span class="comment">2,2</span></span><br><span class="line"><span class="comment">3,2</span></span><br><span class="line"><span class="comment">4,2</span></span><br><span class="line"><span class="comment">...</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>import 语法只能放在最外层作用域中<br>import 语法会解析到页面的最顶端</p>
<h5 id="动态导入"><a href="#动态导入" class="headerlink" title="动态导入"></a>动态导入</h5><p> 希望按钮一点击 再去加载文件</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// file.js</span></span><br><span class="line"><span class="keyword">let</span> btn = <span class="built_in">document</span>.createElement(<span class="string">'button'</span>);</span><br><span class="line">btn.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">// import语法返回的是一个promise</span></span><br><span class="line">    <span class="keyword">import</span>(<span class="string">'./file'</span>).then(<span class="function"><span class="params">data</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(data);</span><br><span class="line">    &#125;);<span class="comment">// es7的语法 动态的使用jsonp加载一个新的文件</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">document</span>.body.appendChild(btn);</span><br></pre></td></tr></table></figure>

<p>动态导入 可以在作用域中使用</p>
<hr>
<p>es6模块：import * as / default     export | export default</p>
]]></content>
      <categories>
        <category>js基础</category>
      </categories>
  </entry>
  <entry>
    <title>Reflect & Symbol</title>
    <url>/2019/09/04/Reflect-Symbol/</url>
    <content><![CDATA[<h3 id="Reflect"><a href="#Reflect" class="headerlink" title="Reflect"></a>Reflect</h3><p>反射 Object.definedProperty<br>里面有部分Object的方法 放到了Reflect 功能基本一致<br>Proxy中能代理的方法 Reflect都可以实现</p>
<a id="more"></a>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;&#125;;</span><br><span class="line"><span class="comment">// 赋值</span></span><br><span class="line"><span class="built_in">Reflect</span>.set(obj, <span class="string">'name'</span>, <span class="string">'加菲'</span>); <span class="comment">// 等同于 obj.name = '加菲';</span></span><br><span class="line"><span class="built_in">console</span>.log(obj); <span class="comment">// &#123; name: '加菲' &#125;</span></span><br><span class="line"><span class="comment">// 取值</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Reflect</span>.get(obj, <span class="string">'name'</span>)); <span class="comment">// 加菲</span></span><br><span class="line"><span class="comment">//是否在对象中</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'a'</span> <span class="keyword">in</span> &#123;<span class="attr">a</span>: <span class="number">1</span>&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Reflect</span>.has( &#123;<span class="attr">a</span>: <span class="number">1</span>&#125;, <span class="string">'a'</span>));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.defineProperty;</span><br><span class="line"><span class="built_in">Reflect</span>.defineProperty;</span><br><span class="line"><span class="comment">//如下：</span></span><br><span class="line"><span class="keyword">const</span> obj = &#123;<span class="attr">a</span>: <span class="number">1</span>&#125;;</span><br><span class="line"><span class="built_in">Object</span>.freeze(obj); <span class="comment">// 冻结</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(obj, <span class="string">'a'</span>, &#123;</span><br><span class="line">    value: <span class="number">100</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(obj);</span><br><span class="line"><span class="comment">// Cannot redefine property: a    报错</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj = &#123;<span class="attr">a</span>: <span class="number">1</span>&#125;;</span><br><span class="line"><span class="built_in">Object</span>.freeze(obj); <span class="comment">// 冻结</span></span><br><span class="line"><span class="comment">// 可以不让别人修改get set方法</span></span><br><span class="line"><span class="comment">// 应用场景：vue里面有个叫数据劫持 把对象上的属性get set都给重写了，重写会增加性能，如果有些对象不需要更改，可以直接用freeze冻结，</span></span><br><span class="line"><span class="keyword">let</span> reflect = <span class="built_in">Reflect</span>.defineProperty(obj, <span class="string">'a'</span>, &#123;</span><br><span class="line">    value: <span class="number">100</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(obj, reflect); <span class="comment">// &#123; a: 1 &#125; false </span></span><br><span class="line"><span class="comment">// 用Reflect就不会报错，且reflect可以获取是否设置成功</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj = &#123;<span class="attr">a</span>: <span class="number">1</span>&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getOwnPropertyDescriptor(obj, <span class="string">'a'</span>));</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Reflect</span>.getOwnPropertyDescriptor(obj, <span class="string">'a'</span>));</span><br><span class="line"><span class="comment">// &#123; value: 1, writable: true, enumerable: true, configurable: true &#125;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">    a: <span class="number">1</span>,</span><br><span class="line">    [<span class="built_in">Symbol</span>()]: <span class="number">2</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getOwnPropertyNames(obj)); <span class="comment">// [ 'a' ]   // 获取自身的属性</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getOwnPropertySymbols(obj)); <span class="comment">// [ Symbol() ]   // 获取Symbol</span></span><br><span class="line"><span class="comment">// Object这2个key都是obj上的私有属性，但是这里只能分开获取</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Reflect</span>.ownKeys(obj)); <span class="comment">// [ 'a', Symbol() ]</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.setPrototypeOf; <span class="comment">// obj.__proto__ 设置原型链</span></span><br><span class="line"><span class="built_in">Object</span>.getPrototypeOf; <span class="comment">// obj.__proto__ 获取原型链</span></span><br><span class="line"><span class="built_in">Reflect</span>.setPrototypeOf;</span><br><span class="line"><span class="built_in">Reflect</span>.getPrototypeOf;</span><br></pre></td></tr></table></figure>

<p>call、apply可以改变this指向</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> fn = <span class="function"><span class="keyword">function</span>(<span class="params">a, b</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>, a, b);</span><br><span class="line">&#125;</span><br><span class="line">fn.apply(<span class="number">1</span>,[<span class="number">2</span>,<span class="number">3</span>]); <span class="comment">// [Number: 1] 2 3</span></span><br><span class="line">fn.call(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>); <span class="comment">// [Number: 1] 2 3</span></span><br></pre></td></tr></table></figure>

<p>假设fn本身有一个apply方法</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> fn = <span class="function"><span class="keyword">function</span> (<span class="params">a, b</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>, a, b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// fn本身有一个apply方法</span></span><br><span class="line">fn.apply = <span class="function"><span class="keyword">function</span> (<span class="params">a, b</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'fn-apply'</span>, a, b);</span><br><span class="line">&#125;</span><br><span class="line">fn.apply(<span class="number">1</span>,[<span class="number">2</span>,<span class="number">3</span>]); <span class="comment">// fn-apply 1 [ 2, 3 ] 那这个调用的就是本身的方法 没有调原型上的apply方法</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">// Function.prototype.apply.call(fn); // 这里意思是我调用原型上的apply方法，并用call改变this相当于</span></span><br><span class="line"><span class="comment">// fn.apply();</span></span><br><span class="line"><span class="built_in">Function</span>.prototype.apply.call(fn,<span class="number">1</span>,[<span class="number">2</span>,<span class="number">3</span>]); <span class="comment">// [Number: 1] 2 3 // 这样调的就是原型上的apply</span></span><br><span class="line"><span class="built_in">Reflect</span>.apply(fn, <span class="number">1</span>,[<span class="number">2</span>,<span class="number">3</span>]); <span class="comment">// [Number: 1] 2 3 这行和上面这行是一样的</span></span><br></pre></td></tr></table></figure>

<p>如何调取原型上的apply方法</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> fn = <span class="function"><span class="keyword">function</span> (<span class="params">a, b</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>, a, b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// fn本身有一个apply方法</span></span><br><span class="line">fn.apply = <span class="function"><span class="keyword">function</span> (<span class="params">a, b</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'fn-apply'</span>, a, b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Function.prototype.apply.call(fn); // 这里意思是我调用原型上的apply方法，并用call改变this相当于</span></span><br><span class="line"><span class="comment">// fn.apply();</span></span><br><span class="line"><span class="built_in">Function</span>.prototype.apply.call(fn,<span class="number">1</span>,[<span class="number">2</span>,<span class="number">3</span>]); <span class="comment">// [Number: 1] 2 3 // 这样调的就是原型上的apply</span></span><br><span class="line"><span class="built_in">Reflect</span>.apply(fn, <span class="number">1</span>,[<span class="number">2</span>,<span class="number">3</span>]); <span class="comment">// [Number: 1] 2 3 这行和上面这行是一样的</span></span><br></pre></td></tr></table></figure>

<p>其他的一些用法</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">XXX</span></span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(name)&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> xxx = <span class="built_in">Reflect</span>.construct(XXX, [<span class="string">'haha'</span>]);</span><br><span class="line"><span class="comment">//let xxx = new XXX('hah');  和这一行是一样的</span></span><br><span class="line"><span class="built_in">console</span>.log(xxx);  </span><br><span class="line"><span class="comment">// XXX &#123; name: 'haha' &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Reflect</span>.deleteProperty <span class="comment">//delete obj.a  返回是否删除成功</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 对象属性不能扩展（不能添加属性）  、是否可扩展</span></span><br><span class="line"><span class="keyword">const</span> obj = &#123;&#125;;</span><br><span class="line"><span class="built_in">Reflect</span>.preventExtensions(obj); <span class="comment">// Object.preventExtensions 和它的用法一样</span></span><br><span class="line">obj.a = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">console</span>.log(obj); <span class="comment">// &#123;&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Reflect</span>.isExtensible(obj)); <span class="comment">// false 是否可扩展 和Object.isExtensible是一样的</span></span><br></pre></td></tr></table></figure>

<h3 id="Symbol"><a href="#Symbol" class="headerlink" title="Symbol"></a>Symbol</h3><blockquote>
<p>ES6 引入了一种新的原始数据类型Symbol，表示独一无二的值。它是 JavaScript 语言的第七种数据类型，前六种是：undefined、null、布尔值（Boolean）、字符串（String）、数值（Number）、对象（Object）。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 一般可以用作常量</span></span><br><span class="line"><span class="keyword">const</span> s1 = <span class="built_in">Symbol</span>(<span class="string">'加菲'</span>); <span class="comment">// 里面放string 、number</span></span><br><span class="line"><span class="built_in">console</span>.log(s1); <span class="comment">// Symbol(加菲)</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">const</span> s1 = <span class="built_in">Symbol</span>(<span class="string">'加菲'</span>); </span><br><span class="line"><span class="keyword">const</span> s2 = <span class="built_in">Symbol</span>(<span class="string">'加菲'</span>); </span><br><span class="line"><span class="built_in">console</span>.log(s1 === s2); <span class="comment">// false</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">let</span> s1 = <span class="built_in">Symbol</span>.for(<span class="string">'加菲'</span>);</span><br><span class="line"><span class="keyword">let</span> s2 = <span class="built_in">Symbol</span>.for(<span class="string">'加菲'</span>); <span class="comment">// 如果Symboly已经有值了，就将这个值返回</span></span><br><span class="line"><span class="built_in">console</span>.log(s1 === s2); <span class="comment">// true</span></span><br><span class="line"><span class="comment">// 和上面line4-5一样，唯一的不同是 已经有值了，就将这个值返回</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">    [s1]: <span class="number">1</span>, <span class="comment">// es6写法，[]的含义是将s1结果取出来作为key</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//对应的取值</span></span><br><span class="line"><span class="built_in">console</span>.log(obj[s1]); <span class="comment">// 1 不能直接obj.s1这样</span></span><br></pre></td></tr></table></figure>

<h4 id="其他功能："><a href="#其他功能：" class="headerlink" title="其他功能："></a>其他功能：</h4><h5 id="元编程-可以改变js源代码的功能"><a href="#元编程-可以改变js源代码的功能" class="headerlink" title="元编程  可以改变js源代码的功能"></a>元编程  可以改变js源代码的功能</h5><p>1）instanceof&nbsp;&nbsp;&nbsp;&nbsp; 可以判断某个人是否是谁的类的实例</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> o = &#123;</span><br><span class="line">    name: <span class="number">1</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> obj = &#123;&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(o <span class="keyword">instanceof</span> obj); <span class="comment">// Right-hand side of 'instanceof' is not callable</span></span><br><span class="line"><span class="comment">// 我们现在希望的是让o是obj的实例</span></span><br></pre></td></tr></table></figure>

<p>现在就重写下这个行为</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> o = &#123;</span><br><span class="line">    name: <span class="number">1</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    [<span class="built_in">Symbol</span>.hasInstance]()&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'name'</span> <span class="keyword">in</span> o</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(o <span class="keyword">instanceof</span> obj); <span class="comment">// true 这里默认会调obj的[Symbol.hasInstance]方法</span></span><br></pre></td></tr></table></figure>

<p>和之前讲过的Symbol.iterator 在迭代的时候默认会调用一样<br>2）toString</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;<span class="attr">a</span>: <span class="number">1</span>&#125;; <span class="comment">// valueOf toString  面试可能会遇上</span></span><br><span class="line"><span class="built_in">console</span>.log(obj+<span class="number">1</span>, <span class="keyword">typeof</span> (obj+<span class="number">1</span>));</span><br><span class="line"><span class="comment">//  [object Object]1   string</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// toString</span></span><br><span class="line"><span class="keyword">let</span> obj = &#123;<span class="attr">a</span>: <span class="number">1</span>&#125;; </span><br><span class="line"><span class="built_in">console</span>.log(obj.toString()); <span class="comment">//  [object Object]</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    <span class="keyword">get</span> [Symbol.toStringTag]()&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'123'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(obj.toString()); <span class="comment">// [object 123]</span></span><br><span class="line"><span class="comment">// 上面这个obj.toString() 其实调用的是Object.Prototype.toString</span></span><br></pre></td></tr></table></figure>

<h5 id="衍生对象"><a href="#衍生对象" class="headerlink" title="衍生对象"></a>衍生对象</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 衍生对象</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyArray</span> <span class="keyword">extends</span> <span class="title">Array</span></span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(...args)&#123;</span><br><span class="line">        <span class="keyword">super</span>(...args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> myarr = <span class="keyword">new</span> MyArray(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>);</span><br><span class="line"><span class="keyword">let</span> newarr = myarr.map( <span class="function"><span class="params">item</span>=&gt;</span>item*<span class="number">2</span>); <span class="comment">// 衍生出来的结果是当前类的实例</span></span><br><span class="line"><span class="comment">// instanceof 原理 .__proto__.__proto__一级一级在原型链上找</span></span><br><span class="line"><span class="built_in">console</span>.log(myarr <span class="keyword">instanceof</span> MyArray); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(newarr <span class="keyword">instanceof</span> MyArray); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(newarr <span class="keyword">instanceof</span> <span class="built_in">Array</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>newarr明明不是new出来的 怎么会是MyArray 和Array的实例呢 改变如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyArray</span> <span class="keyword">extends</span> <span class="title">Array</span></span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(...args)&#123;</span><br><span class="line">        <span class="keyword">super</span>(...args);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">get</span> [Symbol.species]()&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Array</span>; <span class="comment">// 控制衍生对象的类的构造函数  这样衍生出来的时候就是Array的实例 不是MyArray的实例了</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> myarr = <span class="keyword">new</span> MyArray(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>);</span><br><span class="line"><span class="keyword">let</span> newarr = myarr.map( <span class="function"><span class="params">item</span>=&gt;</span>item*<span class="number">2</span>); <span class="comment">// 衍生出来的结果是当前类的实例</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(myarr <span class="keyword">instanceof</span> MyArray); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(newarr <span class="keyword">instanceof</span> MyArray); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(newarr <span class="keyword">instanceof</span> <span class="built_in">Array</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>ES6</category>
      </categories>
  </entry>
  <entry>
    <title>Object.defineProperty-Proxy</title>
    <url>/2019/09/04/Object.defineProperty-Proxy/</url>
    <content><![CDATA[<p>getter&nbsp;&nbsp;&nbsp;&nbsp;setter</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    <span class="keyword">get</span> a()&#123;</span><br><span class="line">        <span class="comment">// todo</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"取值了"</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(obj.a); <span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 这样设置和直接给obj.a赋值是一样的，不过可以在取值的时候todo</span></span><br></pre></td></tr></table></figure>

<a id="more"></a>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    _a: <span class="string">''</span>,</span><br><span class="line">    <span class="keyword">get</span> a()&#123;</span><br><span class="line">        <span class="comment">// todo</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"取值了"</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>._a;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="keyword">set</span> a(value)&#123;</span><br><span class="line">        <span class="keyword">this</span>._a = value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">obj.a = <span class="number">100</span>;</span><br><span class="line"><span class="built_in">console</span>.log(obj.a); <span class="comment">// 取值了 100</span></span><br></pre></td></tr></table></figure>

<h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><h5 id="vue中的数据劫持"><a href="#vue中的数据劫持" class="headerlink" title="vue中的数据劫持"></a>vue中的数据劫持</h5><p>给每个对象都添加一个getter setter 当值变化可以实现更新视图的功能</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    a: <span class="number">1</span>,</span><br><span class="line">    b: <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> updateView = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"更新"</span>);</span><br><span class="line">&#125;</span><br><span class="line">obj.a = <span class="number">100</span>;</span><br><span class="line"><span class="comment">// 希望的是 a的值一改变就能触发updateView这个方法  先掌握下面的基础知识</span></span><br></pre></td></tr></table></figure>

<p>Object.defineProperty</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;&#125;;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(obj, <span class="string">'a'</span>, &#123;</span><br><span class="line">    value: <span class="number">1</span>, <span class="comment">// 默认是不可枚举的</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(obj); <span class="comment">// &#123;&#125;</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> key <span class="keyword">in</span> obj)&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(key);  <span class="comment">// &#123;&#125; value的值不能被循环输出</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;&#125;;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(obj, <span class="string">'a'</span>, &#123;</span><br><span class="line">    value: <span class="number">1</span>, <span class="comment">// 默认是不可枚举的</span></span><br><span class="line">    enumerable: <span class="literal">true</span>,  <span class="comment">//改成true就可以枚举了， 原型上的方法也是不可枚举的</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(obj); <span class="comment">// &#123; a: 1 &#125;</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> key <span class="keyword">in</span> obj)&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(key);  <span class="comment">// a</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;&#125;;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(obj, <span class="string">'a'</span>, &#123;</span><br><span class="line">    value: <span class="number">1</span>,</span><br><span class="line">    enumerable: <span class="literal">true</span>,</span><br><span class="line">    writable: <span class="literal">true</span>, <span class="comment">// 是否可写  默认false 这里没有配置就不能更改他的值了 line8</span></span><br><span class="line">    configurable: <span class="literal">true</span>, <span class="comment">// 是否可删除   默认false</span></span><br><span class="line">&#125;)</span><br><span class="line">obj.a = <span class="number">100</span>;</span><br><span class="line"><span class="built_in">console</span>.log(obj); <span class="comment">// &#123; a: 100 &#125;</span></span><br></pre></td></tr></table></figure>

<p>现在加入get set</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;&#125;;</span><br><span class="line"><span class="keyword">let</span> val = <span class="string">''</span>;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(obj, <span class="string">'a'</span>, &#123;</span><br><span class="line">    <span class="comment">// value: 1, // 需要把这行隐藏 否则报错</span></span><br><span class="line">    enumerable: <span class="literal">true</span>,</span><br><span class="line">    <span class="comment">//writable: true, // 需要把这行隐藏 否则报错</span></span><br><span class="line">    configurable: <span class="literal">true</span>,</span><br><span class="line">    <span class="keyword">get</span>()&#123;</span><br><span class="line">        <span class="keyword">return</span> val;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="keyword">set</span>(value)&#123;</span><br><span class="line">        val = value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(obj);  <span class="comment">// &#123; a: [Getter/Setter] &#125;</span></span><br></pre></td></tr></table></figure>

<p>现在我希望把obj上的ab循环 将他们的定义方式和上面一样 如下:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    <span class="comment">// a: 1,</span></span><br><span class="line">    a: &#123;<span class="attr">a</span>:&#123;<span class="attr">a</span>:<span class="number">1</span>&#125;&#125;,</span><br><span class="line">    b: <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 模拟下vue源码    缺陷：无法监控数组的变化</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">observer</span>(<span class="params">obj</span>) </span>&#123; <span class="comment">// obj对象里面可能还有对象line3 所以这里新起了一个函数用来递归</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">typeof</span> obj !== <span class="string">'object'</span> || obj == <span class="literal">null</span>)&#123;</span><br><span class="line">         <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> key <span class="keyword">in</span> obj)&#123;</span><br><span class="line">        defineReactive(obj, key, obj[key]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> updateView = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"更新"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//  因为defineProperty需要一个公共的vaule去修改（供get、set）所以这里新起了一个defineReactive函数，这样这个value的作用域就是在下面这个函数中</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">defineReactive</span>(<span class="params">obj, key, value</span>)</span>&#123; <span class="comment">// 这里面这个value就在当前作用域下</span></span><br><span class="line">    observer(value); <span class="comment">// value可能是对象，这里递归去赋值get、set</span></span><br><span class="line">    <span class="built_in">Object</span>.defineProperty(obj, key, &#123;</span><br><span class="line">        <span class="keyword">get</span>()&#123;</span><br><span class="line">            <span class="keyword">return</span> value;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="keyword">set</span>(val)&#123;</span><br><span class="line">            updateView();</span><br><span class="line">            value = val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line">observer(obj);</span><br><span class="line">obj.a.a = <span class="number">100</span>;</span><br><span class="line"><span class="built_in">console</span>.log(obj, obj.a.a);</span><br><span class="line"><span class="comment">/*执行结果：</span></span><br><span class="line"><span class="comment">更新</span></span><br><span class="line"><span class="comment">&#123; a: [Getter/Setter], b: [Getter/Setter] &#125; 100</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p> 缺陷：现在我已近给a、b设置get、set了，但是如果我新加一个c，它是没有get、set的<br> <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">obj.c = <span class="number">200</span>;</span><br><span class="line"><span class="built_in">console</span>.log(obj); <span class="comment">// &#123; a: [Getter/Setter], b: [Getter/Setter], c: 200 &#125;</span></span><br></pre></td></tr></table></figure></p>
<p> 下面用proxy来实现：</p>
<h4 id="Proxy"><a href="#Proxy" class="headerlink" title="Proxy"></a>Proxy</h4><p> 特点 兼容性差<br> 代理 可以创造一个代理 帮我们干某些事</p>
<h5 id="对象代理"><a href="#对象代理" class="headerlink" title="对象代理"></a>对象代理</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    a: <span class="number">1</span>,</span><br><span class="line">    b: <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(obj, &#123;</span><br><span class="line">    <span class="keyword">get</span>()&#123;</span><br><span class="line"></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="keyword">set</span>(target, key, value)&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(target, key, value); <span class="comment">// &#123; a: 1, b: 2 &#125; 'c' 100</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">proxy.c = <span class="number">100</span>;</span><br></pre></td></tr></table></figure>

<p>现在给obj赋值</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    a: <span class="number">1</span>,</span><br><span class="line">    b: <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(obj, &#123;</span><br><span class="line">    <span class="keyword">get</span>()&#123;</span><br><span class="line"></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="keyword">set</span>(target, key, value)&#123;</span><br><span class="line">        target[key] = value; <span class="comment">//这行不够优雅 可如下</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">proxy.c = <span class="number">100</span>;</span><br><span class="line"><span class="built_in">console</span>.log(obj); </span><br><span class="line"><span class="comment">// &#123; a: 1, b: 2, c: 100 &#125;</span></span><br></pre></td></tr></table></figure>

<p>可以用Reflect 反射属性</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    a: <span class="number">1</span>,</span><br><span class="line">    b: <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(obj, &#123;</span><br><span class="line">    <span class="keyword">get</span>(target, key)&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"取值"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Reflect</span>.get(target, key);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="keyword">set</span>(target, key, value)&#123;</span><br><span class="line">        <span class="comment">//target[key] = value;</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"更新"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Reflect</span>.set(target, key, value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">proxy.c = <span class="number">100</span>;  <span class="comment">// 更新</span></span><br><span class="line"><span class="built_in">console</span>.log(obj); <span class="comment">// &#123; a: 1, b: 2, c: 100 &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(obj.c);  <span class="comment">// 100</span></span><br><span class="line"><span class="built_in">console</span>.log(proxy.c); <span class="comment">// 取值  100</span></span><br></pre></td></tr></table></figure>

<h5 id="数组代理"><a href="#数组代理" class="headerlink" title="数组代理"></a>数组代理</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(obj, &#123;</span><br><span class="line">    <span class="keyword">get</span>(target, key)&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"取值"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Reflect</span>.get(target, key);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="keyword">set</span>(target, key, value)&#123;</span><br><span class="line">        <span class="comment">//target[key] = value;</span></span><br><span class="line">        <span class="built_in">console</span>.log(target, key, value);</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"更新"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Reflect</span>.set(target, key, value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">proxy.push(<span class="number">3</span>);</span><br><span class="line"><span class="comment">/*执行结果</span></span><br><span class="line"><span class="comment">[ 1, 2, 3 ] '3' 3</span></span><br><span class="line"><span class="comment">更新</span></span><br><span class="line"><span class="comment">[ 1, 2, 3, 3 ] 'length' 4</span></span><br><span class="line"><span class="comment">更新</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>这里把修改length长度也打印出来了，做如下优化：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(obj, &#123;</span><br><span class="line">    <span class="keyword">get</span>(target, key)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Reflect</span>.get(target, key);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="keyword">set</span>(target, key, value)&#123;</span><br><span class="line">        <span class="comment">//target[key] = value;</span></span><br><span class="line">        <span class="keyword">if</span>(key === <span class="string">'length'</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="built_in">console</span>.log(target, key, value);</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"更新"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Reflect</span>.set(target, key, value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">proxy.push(<span class="number">3</span>);</span><br><span class="line"><span class="comment">/*执行结果：</span></span><br><span class="line"><span class="comment">[ 1, 2, 3 ] '3' 3</span></span><br><span class="line"><span class="comment">更新</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="built_in">console</span>.log(obj, proxy); <span class="comment">// [ 1, 2, 3, 3 ] [ 1, 2, 3, 3 ]</span></span><br></pre></td></tr></table></figure>

<p>优点： 支持数组，可直接更改数组 达到拦截的目的<br>当obj中有多层对象时，如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    a: &#123;<span class="attr">b</span>:&#123;<span class="attr">c</span>:&#123;<span class="attr">d</span>: <span class="number">1</span>&#125;&#125;&#125;,</span><br><span class="line">    b: <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(obj, &#123; <span class="comment">//只代理当前对象obj 1层</span></span><br><span class="line">    <span class="keyword">get</span>(target, key)&#123;</span><br><span class="line">        <span class="comment">//console.log("取值");</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Reflect</span>.get(target, key);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="keyword">set</span>(target, key, value)&#123;</span><br><span class="line">        <span class="comment">//target[key] = value;</span></span><br><span class="line">        <span class="keyword">if</span>(key === <span class="string">'length'</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="built_in">console</span>.log(target, key, value);</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"更新"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Reflect</span>.set(target, key, value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">proxy.a.b = <span class="number">100</span>; <span class="comment">// 这里没走“更新” 是因为proxy只代理这个对象obj 现在希望的是能走“更新”触发代理对象</span></span><br></pre></td></tr></table></figure>

<p>所以要递归代理 这里要给 {b:{c:{d: 1}}} 这个对象加上代理，然后要把这个代理赋给a，这样就会触发obj的set ，同样 {c:{d: 1}}要给这个对象加上代理，就会触发{b:{c:{d: 1}}}这个对象的set</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    a: &#123;<span class="attr">b</span>:&#123;<span class="attr">c</span>:&#123;<span class="attr">d</span>: <span class="number">1</span>&#125;&#125;&#125;,</span><br><span class="line">    b: <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(obj, &#123; <span class="comment">//只代理当前对象 1层</span></span><br><span class="line">    <span class="keyword">get</span>(target, key)&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">typeof</span> target[key] === <span class="string">'object'</span> &amp;&amp; target[key] !== <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Proxy</span>(target[key], handler); <span class="comment">// 这里递归了这个代理的过程，将这部分抽离出来</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Reflect</span>.get(target, key);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="keyword">set</span>(target, key, value)&#123;</span><br><span class="line">        <span class="keyword">if</span>(key === <span class="string">'length'</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="built_in">console</span>.log(target, key, value);</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"更新"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Reflect</span>.set(target, key, value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">proxy.a.b = <span class="number">100</span>;</span><br></pre></td></tr></table></figure>

<p>将递归代理的这个过程抽离出来</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    a: &#123;<span class="attr">b</span>:&#123;<span class="attr">c</span>:&#123;<span class="attr">d</span>: <span class="number">1</span>&#125;&#125;&#125;,</span><br><span class="line">    b: <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> handler = &#123;</span><br><span class="line">    <span class="keyword">get</span>(target, key)&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"get"</span>);</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">typeof</span> target[key] === <span class="string">'object'</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Proxy</span>(target[key], handler); <span class="comment">// 如果是对象就返回这个对象的代理</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Reflect</span>.get(target, key);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="keyword">set</span>(target, key, value)&#123;</span><br><span class="line">        <span class="keyword">if</span>(key === <span class="string">'length'</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"更新"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Reflect</span>.set(target, key, value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(obj, handler)</span><br><span class="line">proxy.a.b = <span class="number">100</span>; <span class="comment">// get 更新</span></span><br><span class="line"><span class="built_in">console</span>.log(obj); <span class="comment">// &#123; a: &#123; b: 100 &#125;, b: 1 &#125;</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>ES6</category>
      </categories>
  </entry>
  <entry>
    <title>... 解构赋值、Set&Map</title>
    <url>/2019/09/04/Desctruction/</url>
    <content><![CDATA[<h2 id="结构赋值"><a href="#结构赋值" class="headerlink" title="结构赋值"></a>结构赋值</h2><p>解构的方式都是根据key来实现的</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 数组</span></span><br><span class="line"><span class="keyword">let</span> arr = [<span class="string">'姓名'</span>,<span class="string">'年龄'</span>];</span><br><span class="line"><span class="keyword">let</span> [name, age] = [<span class="string">'姓名'</span>,<span class="string">'年龄'</span>];</span><br><span class="line"><span class="built_in">console</span>.log(name, age);</span><br><span class="line"><span class="comment">// 执行结果： 姓名 年龄</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> [,age] = [<span class="string">'姓名'</span>,<span class="string">'年龄'</span>];</span><br><span class="line"><span class="built_in">console</span>.log(age);</span><br><span class="line"><span class="comment">// 执行结果： 年龄</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 对象</span></span><br><span class="line"><span class="keyword">let</span> &#123;name,age&#125; = &#123;<span class="attr">name</span>: <span class="string">'加菲'</span>, <span class="attr">age</span>: <span class="number">18</span>&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(name,age);</span><br><span class="line"><span class="comment">// 执行结果： 加菲 18</span></span><br></pre></td></tr></table></figure>

<p>用：来重新命名 用=来赋值默认值</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123;name,<span class="attr">age</span>:age1, addr=<span class="string">"杭州"</span>&#125; = &#123;<span class="attr">name</span>: <span class="string">'加菲'</span>, <span class="attr">age</span>: <span class="number">18</span>&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(name,age1);</span><br><span class="line"><span class="comment">// 执行结果： 加菲 18</span></span><br></pre></td></tr></table></figure>

<a id="more"></a>
<p>剩余运算符 只能用在最后一项</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 数组</span></span><br><span class="line"><span class="keyword">let</span> [name,...args] = [<span class="string">'加菲'</span>, <span class="number">10</span>, <span class="string">'杭州'</span>]; </span><br><span class="line"><span class="built_in">console</span>.log(args);</span><br><span class="line"><span class="comment">// 执行结果： [ 10, '杭州' ]</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 对象</span></span><br><span class="line"><span class="keyword">let</span> &#123;name, ...args&#125; = &#123;<span class="attr">name</span>: <span class="string">'加菲'</span>, <span class="attr">age</span>: <span class="number">18</span>&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(args);</span><br><span class="line"><span class="comment">// 执行结果： &#123; age: 18 &#125;</span></span><br></pre></td></tr></table></figure>

<p>展开运算符</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 数组</span></span><br><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line"><span class="built_in">console</span>.log(...arr); <span class="comment">//可以理解为把[]中间的内容拿出来</span></span><br><span class="line"><span class="comment">// 执行结果：1 2 3</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 对象</span></span><br><span class="line"><span class="keyword">let</span> arr2 = &#123;<span class="attr">name</span>: <span class="string">'加菲'</span>, <span class="attr">age</span>: <span class="number">18</span>&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(...arr2);</span><br><span class="line"><span class="comment">// 这样是不行的，相等于把大括号拿走 打印 console.log(name: '加菲', age: 18);</span></span><br><span class="line"><span class="comment">// 执行结果： Found non-callable @@iterator</span></span><br></pre></td></tr></table></figure>

<p>展开运算符 可以合并数组 合并对象</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 数组</span></span><br><span class="line"><span class="keyword">let</span> a1 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> a2 = [<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>];</span><br><span class="line"><span class="built_in">console</span>.log([...a1,...a2]);</span><br><span class="line"><span class="comment">// 执行结果：[ 1, 2, 3, 4, 5, 6 ]</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 对象</span></span><br><span class="line"><span class="keyword">let</span> a1 = &#123;<span class="attr">a</span>: <span class="number">1</span>&#125;;</span><br><span class="line"><span class="keyword">let</span> a2 = &#123;<span class="attr">b</span>: <span class="number">2</span>&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(&#123;...a1, ...a2&#125;);</span><br><span class="line"><span class="comment">// 执行结果： &#123; a: 1, b: 2 &#125;</span></span><br></pre></td></tr></table></figure>

<h2 id="Set-amp-Map"><a href="#Set-amp-Map" class="headerlink" title="Set &amp; Map"></a>Set &amp; Map</h2><p>set 、 map 是es6中新的数据类型 不能放重复项</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">set</span> = new Set([1,2,3,3]);</span><br><span class="line">console.log(<span class="keyword">set</span>);</span><br><span class="line">// 执行结果： Set &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;  没有key属性</span><br><span class="line"></span><br><span class="line"><span class="comment">// 基本操作：</span></span><br><span class="line"><span class="keyword">set</span>.add(4);</span><br><span class="line"><span class="keyword">set</span>.clear();// 清除</span><br><span class="line"><span class="keyword">set</span>.delete(); // 清除某一项</span><br><span class="line"><span class="keyword">set</span>.entries();</span><br><span class="line"></span><br><span class="line">// <span class="keyword">set</span> 可以被迭代 Symbol.iterator  <span class="keyword">set</span>只有forEach</span><br><span class="line">let <span class="keyword">set</span> = new Set([1,2,3,3]);</span><br><span class="line"> <span class="keyword">set</span>.forEach( item=&gt;&#123;</span><br><span class="line">     <span class="built_in">console</span>.log(item); <span class="comment">// 1 2 3</span></span><br><span class="line"> &#125;)</span><br><span class="line"> <span class="built_in">console</span>.log(<span class="keyword">set</span>.has(1)); // 有没有1 执行结果：true</span><br></pre></td></tr></table></figure>

<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>数组的去重 并集 交集 差集</p>
<h4 id="并集"><a href="#并集" class="headerlink" title="并集"></a>并集</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a1 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> a2 = [<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]; </span><br><span class="line"><span class="comment">// 首先去重</span></span><br><span class="line"><span class="keyword">let</span> s = <span class="keyword">new</span> <span class="built_in">Set</span>([...a1, ...a2]);</span><br><span class="line"><span class="built_in">console</span>.log(s, <span class="keyword">typeof</span> s); <span class="comment">// 现在合并并且去重了，但是现在还是set</span></span><br><span class="line"><span class="comment">// 执行结果：Set &#123; 1, 2, 3, 4, 5, 6 &#125; 'object'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 因为set里面也有Symbol.iterator 可以被迭代 所以可以直接打印</span></span><br><span class="line"><span class="built_in">console</span>.log([...s]); </span><br><span class="line"><span class="comment">// 执行结果： [ 1, 2, 3, 4, 5, 6 ]</span></span><br></pre></td></tr></table></figure>

<h4 id="交集"><a href="#交集" class="headerlink" title="交集"></a>交集</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a1 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> a2 = [<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]; </span><br><span class="line">a1 = <span class="keyword">new</span> <span class="built_in">Set</span>([...a1]);</span><br><span class="line">a2 = <span class="keyword">new</span> <span class="built_in">Set</span>([...a2]);</span><br><span class="line"><span class="keyword">let</span> s1 = [...a2].filter( <span class="function"><span class="params">item</span>=&gt;</span>&#123; <span class="comment">// filter是es5里的 返回的是一个新的数组</span></span><br><span class="line">    <span class="keyword">return</span> a1.has(item);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(s1);</span><br><span class="line"><span class="comment">// 执行结果： [ 1, 2, 3 ]</span></span><br></pre></td></tr></table></figure>

<h4 id="差集"><a href="#差集" class="headerlink" title="差集"></a>差集</h4><p>你有的我没有</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a1 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> a2 = [<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]; </span><br><span class="line">a1 = <span class="keyword">new</span> <span class="built_in">Set</span>([...a1]);</span><br><span class="line">a2 = <span class="keyword">new</span> <span class="built_in">Set</span>([...a2]);</span><br><span class="line"><span class="keyword">let</span> s1 = [...a2].filter( <span class="function"><span class="params">item</span>=&gt;</span>&#123; <span class="comment">// 过滤</span></span><br><span class="line">    <span class="keyword">return</span> !a1.has(item); <span class="comment">// map是映射一个新的数组，但是不会比以前少,所以这里不能用map</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(s1);</span><br><span class="line"><span class="comment">// 执行结果：[ 4, 5, 6 ]</span></span><br></pre></td></tr></table></figure>

<h2 id="对象的结构赋值"><a href="#对象的结构赋值" class="headerlink" title="对象的结构赋值"></a>对象的结构赋值</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> school = &#123;<span class="attr">name</span>: <span class="string">'加菲'</span>, <span class="attr">age</span>: <span class="number">18</span>&#125;;</span><br><span class="line"><span class="keyword">let</span> addr = &#123;<span class="attr">addr</span>: <span class="string">'杭州'</span>&#125;;</span><br><span class="line"><span class="keyword">let</span> newObj = &#123;...school, ...addr&#125;; <span class="comment">// 和数组一样 相当于把&#123;&#125;大括号里面的展开</span></span><br><span class="line"><span class="built_in">console</span>.log(newObj);</span><br><span class="line"><span class="comment">// 执行结果： &#123; name: '加菲', age: 18, addr: '杭州' &#125;</span></span><br></pre></td></tr></table></figure>

<p>如果key 一样 会被后面的值覆盖</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> school = &#123;<span class="attr">name</span>: <span class="string">'加菲'</span>, <span class="attr">age</span>: <span class="number">18</span>&#125;;</span><br><span class="line"><span class="keyword">let</span> addr = &#123;<span class="attr">addr</span>: <span class="string">'杭州'</span>, <span class="attr">age</span>: <span class="number">19</span>&#125;;</span><br><span class="line"><span class="keyword">let</span> newObj = &#123;...school, ...addr&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(newObj);</span><br><span class="line"><span class="comment">//执行结果：&#123; name: '加菲', age: 19, addr: '杭州' &#125;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> school = &#123;<span class="attr">name</span>: <span class="string">'加菲'</span>, <span class="attr">age</span>: <span class="number">18</span>, <span class="attr">a</span>: &#123;<span class="attr">b</span>:<span class="number">1</span>&#125;&#125;;</span><br><span class="line"><span class="keyword">let</span> addr = &#123;<span class="attr">addr</span>: <span class="string">'杭州'</span>, <span class="attr">a</span>: &#123;<span class="attr">b</span>: <span class="number">2</span>&#125;&#125;;</span><br><span class="line"><span class="keyword">let</span> newObj = &#123;...school, ...addr&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(newObj); </span><br><span class="line"><span class="comment">// &#123; name: '加菲', age: 18, a: &#123; b: 2 &#125;, addr: '杭州' &#125;</span></span><br><span class="line"><span class="comment">// 修改</span></span><br><span class="line">newObj.a.b = <span class="number">3</span>;</span><br><span class="line"><span class="built_in">console</span>.log(newObj); </span><br><span class="line"><span class="comment">// &#123; name: '加菲', age: 18, a: &#123; b: 3 &#125;, addr: '杭州' &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(school,addr); </span><br><span class="line"><span class="comment">// &#123; name: '加菲', age: 18, a: &#123; b: 1 &#125; &#125; &#123; addr: '杭州', a: &#123; b: 3 &#125; &#125;</span></span><br></pre></td></tr></table></figure>

<p>这里面 addr里面的值也改变了，因为引用的是同一个地址<br>现在这里是浅拷贝<br>如何实现深拷贝：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// JSON.parse JSON.stringify</span></span><br><span class="line"><span class="keyword">let</span> school = &#123;<span class="attr">name</span>: <span class="string">'加菲'</span>, <span class="attr">age</span>: <span class="number">18</span>, <span class="attr">a</span>: &#123;<span class="attr">b</span>:<span class="number">1</span>&#125;&#125;;</span><br><span class="line"><span class="keyword">let</span> addr = &#123;<span class="attr">addr</span>: <span class="string">'杭州'</span>, <span class="attr">a</span>: &#123;<span class="attr">b</span>: <span class="number">2</span>&#125;&#125;;</span><br><span class="line"><span class="keyword">let</span> newObj = &#123;...school, ...addr&#125;;</span><br><span class="line">newObj = <span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(newObj));</span><br><span class="line">newObj.a.b = <span class="number">3</span>;</span><br><span class="line"><span class="built_in">console</span>.log(newObj); </span><br><span class="line"><span class="comment">// &#123; name: '加菲', age: 18, a: &#123; b: 3 &#125;, addr: '杭州' &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(school,addr);</span><br><span class="line"><span class="comment">// &#123; name: '加菲', age: 18, a: &#123; b: 1 &#125; &#125; &#123; addr: '杭州', a: &#123; b: 2 &#125; &#125;</span></span><br></pre></td></tr></table></figure>

<p>可以实现 但是如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> school = &#123;<span class="attr">name</span>: <span class="string">'加菲'</span>, <span class="attr">age</span>: <span class="number">18</span>, <span class="attr">a</span>: &#123;<span class="attr">b</span>:<span class="number">1</span>&#125;, <span class="attr">b</span>: <span class="function"><span class="params">()</span>=&gt;</span>&#123;&#125;, <span class="attr">c</span>: <span class="literal">undefined</span>, <span class="attr">reg</span>: <span class="regexp">/\d+/</span>&#125;;</span><br><span class="line"><span class="keyword">let</span> addr = &#123;<span class="attr">addr</span>: <span class="string">'杭州'</span>, <span class="attr">a</span>: &#123;<span class="attr">b</span>: <span class="number">2</span>&#125;&#125;;</span><br><span class="line"><span class="keyword">let</span> newObj = &#123;...school, ...addr&#125;;</span><br><span class="line">newObj = <span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(newObj));</span><br><span class="line">newObj.a.b = <span class="number">3</span>;</span><br><span class="line"><span class="built_in">console</span>.log(newObj);</span><br><span class="line"><span class="comment">// &#123; name: '加菲', age: 18, a: &#123; b: 3 &#125;, reg: &#123;&#125;, addr: '杭州' &#125;  b、c没有了，reg也不对</span></span><br><span class="line"><span class="built_in">console</span>.log(school,addr);</span><br><span class="line"><span class="comment">// &#123; name: '加菲', age: 18, a: &#123; b: 1 &#125;, b: [Function: b], c: undefined, reg: /\d+/ &#125;</span></span><br><span class="line"><span class="comment">// &#123; addr: '杭州', a: &#123; b: 2 &#125; &#125;</span></span><br></pre></td></tr></table></figure>

<p>所以说 函数、undefined、正则不能完全拷贝</p>
<h3 id="递归拷贝"><a href="#递归拷贝" class="headerlink" title="递归拷贝"></a>递归拷贝</h3><p>首先要判断数据类型<br>instanceof 可以判断类型 判断是谁的实例<br>constructor 构造函数<br>在控制台打印 ({}).constructor &nbsp;&nbsp;&nbsp;&nbsp;([]).constructor 可以知道它的构造函数是谁 是什么类型的 Object() &nbsp;&nbsp; Array()</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> deepClone = <span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(value == <span class="literal">null</span>) <span class="keyword">return</span> value; <span class="comment">// 这里排除掉了null 和 undefined的情况 </span></span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">typeof</span> value !== <span class="string">'object'</span>) <span class="keyword">return</span> value; <span class="comment">// 这里面包含了函数类型 很少有拷贝函数的，这里先不判断了</span></span><br><span class="line">    <span class="keyword">if</span>(value <span class="keyword">instanceof</span> <span class="built_in">RegExp</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">RegExp</span>(value); <span class="comment">// 这里返回一个新的正则</span></span><br><span class="line">    <span class="keyword">if</span>(value <span class="keyword">instanceof</span> <span class="built_in">Date</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Date</span>(value); </span><br><span class="line">    <span class="comment">// 拷贝的可能是对象或数组 （循环） 数组对象都能循环 for in</span></span><br><span class="line">    <span class="keyword">let</span> instance = <span class="keyword">new</span> value.constructor; <span class="comment">//根据当前属性构造一个新的实例</span></span><br><span class="line">    <span class="comment">//console.log(instance); </span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> key <span class="keyword">in</span> value)&#123;</span><br><span class="line">        <span class="keyword">if</span>(value.hasOwnProperty(key))&#123; <span class="comment">// 拷贝自己的属性 不拷贝原型链上 过滤掉原型链上的属性</span></span><br><span class="line">            <span class="comment">// 当value[key] 有多层</span></span><br><span class="line">            instance[key] = deepClone(value[key]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> a1 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]];</span><br><span class="line"><span class="keyword">let</span> a2 = deepClone([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]]);</span><br><span class="line"><span class="built_in">console</span>.log(a1,a2);</span><br><span class="line"><span class="comment">// [ 1, 2, 3, [ 4, 5, 6 ] ] [ 1, 2, 3, [ 4, 5, 6 ] ]</span></span><br><span class="line">a2[<span class="number">3</span>] = <span class="string">'haha'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a1,a2);</span><br><span class="line"><span class="comment">// [ 1, 2, 3, [ 4, 5, 6 ] ] [ 1, 2, 3, 'haha' ]</span></span><br></pre></td></tr></table></figure>

<p>这样的深拷贝还有问题 会有死循环的可能，如下</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;<span class="attr">b</span>: <span class="number">1</span>&#125;;</span><br><span class="line">obj.b = obj;</span><br><span class="line"><span class="built_in">console</span>.log(deepClone(obj)); <span class="comment">// 这样就死循环了</span></span><br></pre></td></tr></table></figure>

<p>解决 如果obj已经被拷贝一次了，下次在用到obj的时候 直接返回 不用再次拷贝<br>Map:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> newMap = <span class="keyword">new</span> <span class="built_in">Map</span>([[<span class="number">1</span>,<span class="number">2</span>], [<span class="number">3</span>,<span class="number">4</span>]]); <span class="comment">// 存的是键值对的形式  也是不能放重复的项 用法和Set差不多</span></span><br><span class="line"><span class="built_in">console</span>.log(newMap); <span class="comment">// Map &#123; 1 =&gt; 2, 3 =&gt; 4 &#125;</span></span><br></pre></td></tr></table></figure>

<p>现在将key的值变为了一个对象 如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> newMap = <span class="keyword">new</span> <span class="built_in">Map</span>([[&#123;<span class="attr">a</span>: <span class="number">1</span>&#125;,<span class="number">2</span>], [<span class="number">3</span>,<span class="number">4</span>]]); </span><br><span class="line"><span class="built_in">console</span>.log(newMap); <span class="comment">//Map &#123; &#123; a: 1 &#125; =&gt; 2, 3 =&gt; 4 &#125;</span></span><br></pre></td></tr></table></figure>

<p>但是这样会有一个问题 容易造成内存泄漏，如下：<br>新建一个html文件</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">    &lt;head&gt;<span class="xml"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span></span><br><span class="line">    &lt;body&gt;</span><br><span class="line">        &lt;script&gt;</span><br><span class="line">            <span class="class"><span class="keyword">class</span> <span class="title">My</span></span>&#123;</span><br><span class="line">                <span class="keyword">constructor</span>()&#123;</span><br><span class="line">                    <span class="keyword">this</span>.a = <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">let</span> obj = <span class="keyword">new</span> My();</span><br><span class="line">            <span class="keyword">let</span> newMap = <span class="keyword">new</span> <span class="built_in">Map</span>([[obj, <span class="number">2</span>], [<span class="number">3</span>, <span class="number">4</span>]]); <span class="comment">// 这里面key是obj</span></span><br><span class="line">            obj = <span class="literal">null</span>; <span class="comment">// 现在我obj不要了   但是上面newMap里面还用着obj</span></span><br><span class="line">            <span class="comment">// v8 垃圾回收 标记引用 现在obj被引用了2次 line10、line11 在line12的时候把obj的引用去掉了，还有一次，v8是不会把它回收掉的，因为它还在newMap中引用，当newMap销毁的时候才会把它回收 </span></span><br><span class="line">            <span class="comment">// 现在实现以下，用浏览器打开这个页面</span></span><br><span class="line">            <span class="comment">// 打开F12 =&gt; Memory =&gt; 下面有个 Take snapshot拍快照的按钮  点击按钮  之后可以在搜索框里面搜索My 可以搜索到，意思表示这里我执行了line12销毁了，但是line11还在用所以没有销毁</span></span><br><span class="line">            <span class="comment">// 现在把line11注释掉，再浏览器清空 再拍快照 可以发现My没有搜到  这里面搜My是因为比较好找，用对象会找的比较麻烦</span></span><br><span class="line">            <span class="comment">// 现在我们可以换成WeakMap 如下:</span></span><br><span class="line"></span><br><span class="line">            <span class="class"><span class="keyword">class</span> <span class="title">My</span></span>&#123;</span><br><span class="line">                <span class="keyword">constructor</span>()&#123;</span><br><span class="line">                    <span class="keyword">this</span>.a = <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">let</span> obj = <span class="keyword">new</span> My();</span><br><span class="line">            <span class="keyword">let</span> newMap = <span class="keyword">new</span> <span class="built_in">WeakMap</span>([[obj, <span class="number">2</span>]]); <span class="comment">// 弱引用 key只能放对象</span></span><br><span class="line">            obj = <span class="literal">null</span>; </span><br><span class="line">            <span class="comment">// 重新运行下 可以看到 My就没有被搜到了 这里line26 obj被销毁了，line25也被销毁了</span></span><br><span class="line"></span><br><span class="line">        &lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>body&gt;</span><br><span class="line">&lt;<span class="regexp">/html&gt;</span></span><br></pre></td></tr></table></figure>

<p>下面就可以用WeakMap来记录已经被拷贝的值 防止重复拷贝</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> deepClone = <span class="function">(<span class="params">value, hash = <span class="keyword">new</span> <span class="built_in">WeakMap</span>(</span>)) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(value == <span class="literal">null</span>) <span class="keyword">return</span> value; </span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">typeof</span> value !== <span class="string">'object'</span>) <span class="keyword">return</span> value;</span><br><span class="line">    <span class="keyword">if</span>(value <span class="keyword">instanceof</span> <span class="built_in">RegExp</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">RegExp</span>(value);</span><br><span class="line">    <span class="keyword">if</span>(value <span class="keyword">instanceof</span> <span class="built_in">Date</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Date</span>(value); </span><br><span class="line">    <span class="keyword">if</span>(hash.has(value)) <span class="keyword">return</span> hash.get(value); <span class="comment">//先去hash中查看一下是否存在，有就把之前拷贝的值返回</span></span><br><span class="line">    <span class="keyword">let</span> instance = <span class="keyword">new</span> value.constructor;</span><br><span class="line">    hash.set(value, instance); <span class="comment">// 没有就存储</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> key <span class="keyword">in</span> value)&#123;</span><br><span class="line">        <span class="keyword">if</span>(value.hasOwnProperty(key))&#123;</span><br><span class="line">            instance[key] = deepClone(value[key], hash); <span class="comment">// 将hash继续向下传递</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> obj = &#123;<span class="attr">a</span>: <span class="number">1</span>&#125;;</span><br><span class="line">obj.b = obj;</span><br><span class="line"><span class="built_in">console</span>.log(deepClone(obj)); <span class="comment">// &#123; a: 1, b: [Circular] &#125; b是一个引用类型 引用的是自己</span></span><br></pre></td></tr></table></figure>

<h2 id="tips"><a href="#tips" class="headerlink" title="tips:"></a>tips:</h2><p>null == undefined // true&nbsp;&nbsp;&nbsp;&nbsp;null === undefined // false<br>for in 当遍历对象时&nbsp;&nbsp; 只遍历对象自身的和继承的可枚举的属性。 会把.length也当做键值遍历出来</p>
]]></content>
      <categories>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title>var-let-const</title>
    <url>/2019/09/03/var-let-const/</url>
    <content><![CDATA[<p>一阅 1处</p>
<hr>
<h4 id="使用-var-的问题"><a href="#使用-var-的问题" class="headerlink" title="使用 var 的问题"></a>使用 var 的问题</h4><h5 id="1）声明的变量默认声明到全局（会污染全局作用域）"><a href="#1）声明的变量默认声明到全局（会污染全局作用域）" class="headerlink" title="1）声明的变量默认声明到全局（会污染全局作用域）"></a>1）声明的变量默认声明到全局（会污染全局作用域）</h5><p> 作用域分为：全局作用域、函数作用域</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="comment">// window.a; 这是全局作用域中的a</span></span><br><span class="line"><span class="comment">// 当我们想把a放在作用域里面 可以套一个函数</span></span><br></pre></td></tr></table></figure>

<p>let + {}</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> a = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(a);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"外面"</span>, a);</span><br><span class="line"><span class="comment">/* 打印结果： </span></span><br><span class="line"><span class="comment">1  </span></span><br><span class="line"><span class="comment">a is not defined</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// 如上 &#123;&#125;作用域 + let 可以实现一个作用域</span></span><br></pre></td></tr></table></figure>

<a id="more"></a>
<p>var + {}</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a);</span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"外面"</span>, a);</span><br><span class="line"><span class="comment">/* 打印结果： </span></span><br><span class="line"><span class="comment">undefined</span></span><br><span class="line"><span class="comment">外面 1</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// 这里line3 用var声明的变量会导致变量提升， 所以line2可以打印，因为已经声明了，只是line3才赋值，所以没有打印出1</span></span><br></pre></td></tr></table></figure>

<h5 id="2）用var声明的变量会提升-var-function-import-这3种都会导致变量提升，用let声明的变量会绑定到当前作用域-暂存死区"><a href="#2）用var声明的变量会提升-var-function-import-这3种都会导致变量提升，用let声明的变量会绑定到当前作用域-暂存死区" class="headerlink" title="2）用var声明的变量会提升  var function import 这3种都会导致变量提升，用let声明的变量会绑定到当前作用域  暂存死区"></a>2）用var声明的变量会提升  var function import 这3种都会导致变量提升，用let声明的变量会绑定到当前作用域  暂存死区</h5><p>我们希望像如上这样可以报错，因为a还没有声明 所以可以如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a);</span><br><span class="line">    <span class="keyword">let</span> a = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"外面"</span>, a);</span><br><span class="line"><span class="comment">/*打印结果：</span></span><br><span class="line"><span class="comment">line2会报错 ReferenceError: a is not defined</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>var VS let</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// var</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a);</span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"外面"</span>, a);</span><br><span class="line"><span class="comment">// 打印结果： 2  外面 1</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// let</span></span><br><span class="line"><span class="keyword">let</span> a = <span class="number">2</span>;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a);</span><br><span class="line">    <span class="keyword">let</span> a = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"外面"</span>, a);</span><br><span class="line"><span class="comment">/*打印结果：</span></span><br><span class="line"><span class="comment">line4会报错 ReferenceError: a is not defined</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// 可以看出 还是会报错 这是因为用let声明的变量会绑定到当前作用域 当前&#123;&#125;作用域(line3-6)下已经有a了，就不会往上级作用域查找</span></span><br></pre></td></tr></table></figure>

<p>*****当line5注释掉之后，可以看到返回 2  外面 2 向上级作用域查找了</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// let</span></span><br><span class="line"><span class="keyword">let</span> a = <span class="number">2</span>;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a);</span><br><span class="line">	<span class="comment">// let a = 1;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"外面"</span>, a);</span><br><span class="line"><span class="comment">// 执行结果： 2  外面 2</span></span><br></pre></td></tr></table></figure>

<p>当前这个都是es6语法 要把es6转化成es5需要转化器 babel, 就会把let转化为var 就会输出 2    外面 1</p>
<h5 id="3）当var-a-1-var-a-2-时后面的变量会把前面的覆盖掉，如果引用了别人的代码-若变量名相同会把别人的代码覆盖，所以这里用let-可以保证命名不重"><a href="#3）当var-a-1-var-a-2-时后面的变量会把前面的覆盖掉，如果引用了别人的代码-若变量名相同会把别人的代码覆盖，所以这里用let-可以保证命名不重" class="headerlink" title="3）当var a = 1; var a = 2;时后面的变量会把前面的覆盖掉，如果引用了别人的代码 若变量名相同会把别人的代码覆盖，所以这里用let 可以保证命名不重"></a>3）当var a = 1; var a = 2;时后面的变量会把前面的覆盖掉，如果引用了别人的代码 若变量名相同会把别人的代码覆盖，所以这里用let 可以保证命名不重</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">let</span> a = <span class="number">2</span>;</span><br><span class="line"><span class="comment">//执行结果： SyntaxError: Identifier 'a' has already been declared</span></span><br></pre></td></tr></table></figure>

<p>小示例</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> fn = <span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(a);</span><br><span class="line"><span class="comment">// 执行结果： ReferenceError: a is not defined</span></span><br><span class="line"><span class="comment">// 这里这个a不能调用函数，fn可以 这里的a只是改变了这个匿名函数的名称 不能改变他的声明变量</span></span><br></pre></td></tr></table></figure>

<h5 id="4-var-a-1-a-100-var声明的变量可以被更改-希望不被更改用const"><a href="#4-var-a-1-a-100-var声明的变量可以被更改-希望不被更改用const" class="headerlink" title="4) var a = 1; a = 100; var声明的变量可以被更改 希望不被更改用const"></a>4) var a = 1; a = 100; var声明的变量可以被更改 希望不被更改用const</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;&#125;;</span><br><span class="line">obj = <span class="number">1</span>; <span class="comment">// 会报错</span></span><br><span class="line">obj.b = <span class="number">2</span>; <span class="comment">// 不会报错</span></span><br><span class="line"><span class="built_in">console</span>.log(obj);</span><br><span class="line"><span class="comment">// 不改变空间指向的值就不会报错</span></span><br></pre></td></tr></table></figure>

<p>什么时候用const let，  尽可能用const 如果整个值需要改变 则使用let</p>
<h5 id="5-自执行函数可以解决作用域问题"><a href="#5-自执行函数可以解决作用域问题" class="headerlink" title="5) 自执行函数可以解决作用域问题"></a>5) 自执行函数可以解决作用域问题</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i&lt; <span class="number">10</span>; i++)&#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(i);</span><br><span class="line">    &#125;) <span class="comment">// 默认不给时间 是 &gt;=4ms</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 执行结果： 10 10 10 10 10 10 10 10 10 10</span></span><br><span class="line"><span class="comment">// 解决办法  如果是以前会这样</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i&lt; <span class="number">10</span>; i++)&#123;</span><br><span class="line">    (<span class="function"><span class="keyword">function</span>(<span class="params">i</span>)</span>&#123;</span><br><span class="line">        setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(i);</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)(i)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 执行结果：0 1 2 3 4 5 6 7 8 9</span></span><br><span class="line"><span class="comment">// 这里将i放到函数作用域保存起来 所以能够拿到</span></span><br></pre></td></tr></table></figure>

<p>用let的方法解决</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i&lt; <span class="number">10</span>; i++)&#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(i);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 执行结果：0 1 2 3 4 5 6 7 8 9</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>ES6</category>
      </categories>
  </entry>
  <entry>
    <title>Promise</title>
    <url>/2019/08/28/Promise/</url>
    <content><![CDATA[<h3 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h3><p>1) 解决并发问题 （同步的多个异步方法的执行结果 promise.all）<br>2) 解决链式调用问题 （先获取name,再获取age,再获取…）  回调地狱 解决多个回调嵌套的问题(不是完全解决，.then.then也是回调)</p>
<h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>Promise 是一个类</p>
<p>1) 每次new一个 Promise 都需要传递一个执行器，执行器(executor)是立即执行的<br> <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>( <span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">   <span class="built_in">console</span>.log(<span class="string">"init"</span>);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'1'</span>);</span><br><span class="line"><span class="comment">// 这里先执行的是  init  再执行 1</span></span><br><span class="line"><span class="comment">// 结果：init  1</span></span><br></pre></td></tr></table></figure></p>
 <a id="more"></a>
<p>2) 执行器函数中有2个参数 resolve、 reject。<br>3) 默认Primose有3个状态：pedding、fulfilled、rejected。 pedding =&gt; resolve 表示成功 pedding=&gt; reject 表示拒绝。<br>4) 如果一旦成功不能再失败， 一旦失败不能成功了 只有当状态为pending的时候才能改变。<br>5) 每个Promise都有一个then方法。</p>
<h3 id="手写一个Promise"><a href="#手写一个Promise" class="headerlink" title="手写一个Promise"></a>手写一个Promise</h3><p>首先建2个文件 <code>1.promise.js</code>(用于执行一系列操作) <code>promise.js</code>（用于放置手写的Promise）</p>
<h4 id="基础封装"><a href="#基础封装" class="headerlink" title="基础封装"></a>基础封装</h4><p>【1】</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1.promise.js</span></span><br><span class="line"><span class="keyword">let</span> <span class="built_in">Promise</span>= <span class="built_in">require</span>(<span class="string">'./promise'</span>); <span class="comment">// 这里引入的是自己手写的Promise</span></span><br><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    resolve(<span class="string">"我有钱"</span>);</span><br><span class="line">    <span class="comment">//reject("我有钱");</span></span><br><span class="line">    <span class="comment">//throw new Error("失败");</span></span><br><span class="line">&#125;)</span><br><span class="line">p.then(<span class="function"><span class="params">data</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"成功的回调："</span>, data);</span><br><span class="line">&#125;,err=&gt;&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"失败的回调："</span>, err);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 执行结果：line4 成功的回调：我有钱</span></span><br><span class="line"><span class="comment">// 执行结果：line5 失败的回调：我有钱</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// promise.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> PENDING = <span class="string">'PENDING'</span>;</span><br><span class="line"><span class="keyword">const</span> FULFILLED = <span class="string">'FULFILLED'</span>;</span><br><span class="line"><span class="keyword">const</span> REJECTED = <span class="string">'REJECTED'</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Promise</span></span>&#123;</span><br><span class="line">    <span class="comment">//1) 每次new一个 Promise 都需要传递一个执行器，执行器(executor)是立即执行的</span></span><br><span class="line">    <span class="keyword">constructor</span>(executor)&#123;</span><br><span class="line">	<span class="comment">// 不能用let 要如下 放在实例中 为了能在1.promise.js line4-5调用的时候把对应的成功的值和失败的值在line9、line11同样能拿到</span></span><br><span class="line">        <span class="comment">// let value; </span></span><br><span class="line">        <span class="comment">// let reason; </span></span><br><span class="line">        <span class="keyword">this</span>.value = <span class="literal">undefined</span>;</span><br><span class="line">        <span class="keyword">this</span>.reason = <span class="literal">undefined</span>;</span><br><span class="line">        <span class="keyword">this</span>.status = PENDING;</span><br><span class="line">        <span class="keyword">let</span> resolve = <span class="function">(<span class="params">value</span>) =&gt;</span> &#123; </span><br><span class="line">            <span class="keyword">this</span>.value = value;</span><br><span class="line">            <span class="keyword">this</span>.status = FULFILLED;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">let</span> reject = <span class="function">(<span class="params">reason</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.reason = reason;</span><br><span class="line">            <span class="keyword">this</span>.status = REJECTED;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 创建promise executor会立即执行</span></span><br><span class="line">        <span class="comment">// 2) 执行器函数中有2个参数 resolve,reject</span></span><br><span class="line">        executor(resolve, reject); <span class="comment">// 且可以知道这2个参数是两个函数所以let resolve reject</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如1.promise.jsline8 每个实例上还有then方法</span></span><br><span class="line">	<span class="comment">// then方法会判断当前的状态</span></span><br><span class="line">    then(onFulfilled, onRejected)&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.status === FULFILLED)&#123;</span><br><span class="line">            onFulfilled(<span class="keyword">this</span>.value);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.status === REJECTED)&#123;</span><br><span class="line">            onRejected(<span class="keyword">this</span>.reason);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 导出当前类 commonjs定义方式</span></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="built_in">Promise</span>;</span><br></pre></td></tr></table></figure>

<p>【1】中，<code>1.promise.js</code>依次取消注释执行line4、5</p>
<hr>
<p>【2】<br>当执行<code>1.promise.js</code>中line6时</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"失败"</span>);</span><br></pre></td></tr></table></figure>

<p>需要做异常处理：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// promise.js</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Promise</span></span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(executor)&#123;</span><br><span class="line">        <span class="keyword">this</span>.value = <span class="literal">undefined</span>;</span><br><span class="line">        <span class="keyword">this</span>.reason = <span class="literal">undefined</span>;</span><br><span class="line">        <span class="keyword">this</span>.status = PENDING;</span><br><span class="line">        <span class="keyword">let</span> resolve = <span class="function">(<span class="params">value</span>) =&gt;</span> &#123; </span><br><span class="line">            <span class="keyword">this</span>.value = value;</span><br><span class="line">            <span class="keyword">this</span>.status = FULFILLED;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">let</span> reject = <span class="function">(<span class="params">reason</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.reason = reason;</span><br><span class="line">            <span class="keyword">this</span>.status = REJECTED;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span>&#123; <span class="comment">// 注意 同步操作是可以用try catch来捕获的</span></span><br><span class="line">            executor(resolve, reject);</span><br><span class="line">        &#125;<span class="keyword">catch</span>(e)&#123;</span><br><span class="line">            reject(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    then(onFulfilled, onRejected)&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.status === FULFILLED)&#123;</span><br><span class="line">            onFulfilled(<span class="keyword">this</span>.value);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.status === REJECTED)&#123;</span><br><span class="line">            onRejected(<span class="keyword">this</span>.reason);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">module</span>.exports = <span class="built_in">Promise</span>;</span><br></pre></td></tr></table></figure>

<p>这时候执行<code>1.promise.js</code>line6 就能在line11捕获输出，执行结果： 失败的回调 Error: 失败</p>
<hr>
<p>【3】<br>当同时打开<code>1.promise.js</code>line4、6或line5、6时，执行结果都是  失败的回调 Error: 失败，这里不符合分析的第4点，<br>只有当状态为pending时才能改变状态</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// promise.js</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Promise</span></span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(executor)&#123;</span><br><span class="line">        <span class="keyword">this</span>.value = <span class="literal">undefined</span>;</span><br><span class="line">        <span class="keyword">this</span>.reason = <span class="literal">undefined</span>;</span><br><span class="line">        <span class="keyword">this</span>.status = PENDING;</span><br><span class="line">        <span class="keyword">let</span> resolve = <span class="function">(<span class="params">value</span>) =&gt;</span> &#123; </span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">this</span>.status === PENDING)&#123; <span class="comment">// 4)如果一旦成功不能再失败，只有当状态为pending的时候才能改变</span></span><br><span class="line">                <span class="keyword">this</span>.value = value;</span><br><span class="line">                <span class="keyword">this</span>.status = FULFILLED;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">let</span> reject = <span class="function">(<span class="params">reason</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">this</span>.status === PENDING)&#123; <span class="comment">// 4)如果一旦失败不能再成功 只有当状态为pending的时候才能改变</span></span><br><span class="line">                <span class="keyword">this</span>.reason = reason;</span><br><span class="line">                <span class="keyword">this</span>.status = REJECTED;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            executor(resolve, reject);</span><br><span class="line">        &#125;<span class="keyword">catch</span>(e)&#123;</span><br><span class="line">            reject(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    then(onFulfilled, onRejected)&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.status === FULFILLED)&#123;</span><br><span class="line">            onFulfilled(<span class="keyword">this</span>.value);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.status === REJECTED)&#123;</span><br><span class="line">            onRejected(<span class="keyword">this</span>.reason);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">module</span>.exports = <span class="built_in">Promise</span>;</span><br></pre></td></tr></table></figure>

<p>【4】<br> 查看文档 <a href="https://promisesaplus.com/" target="_blank" rel="noopener">https://promisesaplus.com/</a>   promises/A+<br><code>2.2.6</code> then may be called multiple times on the same promise  相同的promise被多次调用then</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1.promise.js</span></span><br><span class="line"><span class="keyword">let</span> <span class="built_in">Promise</span>= <span class="built_in">require</span>(<span class="string">'./promise'</span>);</span><br><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    resolve(<span class="string">"我有钱"</span>);</span><br><span class="line">    reject(<span class="string">"我有钱"</span>);</span><br><span class="line">    <span class="comment">//throw new Error("失败");</span></span><br><span class="line">&#125;)</span><br><span class="line">p.then(<span class="function"><span class="params">data</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"成功的回调"</span>, data);</span><br><span class="line">&#125;,err=&gt;&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"失败的回调"</span>, err);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">p.then(<span class="function"><span class="params">data</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"成功的回调"</span>, data);</span><br><span class="line">&#125;,err=&gt;&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"失败的回调"</span>, err);</span><br><span class="line">&#125;)</span><br><span class="line">p.then(<span class="function"><span class="params">data</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"成功的回调"</span>, data);</span><br><span class="line">&#125;,err=&gt;&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"失败的回调"</span>, err);</span><br><span class="line">&#125;)</span><br><span class="line">p.then(<span class="function"><span class="params">data</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"成功的回调"</span>, data);</span><br><span class="line">&#125;,err=&gt;&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"失败的回调"</span>, err);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 执行结果: </span></span><br><span class="line"><span class="comment">// 成功的回调 我有钱</span></span><br><span class="line"><span class="comment">// 成功的回调 我有钱</span></span><br><span class="line"><span class="comment">// 成功的回调 我有钱</span></span><br><span class="line"><span class="comment">// 成功的回调 我有钱</span></span><br><span class="line"><span class="comment">// 多个成功回调  用原生的Promise执行结果也一样 这里面p.then p是一样的</span></span><br></pre></td></tr></table></figure>

<p>【5】<br>当<code>1.promise.js</code>改成如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1.promise.js</span></span><br><span class="line"><span class="keyword">let</span> <span class="built_in">Promise</span>= <span class="built_in">require</span>(<span class="string">'./promise'</span>);</span><br><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">	<span class="comment">// 这里执行的是异步操作时</span></span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        resolve(<span class="string">"我有钱"</span>);</span><br><span class="line">    &#125;, <span class="number">0</span>);    </span><br><span class="line">&#125;)</span><br><span class="line">p.then(<span class="function"><span class="params">data</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"成功的回调"</span>, data);</span><br><span class="line">&#125;,err=&gt;&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"失败的回调"</span>, err);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">p.then(<span class="function"><span class="params">data</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"成功的回调"</span>, data);</span><br><span class="line">&#125;,err=&gt;&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"失败的回调"</span>, err);</span><br><span class="line">&#125;)</span><br><span class="line">p.then(<span class="function"><span class="params">data</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"成功的回调"</span>, data);</span><br><span class="line">&#125;,err=&gt;&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"失败的回调"</span>, err);</span><br><span class="line">&#125;)</span><br><span class="line">p.then(<span class="function"><span class="params">data</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"成功的回调"</span>, data);</span><br><span class="line">&#125;,err=&gt;&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"失败的回调"</span>, err);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>自己写的和原生的结果不同，原生的会等到异步执行结束再执行then，而自己写的直接执行的then导致没有内容输出，<br>当前执行异步时状态是pending  而我们这里then函数中PENDING状态还未写，如下修改：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// promise.js</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Promise</span></span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(executor)&#123;</span><br><span class="line">        <span class="keyword">this</span>.value = <span class="literal">undefined</span>;</span><br><span class="line">        <span class="keyword">this</span>.reason = <span class="literal">undefined</span>;</span><br><span class="line">        <span class="keyword">this</span>.status = PENDING;</span><br><span class="line">        <span class="comment">// 2个数组存储</span></span><br><span class="line">        <span class="keyword">this</span>.onResolvedCallbacks = [];</span><br><span class="line">        <span class="keyword">this</span>.onRejectedCallbacks = [];</span><br><span class="line">        <span class="keyword">let</span> resolve = <span class="function">(<span class="params">value</span>) =&gt;</span> &#123; </span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">this</span>.status === PENDING)&#123; </span><br><span class="line">                <span class="keyword">this</span>.value = value;</span><br><span class="line">                <span class="keyword">this</span>.status = FULFILLED;</span><br><span class="line">                <span class="comment">// 发布</span></span><br><span class="line">                <span class="keyword">this</span>.onResolvedCallbacks.forEach(<span class="function"><span class="params">fn</span> =&gt;</span> fn());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">let</span> reject = <span class="function">(<span class="params">reason</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">this</span>.status === PENDING)&#123;</span><br><span class="line">                <span class="keyword">this</span>.reason = reason;</span><br><span class="line">                <span class="keyword">this</span>.status = REJECTED;</span><br><span class="line">                <span class="comment">// 发布</span></span><br><span class="line">                <span class="keyword">this</span>.onRejectedCallbacks.forEach(<span class="function"><span class="params">fn</span> =&gt;</span> fn());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            executor(resolve, reject);</span><br><span class="line">        &#125;<span class="keyword">catch</span>(e)&#123;</span><br><span class="line">            reject(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    then(onFulfilled, onRejected)&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.status === FULFILLED)&#123;</span><br><span class="line">            onFulfilled(<span class="keyword">this</span>.value);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.status === REJECTED)&#123;</span><br><span class="line">            onRejected(<span class="keyword">this</span>.reason);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.status === PENDING)&#123;</span><br><span class="line">            <span class="comment">//可以直接push 但如果有其他todo 所以用下面的方式</span></span><br><span class="line">            <span class="comment">//this.onResolvedCallbacks.push(onFulfilled(this.value));</span></span><br><span class="line">            <span class="keyword">this</span>.onResolvedCallbacks.push(<span class="function"><span class="params">()</span>=&gt;</span>&#123; <span class="comment">// 订阅的过程 存储</span></span><br><span class="line">                <span class="comment">//todo</span></span><br><span class="line">                onFulfilled(<span class="keyword">this</span>.value);</span><br><span class="line">            &#125;)</span><br><span class="line">            <span class="keyword">this</span>.onRejectedCallbacks.push(<span class="function"><span class="params">()</span>=&gt;</span>&#123; <span class="comment">// 订阅的过程</span></span><br><span class="line">                <span class="comment">//todo</span></span><br><span class="line">                onRejected(<span class="keyword">this</span>.reason);</span><br><span class="line">            &#125;)</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">module</span>.exports = <span class="built_in">Promise</span>;</span><br><span class="line"><span class="comment">// 执行结果：</span></span><br><span class="line"><span class="comment">// 成功的回调 我有钱</span></span><br><span class="line"><span class="comment">// 成功的回调 我有钱</span></span><br><span class="line"><span class="comment">// 成功的回调 我有钱</span></span><br><span class="line"><span class="comment">// 成功的回调 我有钱</span></span><br></pre></td></tr></table></figure>

<p> 这就是典型的发布订阅 当<code>1.promise.js</code> line4-7执行状态为pending时，p.then()里面的方法先存起来，等到定时器里面resolve的时候依次执行。<br> 概括 订阅：弄个数组 存起来 ； 发布：将存起来的数组里面的内容执行一遍。<br> 所以现在相当于<code>1.promise.js</code>line9-29在订阅 line6在发布<br> 这就是同步的时候直接触发，异步的时候发布订阅</p>
<hr>
<h4 id="链式调用（应用）"><a href="#链式调用（应用）" class="headerlink" title="链式调用（应用）"></a>链式调用（应用）</h4><p> 现在的需求：读取name中的值 再读取age中的值， 以前的做法如下：<br> <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line">fs.readFile(__dirname + <span class="string">'/name.txt'</span>, <span class="string">'utf8'</span>, (err, data)=&gt;&#123;</span><br><span class="line">    <span class="keyword">if</span>(err)&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(err);</span><br><span class="line">    &#125;</span><br><span class="line">    fs.readFile(__dirname + <span class="string">'/age.txt'</span>, <span class="string">'utf8'</span>, (err, data)=&gt;&#123;</span><br><span class="line">        <span class="keyword">if</span>(err)&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(err);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p>现在用promise做法如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">readFile</span>(<span class="params">...args</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        fs.readFile(...args, (err, data)=&gt;&#123;</span><br><span class="line">            <span class="keyword">if</span>(err) reject(err);</span><br><span class="line">            resolve(data);</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line">readFile(__dirname + <span class="string">'/name.txt'</span>, <span class="string">'utf8'</span>).then(<span class="function"><span class="params">data</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(data);</span><br><span class="line">&#125;,err=&gt;&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>成功之后不通过回调，而是通过then<br>readFile(__dirname + ‘/name.txt’, ‘utf8’) 返回的是Promise实例，记住 能then的就是Promise实例<br>如果需要改造成Promise 就先将回调的方法 改成Promise<br>完整代码如下：<br>【1】then方法中返回： 1) 普通值</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">readFile</span>(<span class="params">...args</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        fs.readFile(...args, (err, data)=&gt;&#123;</span><br><span class="line">            <span class="keyword">if</span>(err) reject(err);</span><br><span class="line">            resolve(data);</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Promsie链式调用</span></span><br><span class="line"><span class="comment">// then方法中返回： 1) 普通值 指不是promise也不报错 如line14 它会把值传到then的外层如line18</span></span><br><span class="line">readFile(__dirname + <span class="string">'/name.txt'</span>, <span class="string">'utf8'</span>).then(<span class="function"><span class="params">data</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="comment">//console.log(data);</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;,err=&gt;&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err);</span><br><span class="line">&#125;).then(<span class="function"><span class="params">data</span>=&gt;</span>&#123; <span class="comment">// step: 1</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"successline18:"</span>, data);</span><br><span class="line">    <span class="comment">//throw new Error('err'); //step: 2 + 3  // 想让下一个then走失败 需要 1）返回一个失败的promise 或者抛出一个异常</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        reject(<span class="string">'err'</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;,err=&gt;&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'errline24:'</span>, err);</span><br><span class="line">&#125;) </span><br><span class="line">.then(<span class="function"><span class="params">data</span>=&gt;</span>&#123; <span class="comment">// step: 2</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"successline27:"</span>, data);</span><br><span class="line">&#125;,err=&gt;&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'errline29:'</span>, err);</span><br><span class="line">&#125;) </span><br><span class="line">.then(<span class="function"><span class="params">data</span>=&gt;</span>&#123;  <span class="comment">// step: 3</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"successline32:"</span>, data);</span><br><span class="line">&#125;,err=&gt;&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'errline34:'</span>, err);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>step1: line12 then里面返回的line14 它会把值传到then的外层到line18  可以看到打印结果： successline18: false<br>step2： 第一步走的成功 希望能走失败，现加入了line19 或line20-22  结果： line29<br>step3: 可以看到经历了第二步的失败 第三部从line29打印出来 失败也可以变成成功 结果：line32</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 打印结果：</span></span><br><span class="line">successline18: <span class="literal">false</span></span><br><span class="line">errline29: err</span><br><span class="line">successline32: <span class="literal">undefined</span></span><br><span class="line"><span class="comment">// 如果line19执行，line20-22注释</span></span><br><span class="line"><span class="comment">// 打印结果</span></span><br><span class="line">successline18: <span class="literal">false</span></span><br><span class="line">errline29: <span class="built_in">Error</span>: err</span><br><span class="line">    at readFile.then.then.data (e:\.....js:<span class="number">20</span>:<span class="number">11</span>)</span><br><span class="line">successline32: <span class="literal">undefined</span></span><br></pre></td></tr></table></figure>

<p>【2】then方法中返回： 2) 返回的是一个promise</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">readFile</span>(<span class="params">...args</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        fs.readFile(...args, (err, data)=&gt;&#123;</span><br><span class="line">            <span class="keyword">if</span>(err) reject(err);</span><br><span class="line">            resolve(data);</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line">readFile(__dirname + <span class="string">'/name.txt'</span>, <span class="string">'utf8'</span>).then(<span class="function"><span class="params">data</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="comment">// 这里先调用name 成功之后 再调用age 如下</span></span><br><span class="line">    <span class="comment">// 返回的是一个promise 则会执行 并根据状态 走外层then方法 line15</span></span><br><span class="line">    <span class="keyword">return</span> readFile(__dirname + <span class="string">'/age.txt'</span>, <span class="string">'utf8'</span>); </span><br><span class="line">&#125;)</span><br><span class="line">.then(<span class="function"><span class="params">data</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(data);</span><br><span class="line">&#125;,err=&gt;&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'err:'</span>, err);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 执行结果： 18（age.txt里面的内容）</span></span><br></pre></td></tr></table></figure>

<p>所以可以用这种方式来解决回调嵌套的问题 并且很容易捕获到错误<br>并且当line10读取报错（假设读取的是‘/name11.txt’），首先找then自身的错误处理，这里line14没有错误处理就找下一个line18去输出， 同样的line13读取报错（假设读取的是‘/age.txt123’）也可以在line18获取</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 如果这里line4-6添加了err</span></span><br><span class="line">readFile(__dirname + <span class="string">'/name.txt11'</span>, <span class="string">'utf8'</span>).then(<span class="function"><span class="params">data</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> readFile(__dirname + <span class="string">'/age.txt'</span>, <span class="string">'utf8'</span>); </span><br><span class="line">&#125;,err=&gt;&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(err);</span><br><span class="line">&#125;)</span><br><span class="line">.then(<span class="function"><span class="params">data</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(data);</span><br><span class="line">&#125;,err=&gt;&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'err:'</span>, err);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// line5输出报错信息</span></span><br><span class="line"><span class="comment">// line8 undefined</span></span><br></pre></td></tr></table></figure>

<p>总结：<br>链式调用 如果返回一个普通值 会走下一个then的成功<br>抛出错误 走then失败的方法<br>如果是promise 就让promise执行 采用它的状态<br><code>是返回了一个新的promise 来实现链式调用</code> </p>
<hr>
<h4 id="继续封装-链式调用"><a href="#继续封装-链式调用" class="headerlink" title="继续封装 链式调用"></a>继续封装 链式调用</h4><p>【6】<br> 当一个promise的then方法中返回了一个普通值, 会将这个普通纸传到外层then的回调里 如下面的line6<br> 这里p这个promise调用p.then之后返回的是一个新的promsie</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1.promsie.js</span></span><br><span class="line"><span class="keyword">const</span> <span class="built_in">Promise</span>  = <span class="built_in">require</span>(<span class="string">'./promise'</span>);</span><br><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    resolve(<span class="string">'hello'</span>)</span><br><span class="line">&#125;)</span><br><span class="line">p.then(<span class="function"><span class="params">data</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> data;</span><br><span class="line">    <span class="comment">//throw new Error('err');</span></span><br><span class="line">&#125;).then(<span class="function"><span class="params">data</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"成功："</span>,data)</span><br><span class="line">&#125;,err=&gt;&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'err:'</span>, err);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 执行结果： 成功： hello</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这里p这个promise调用p.then之后返回的是一个新的promsie</span></span><br><span class="line">p.then(<span class="function"><span class="params">data</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> data;</span><br><span class="line">    <span class="comment">//throw new Error('err');</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>所以这里面<code>promise.js</code>改为：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// promise.js</span></span><br><span class="line"><span class="comment">/**********************************这部分line35-41 只展示了成功的情况 后面会将3种状态都加进去*************/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Promise</span></span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(executor)&#123;</span><br><span class="line">        <span class="keyword">this</span>.value = <span class="literal">undefined</span>;</span><br><span class="line">        <span class="keyword">this</span>.reason = <span class="literal">undefined</span>;</span><br><span class="line">        <span class="keyword">this</span>.status = PENDING;</span><br><span class="line">        <span class="comment">// 2个数组存储</span></span><br><span class="line">        <span class="keyword">this</span>.onResolvedCallbacks = [];</span><br><span class="line">        <span class="keyword">this</span>.onRejectedCallbacks = [];</span><br><span class="line">        <span class="keyword">let</span> resolve = <span class="function">(<span class="params">value</span>) =&gt;</span> &#123; </span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">this</span>.status === PENDING)&#123; </span><br><span class="line">                <span class="keyword">this</span>.value = value;</span><br><span class="line">                <span class="keyword">this</span>.status = FULFILLED;</span><br><span class="line">                <span class="comment">// 发布</span></span><br><span class="line">                <span class="keyword">this</span>.onResolvedCallbacks.forEach(<span class="function"><span class="params">fn</span> =&gt;</span> fn());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">let</span> reject = <span class="function">(<span class="params">reason</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">this</span>.status === PENDING)&#123;</span><br><span class="line">                <span class="keyword">this</span>.reason = reason;</span><br><span class="line">                <span class="keyword">this</span>.status = REJECTED;</span><br><span class="line">                <span class="comment">// 发布</span></span><br><span class="line">                <span class="keyword">this</span>.onRejectedCallbacks.forEach(<span class="function"><span class="params">fn</span> =&gt;</span> fn());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            executor(resolve, reject);</span><br><span class="line">        &#125;<span class="keyword">catch</span>(e)&#123;</span><br><span class="line">            reject(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    then(onFulfilled, onRejected)&#123;</span><br><span class="line">        <span class="comment">// then 方法调用后 会返回一个新的promise</span></span><br><span class="line">        <span class="keyword">let</span> promise2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="comment">// 先以成功为例 1.promise.js line6-9 这个成功的方法里面 注释line8</span></span><br><span class="line">            <span class="comment">// 首先拿到它的结果 line6 data</span></span><br><span class="line">            <span class="keyword">let</span> x = onFulfilled(<span class="keyword">this</span>.value); <span class="comment">// 这里的this.value就是data</span></span><br><span class="line">            <span class="comment">// line7 再将这个结果返回   </span></span><br><span class="line">            resolve(x); <span class="comment">// return data;</span></span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="keyword">return</span> promise2;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.status === FULFILLED)&#123;</span><br><span class="line">            onFulfilled(<span class="keyword">this</span>.value);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.status === REJECTED)&#123;</span><br><span class="line">            onRejected(<span class="keyword">this</span>.reason);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.status === PENDING)&#123;</span><br><span class="line">            <span class="keyword">this</span>.onResolvedCallbacks.push(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">                <span class="comment">//todo</span></span><br><span class="line">                onFulfilled(<span class="keyword">this</span>.value);</span><br><span class="line">            &#125;)</span><br><span class="line">            <span class="keyword">this</span>.onRejectedCallbacks.push(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">                <span class="comment">//todo</span></span><br><span class="line">                onRejected(<span class="keyword">this</span>.reason);</span><br><span class="line">            &#125;)</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">module</span>.exports = <span class="built_in">Promise</span>;</span><br></pre></td></tr></table></figure>

<p>现在将<code>1.promise.js</code>中line6注释，line7打开</p>
<p><code>promise.js</code>代码中需要捕获错误，如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Promise</span></span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(executor)&#123;</span><br><span class="line">        <span class="keyword">this</span>.value = <span class="literal">undefined</span>;</span><br><span class="line">        <span class="keyword">this</span>.reason = <span class="literal">undefined</span>;</span><br><span class="line">        <span class="keyword">this</span>.status = PENDING;</span><br><span class="line">        <span class="comment">// 2个数组存储</span></span><br><span class="line">        <span class="keyword">this</span>.onResolvedCallbacks = [];</span><br><span class="line">        <span class="keyword">this</span>.onRejectedCallbacks = [];</span><br><span class="line">        <span class="keyword">let</span> resolve = <span class="function">(<span class="params">value</span>) =&gt;</span> &#123; </span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">this</span>.status === PENDING)&#123; </span><br><span class="line">                <span class="keyword">this</span>.value = value;</span><br><span class="line">                <span class="keyword">this</span>.status = FULFILLED;</span><br><span class="line">                <span class="comment">// 发布</span></span><br><span class="line">                <span class="keyword">this</span>.onResolvedCallbacks.forEach(<span class="function"><span class="params">fn</span> =&gt;</span> fn());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">let</span> reject = <span class="function">(<span class="params">reason</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">this</span>.status === PENDING)&#123;</span><br><span class="line">                <span class="keyword">this</span>.reason = reason;</span><br><span class="line">                <span class="keyword">this</span>.status = REJECTED;</span><br><span class="line">                <span class="comment">// 发布</span></span><br><span class="line">                <span class="keyword">this</span>.onRejectedCallbacks.forEach(<span class="function"><span class="params">fn</span> =&gt;</span> fn());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            executor(resolve, reject);</span><br><span class="line">        &#125;<span class="keyword">catch</span>(e)&#123;</span><br><span class="line">            reject(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    then(onFulfilled, onRejected)&#123;</span><br><span class="line">        <span class="keyword">let</span> promise2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">this</span>.status === FULFILLED)&#123;</span><br><span class="line">                  <span class="comment">// 如果promise.js line8 抛出错误</span></span><br><span class="line">                <span class="keyword">try</span> &#123; </span><br><span class="line">                    <span class="keyword">let</span> x = onFulfilled(<span class="keyword">this</span>.value); <span class="comment">// 让then中的方法执行 拿到它的返回值</span></span><br><span class="line">                    resolve(x);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">                    reject(error)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">this</span>.status === REJECTED)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;   </span><br><span class="line">                    <span class="keyword">let</span> x = onRejected(<span class="keyword">this</span>.reason);</span><br><span class="line">                    reject(x);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">                    reject(error)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">this</span>.status === PENDING)&#123;</span><br><span class="line">                <span class="keyword">this</span>.onResolvedCallbacks.push(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">                    <span class="comment">//todo</span></span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="keyword">let</span> x = onFulfilled(<span class="keyword">this</span>.value);</span><br><span class="line">                        resolve(x);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">                        reject(error)</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;)</span><br><span class="line">                <span class="keyword">this</span>.onRejectedCallbacks.push(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">                    <span class="comment">//todo</span></span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="keyword">let</span> x = onRejected(<span class="keyword">this</span>.reason);</span><br><span class="line">                        reject(x);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">                        reject(error)</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="keyword">return</span> promise2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">module</span>.exports = <span class="built_in">Promise</span>;</span><br></pre></td></tr></table></figure>

<p>【7】<br> 当一个promise的then中返回一个promise<br> <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1.promise.js</span></span><br><span class="line"><span class="keyword">const</span> <span class="built_in">Promise</span>  = <span class="built_in">require</span>(<span class="string">'./promise'</span>);</span><br><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        resolve(<span class="string">'hello'</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;)</span><br><span class="line">p.then(<span class="function"><span class="params">data</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>( <span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            resolve(<span class="string">"word"</span>)</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;).then(<span class="function"><span class="params">data</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"成功："</span>,data)</span><br><span class="line">&#125;,err=&gt;&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'err:'</span>, err);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 调用当前的promise.js</span></span><br><span class="line"><span class="comment">// 执行结果：</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">成功： Promise &#123;</span></span><br><span class="line"><span class="comment">  value: undefined,</span></span><br><span class="line"><span class="comment">  reason: undefined,</span></span><br><span class="line"><span class="comment">  status: 'PENDING',</span></span><br><span class="line"><span class="comment">  onResolvedCallbacks: [],</span></span><br><span class="line"><span class="comment">  onRejectedCallbacks: [] &#125; </span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></p>
<p> 会把状态为PENDING状态的结果返回到line14的data<br> <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">new</span> <span class="built_in">Promise</span>( <span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        resolve(<span class="string">"word"</span>)</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 会直接把这个值传递给 data 也就是x 是个等待状态</span></span><br></pre></td></tr></table></figure></p>
<p>我们希望的是能把返回值里面的promise执行完之后再传到then<br>所以现在需要判断x是否为promise<br>这里可以看 <code>promises/A+</code> 里面2.2.7   resolvePromise ， promise的处理函数</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// promise.js</span></span><br><span class="line"><span class="keyword">const</span> resolvePromise = <span class="function">(<span class="params">promise2, x, resolve, reject</span>) =&gt;</span> &#123; <span class="comment">// promise的处理函数</span></span><br><span class="line">    resolve(x);</span><br><span class="line">    <span class="comment">// 处理x类型 来决定是调用resolve 还是reject</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Promise</span></span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(executor)&#123;</span><br><span class="line">        <span class="keyword">this</span>.value = <span class="literal">undefined</span>;</span><br><span class="line">        <span class="keyword">this</span>.reason = <span class="literal">undefined</span>;</span><br><span class="line">        <span class="keyword">this</span>.status = PENDING;</span><br><span class="line">        <span class="comment">// 2个数组存储</span></span><br><span class="line">        <span class="keyword">this</span>.onResolvedCallbacks = [];</span><br><span class="line">        <span class="keyword">this</span>.onRejectedCallbacks = [];</span><br><span class="line">        <span class="keyword">let</span> resolve = <span class="function">(<span class="params">value</span>) =&gt;</span> &#123; </span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">this</span>.status === PENDING)&#123; </span><br><span class="line">                <span class="keyword">this</span>.value = value;</span><br><span class="line">                <span class="keyword">this</span>.status = FULFILLED;</span><br><span class="line">                <span class="comment">// 发布</span></span><br><span class="line">                <span class="keyword">this</span>.onResolvedCallbacks.forEach(<span class="function"><span class="params">fn</span> =&gt;</span> fn());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">let</span> reject = <span class="function">(<span class="params">reason</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">this</span>.status === PENDING)&#123;</span><br><span class="line">                <span class="keyword">this</span>.reason = reason;</span><br><span class="line">                <span class="keyword">this</span>.status = REJECTED;</span><br><span class="line">                <span class="comment">// 发布</span></span><br><span class="line">                <span class="keyword">this</span>.onRejectedCallbacks.forEach(<span class="function"><span class="params">fn</span> =&gt;</span> fn());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            executor(resolve, reject);</span><br><span class="line">        &#125;<span class="keyword">catch</span>(e)&#123;</span><br><span class="line">            reject(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    then(onFulfilled, onRejected)&#123;</span><br><span class="line">        <span class="keyword">let</span> promise2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">this</span>.status === FULFILLED)&#123;</span><br><span class="line">				<span class="comment">// 如promises/A+ 2.2.4，当前onFulfilled、onRejected不能在当前上下文中执行，为了确保promise2存在</span></span><br><span class="line">                setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;<span class="comment">// 当前line43拿到的是promsie2的值，在line37被定义的，直接在line44是拿不到的 所以这里加了一个定时器，让中间这段代码变成异步的，这样会等待line37new完Promise之后再拿到promise2</span></span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="keyword">let</span> x = onFulfilled(<span class="keyword">this</span>.value); <span class="comment">// 问题：这里的x是promise 等待状态的值</span></span><br><span class="line">                        <span class="comment">//resolve(x);</span></span><br><span class="line">                        resolvePromise(promise2, x, resolve, reject);</span><br><span class="line">						<span class="comment">// 这里要拿x的值来判断promise2是成功还是失败，所以这里要把x、promsie2都传过去</span></span><br><span class="line">                    &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">                        reject(error)</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">this</span>.status === REJECTED)&#123;</span><br><span class="line">                setTimeout( <span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;   </span><br><span class="line">                        <span class="keyword">let</span> x = onRejected(<span class="keyword">this</span>.reason);</span><br><span class="line">                        <span class="comment">//reject(x);</span></span><br><span class="line">                        resolvePromise(promise2, x, resolve, reject);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">                        reject(error)</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">this</span>.status === PENDING)&#123;</span><br><span class="line">                <span class="keyword">this</span>.onResolvedCallbacks.push(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">                    <span class="comment">//todo</span></span><br><span class="line">                    setTimeout( <span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            <span class="keyword">let</span> x = onFulfilled(<span class="keyword">this</span>.value);</span><br><span class="line">                            <span class="comment">//resolve(x);</span></span><br><span class="line">                            resolvePromise(promise2, x, resolve, reject);</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">                            reject(error)</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;)</span><br><span class="line">                &#125;)</span><br><span class="line">                <span class="keyword">this</span>.onRejectedCallbacks.push(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">                    <span class="comment">//todo</span></span><br><span class="line">                    setTimeout( <span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            <span class="keyword">let</span> x = onRejected(<span class="keyword">this</span>.reason);</span><br><span class="line">                            <span class="comment">//reject(x);</span></span><br><span class="line">                            resolvePromise(promise2, x, resolve, reject);</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">                            reject(error)</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;)</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="keyword">return</span> promise2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">module</span>.exports = <span class="built_in">Promise</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="built_in">Promise</span>  = <span class="built_in">require</span>(<span class="string">'./promise'</span>);</span><br><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        resolve(<span class="string">'hello'</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">let</span> promise2 = p.then(<span class="function"><span class="params">data</span>=&gt;</span>&#123;  <span class="comment">/*************************这里解析上面promise.js line43*/</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>( <span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            resolve(<span class="string">"word"</span>)</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br><span class="line">promise2.then(<span class="function"><span class="params">data</span>=&gt;</span>&#123;  <span class="comment">/*****************************这里解析上面promise.js line43*/</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"成功："</span>,data)</span><br><span class="line">&#125;,err=&gt;&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'err:'</span>, err);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 这里的line8-12就是上面的x，x的值来决定promise2是成功还是失败，所以都要传过去，然后再让promise2走resolve还是reject</span></span><br></pre></td></tr></table></figure>

<p>【8】<br>现在来处理resolvePromise函数</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1.promise.js</span></span><br><span class="line"><span class="keyword">const</span> <span class="built_in">Promise</span>  = <span class="built_in">require</span>(<span class="string">'./promise'</span>);</span><br><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        resolve(<span class="string">'hello'</span>);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">let</span> promise2 = p.then(<span class="function"><span class="params">data</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> promise2;</span><br><span class="line">&#125;)</span><br><span class="line">promise2.then(<span class="function"><span class="params">data</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"成功："</span>,data)</span><br><span class="line">&#125;,err=&gt;&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'err:'</span>, err);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// promise.js</span></span><br><span class="line"><span class="keyword">const</span> resolvePromise = <span class="function">(<span class="params">promise2, x, resolve, reject</span>) =&gt;</span> &#123; <span class="comment">// promise的处理函数</span></span><br><span class="line">    <span class="comment">//resolve(x)</span></span><br><span class="line">    <span class="comment">// 处理x类型 来决定是调用resolve 还是reject</span></span><br><span class="line">    <span class="comment">// 1.promise.js当我们处理的line5 then里面的promise有可能是原生的或者别人写的，所以必须要写的严谨  promises/A+ 2.3下面的内容可以看看 写的很详细</span></span><br><span class="line">    <span class="comment">// 状况1: 2.3.1 If promise and x refer to the same object, reject promise with a TypeError as the reason.  这里的promise就是promise2 如 1.promise.js line5的then要等line6执行结束之后再执行下面的, let promise2，return promise2 意思是自己等自己 这样肯定是不行的 </span></span><br><span class="line">    <span class="comment">// 执行： ① 将1.promise.js line2注释 用原生的Promise  打印  err: TypeError: Chaining cycle detected for promise #&lt;Promise&gt; （死循环了） ② 现在用我们自己的Promsie，所以当前line8做了判断</span></span><br><span class="line">    <span class="keyword">if</span>(promise2 === x)&#123; <span class="comment">//自己等待自己</span></span><br><span class="line">        <span class="keyword">return</span> reject(<span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">`Chaining cycle detected for promise #&lt;Promise&gt;`</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>【9】</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/***************针对 promise.js line 12  2.3.3.2 取then的过程中抛出异常 */</span></span><br><span class="line"><span class="comment">// 1.promise.js</span></span><br><span class="line"><span class="keyword">const</span> <span class="built_in">Promise</span>  = <span class="built_in">require</span>(<span class="string">'./promise'</span>);</span><br><span class="line"><span class="keyword">let</span> obj = &#123;&#125;;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(obj, <span class="string">"then"</span>, &#123;</span><br><span class="line">    <span class="keyword">get</span>()&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"失败"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    resolve(<span class="string">'hello'</span>);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">let</span> promise2 = p.then(<span class="function"><span class="params">data</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> obj; <span class="comment">// 这里会抛出异常</span></span><br><span class="line">&#125;)</span><br><span class="line">promise2.then(<span class="function"><span class="params">data</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"成功："</span>,data)</span><br><span class="line">&#125;,err=&gt;&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'err:'</span>, err);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// promise.js</span></span><br><span class="line"><span class="keyword">const</span> resolvePromise = <span class="function">(<span class="params">promise2, x, resolve, reject</span>) =&gt;</span> &#123; </span><br><span class="line">    <span class="comment">// 处理x类型 来决定是调用resolve 还是reject</span></span><br><span class="line">    <span class="keyword">if</span>(promise2 === x)&#123; <span class="comment">//自己等待自己</span></span><br><span class="line">        <span class="keyword">return</span> reject(<span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">`Chaining cycle detected for promise #&lt;Promise&gt;`</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="keyword">if</span>( (<span class="keyword">typeof</span> x === <span class="string">'object'</span> &amp;&amp; x !== <span class="literal">null</span>) || (<span class="keyword">typeof</span> x === <span class="string">'function'</span>))&#123;</span><br><span class="line">        <span class="comment">// 这里可能是promise  判断是不是promise 有没有then方法   这里直接看 2.3.3 Otherwise, if x is an object or function （promise a+   2.3.3下面的内容包括2.3.2的）</span></span><br><span class="line">        <span class="comment">//let then = x.then; // 2.3.3.1   看看有没有then方法</span></span><br><span class="line">        <span class="comment">// 2.3.3.2 取then的过程中抛出异常</span></span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="keyword">let</span> then = x.then;</span><br><span class="line">            <span class="comment">// 2.3.3.3 If then is a function, call it with x as this, first argument resolvePromise, and second argument resolvePromise, where</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">typeof</span> then === <span class="string">'function'</span>)&#123;  <span class="comment">// 这一步判断是否有then方法</span></span><br><span class="line">                <span class="comment">// 我现在我们可以认为是promise了</span></span><br><span class="line">                <span class="comment">//x.then(()=&gt;&#123;&#125;,()=&gt;&#123;&#125;);</span></span><br><span class="line">                then.call(x, y=&gt;&#123; <span class="comment">// 如果是promise 就采用promise的结果</span></span><br><span class="line">                    resolve(y)</span><br><span class="line">                &#125;, r=&gt;&#123;</span><br><span class="line">                    reject(r);</span><br><span class="line">                &#125;)</span><br><span class="line">                <span class="comment">// 当前 line17 和 line18-22功能上是一样的，为什么用下面的，因为有可能line17 x.then会报错，而line13这里let 的then已经做过判断了不会报错，所以then.call(x)这样写</span></span><br><span class="line">            &#125;<span class="keyword">else</span>&#123; <span class="comment">// 2.3.3.4 If then is not a function, fulfill promise with x</span></span><br><span class="line">                resolve(x); <span class="comment">// 常量直接抛出去    可在1.promise.js line14 用 return [1,2,3]  打印试试</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span>(e)&#123;</span><br><span class="line">            reject(e); <span class="comment">// 取then抛出异常</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;<span class="keyword">else</span>&#123; <span class="comment">// 2.3.4 If x is not an object or function, fulfill promise with x.   (promise a+)</span></span><br><span class="line">        resolve(x);  <span class="comment">// 这里可以在 3.promise.js  line 14 传个普通值测试</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>小结： 判断是否为promise</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>、<span class="keyword">if</span>( (<span class="keyword">typeof</span> x === <span class="string">'object'</span> &amp;&amp; x !== <span class="literal">null</span>) || (<span class="keyword">typeof</span> x === <span class="string">'function'</span>))</span><br><span class="line"><span class="number">2</span>、<span class="keyword">let</span> then = x.then;	<span class="keyword">if</span>(<span class="keyword">typeof</span> then === <span class="string">'function'</span>)</span><br><span class="line"><span class="comment">// 是否是对象、或者函数 并且有then方法</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 也可以</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">smellLikeAPromise</span>(<span class="params">promise</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (promise <span class="keyword">instanceof</span> <span class="built_in">Promise</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">typeof</span> promise === <span class="string">'object'</span> &amp;&amp; promise.then === <span class="string">'function'</span> &amp;&amp; promise.catch === <span class="string">'function'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>小知识点： then.call(x) 指 让then的this指向x 等价于 x.then</p>
<hr>
<p>【10】</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1.promise.js</span></span><br><span class="line"><span class="keyword">const</span> <span class="built_in">Promise</span>  = <span class="built_in">require</span>(<span class="string">'./promise'</span>);</span><br><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    resolve(<span class="string">'hello'</span>);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">let</span> promise2 = p.then(<span class="function"><span class="params">data</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>( <span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">            resolve(<span class="keyword">new</span> <span class="built_in">Promise</span>( <span class="function">(<span class="params">resolve, reject</span>)=&gt;</span>&#123;</span><br><span class="line">                setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">                    resolve(<span class="string">"hello"</span>)</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;))</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br><span class="line">promise2.then(<span class="function"><span class="params">data</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"成功："</span>,data)</span><br><span class="line">&#125;,err=&gt;&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'err:'</span>, err);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>当如<code>1.promise.js</code> line 6-16之间嵌套了多个promise 我们希望的是能够执行到最里面的resolve或者reject结束之后再执行下一个then方法，即有可能上面<code>resolvePromise</code>函数里line18的y是个promise ，所以下面需要对y的类型做判断</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// promise.js</span></span><br><span class="line"><span class="keyword">const</span> resolvePromise = <span class="function">(<span class="params">promise2, x, resolve, reject</span>) =&gt;</span> &#123; </span><br><span class="line">    <span class="keyword">if</span>(promise2 === x)&#123; <span class="comment">//自己等待自己</span></span><br><span class="line">        <span class="keyword">return</span> reject(<span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">`Chaining cycle detected for promise #&lt;Promise&gt;`</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> called; <span class="comment">// 默认没有调用成功和失败</span></span><br><span class="line">    <span class="keyword">if</span>( (<span class="keyword">typeof</span> x === <span class="string">'object'</span> &amp;&amp; x !== <span class="literal">null</span>) || (<span class="keyword">typeof</span> x === <span class="string">'function'</span>))&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="keyword">let</span> then = x.then</span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">typeof</span> then === <span class="string">'function'</span>)&#123;</span><br><span class="line">                then.call(x, y=&gt;&#123; </span><br><span class="line">                    <span class="comment">//resolve(y);</span></span><br><span class="line">                    <span class="keyword">if</span>(called) <span class="keyword">return</span>;<span class="comment">// 防止多次调用</span></span><br><span class="line">                    called = <span class="literal">true</span>;</span><br><span class="line">                    resolvePromise(promise2, y, resolve, reject); <span class="comment">// 这里实现递归解析</span></span><br><span class="line">                &#125;, r=&gt;&#123;</span><br><span class="line">                    <span class="keyword">if</span>(called) <span class="keyword">return</span>;<span class="comment">// 防止多次调用</span></span><br><span class="line">                    called = <span class="literal">true</span>;</span><br><span class="line">                    reject(r);</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123; </span><br><span class="line">                resolve(x); </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span>(e)&#123;</span><br><span class="line">            <span class="keyword">if</span>(called) <span class="keyword">return</span>;<span class="comment">// 防止多次调用</span></span><br><span class="line">            called = <span class="literal">true</span>; </span><br><span class="line">            reject(e); </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123; </span><br><span class="line">        resolve(x); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>参考promsies/A+ 2.3.3.3 If both resolvePromise and rejectPromise are called, or multiple calls to the same argument are made, the first call takes precedence, and any further calls are ignored.<br>如果<code>1.promise.js</code> line7-15返回的是别人封装的Promise，假设它里面并没有做调取成功了之后不能再掉失败，调取了失败之后不能再调成功的判断，所以上面新增了一个 called 用来防止多次调用。</p>
<hr>
<p>【11】<br>这里对应promises/A+ 2.2.1里面的几点</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1.promise.js</span></span><br><span class="line"><span class="keyword">const</span> <span class="built_in">Promise</span>  = <span class="built_in">require</span>(<span class="string">'./promise'</span>);</span><br><span class="line"><span class="comment">/***********情况1********************************/</span></span><br><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    resolve(<span class="string">'hello'</span>);</span><br><span class="line">&#125;)</span><br><span class="line">.then()</span><br><span class="line">.then(<span class="function"><span class="params">data</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"成功line9："</span>,data)</span><br><span class="line">&#125;,err=&gt;&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'errline11:'</span>, err);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 调用原生Promise的结果: 成功line9： hello</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/***********情况2*******************************/</span></span><br><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    reject(<span class="string">'hello'</span>);</span><br><span class="line">&#125;)</span><br><span class="line">.then()</span><br><span class="line">.then(<span class="function"><span class="params">data</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"成功line21："</span>,data)</span><br><span class="line">&#125;,err=&gt;&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'errline23:'</span>, err);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 调用原生Promise的结果: errline23： hello</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/***********情况3********************************/</span></span><br><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    reject(<span class="string">'hello'</span>);</span><br><span class="line">&#125;)</span><br><span class="line">.then(<span class="literal">null</span>, err=&gt;&#123;</span><br><span class="line">    <span class="comment">//return err; // 如果这里这样写，下一个then会从成功传出来line36 打印结果：成功line36：hello</span></span><br><span class="line">    <span class="keyword">throw</span> err;  <span class="comment">// 把错误抛出 这样 下一个then才会继续走error 打印结果： errline38: hello</span></span><br><span class="line">&#125;)</span><br><span class="line">.then(<span class="function"><span class="params">data</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"成功line36："</span>,data)</span><br><span class="line">&#125;,err=&gt;&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'errline38:'</span>, err);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>有一种穿透的感觉 这个then里没有写，就到下一个then,代码如下line34-35直接把值往下传</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// promise.js</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Promise</span></span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(executor)&#123;</span><br><span class="line">        <span class="keyword">this</span>.value = <span class="literal">undefined</span>;</span><br><span class="line">        <span class="keyword">this</span>.reason = <span class="literal">undefined</span>;</span><br><span class="line">        <span class="keyword">this</span>.status = PENDING;</span><br><span class="line">        <span class="comment">// 2个数组存储</span></span><br><span class="line">        <span class="keyword">this</span>.onResolvedCallbacks = [];</span><br><span class="line">        <span class="keyword">this</span>.onRejectedCallbacks = [];</span><br><span class="line">        <span class="keyword">let</span> resolve = <span class="function">(<span class="params">value</span>) =&gt;</span> &#123; </span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">this</span>.status === PENDING)&#123; </span><br><span class="line">                <span class="keyword">this</span>.value = value;</span><br><span class="line">                <span class="keyword">this</span>.status = FULFILLED;</span><br><span class="line">                <span class="comment">// 发布</span></span><br><span class="line">                <span class="keyword">this</span>.onResolvedCallbacks.forEach(<span class="function"><span class="params">fn</span> =&gt;</span> fn());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">let</span> reject = <span class="function">(<span class="params">reason</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">this</span>.status === PENDING)&#123;</span><br><span class="line">                <span class="keyword">this</span>.reason = reason;</span><br><span class="line">                <span class="keyword">this</span>.status = REJECTED;</span><br><span class="line">                <span class="comment">// 发布</span></span><br><span class="line">                <span class="keyword">this</span>.onRejectedCallbacks.forEach(<span class="function"><span class="params">fn</span> =&gt;</span> fn());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            executor(resolve, reject);</span><br><span class="line">        &#125;<span class="keyword">catch</span>(e)&#123;</span><br><span class="line">            reject(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    then(onFulfilled, onRejected)&#123;</span><br><span class="line">        <span class="comment">//可选参数 没传就给一个默认参数即可</span></span><br><span class="line">        onFulfilled = <span class="keyword">typeof</span> onFulfilled === <span class="string">'function'</span> ? onFulfilled : <span class="function"><span class="params">val</span>=&gt;</span>val;</span><br><span class="line">        onRejected = <span class="keyword">typeof</span> onRejected === <span class="string">'function'</span> ? onRejected : <span class="function"><span class="params">err</span>=&gt;</span>&#123;<span class="keyword">throw</span> err&#125;;</span><br><span class="line">        <span class="keyword">let</span> promise2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">this</span>.status === FULFILLED)&#123;</span><br><span class="line">                setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123; </span><br><span class="line">                        <span class="keyword">let</span> x = onFulfilled(<span class="keyword">this</span>.value);</span><br><span class="line">                        <span class="comment">//resolve(x);</span></span><br><span class="line">                        resolvePromise(promise2, x, resolve, reject);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">                        reject(error)</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">this</span>.status === REJECTED)&#123;</span><br><span class="line">                setTimeout( <span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;   </span><br><span class="line">                        <span class="keyword">let</span> x = onRejected(<span class="keyword">this</span>.reason);</span><br><span class="line">                        <span class="comment">//reject(x);</span></span><br><span class="line">                        resolvePromise(promise2, x, resolve, reject);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">                        reject(error)</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">this</span>.status === PENDING)&#123;</span><br><span class="line">                <span class="keyword">this</span>.onResolvedCallbacks.push(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">                    <span class="comment">//todo</span></span><br><span class="line">                    setTimeout( <span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            <span class="keyword">let</span> x = onFulfilled(<span class="keyword">this</span>.value);</span><br><span class="line">                            <span class="comment">//resolve(x);</span></span><br><span class="line">                            resolvePromise(promise2, x, resolve, reject);</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">                            reject(error)</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;)</span><br><span class="line">                &#125;)</span><br><span class="line">                <span class="keyword">this</span>.onRejectedCallbacks.push(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">                    <span class="comment">//todo</span></span><br><span class="line">                    setTimeout( <span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            <span class="keyword">let</span> x = onRejected(<span class="keyword">this</span>.reason);</span><br><span class="line">                            <span class="comment">//reject(x);</span></span><br><span class="line">                            resolvePromise(promise2, x, resolve, reject);</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">                            reject(error)</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;)</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="keyword">return</span> promise2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>情况4：resolve里面返回了一个promise 可以分别用原生的和自己写的做对比</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1.promise.js</span></span><br><span class="line"><span class="comment">/***********情况4********************************/</span></span><br><span class="line"><span class="keyword">const</span> <span class="built_in">Promise</span>  = <span class="built_in">require</span>(<span class="string">'./promise'</span>);</span><br><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>) =&gt;</span> &#123;</span><br><span class="line">    resolve(<span class="keyword">new</span> <span class="built_in">Promise</span>( <span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        setTimeout( <span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">            resolve(<span class="string">"hello"</span>);</span><br><span class="line">        &#125;,<span class="number">1000</span>);</span><br><span class="line">    &#125;))</span><br><span class="line">&#125;).then(<span class="function"><span class="params">data</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(data);</span><br><span class="line">&#125;,err=&gt;&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// promise.js</span></span><br><span class="line"><span class="keyword">let</span> resolve = <span class="function">(<span class="params">value</span>) =&gt;</span> &#123; </span><br><span class="line">	<span class="comment">// 这里的value 就是 1.promise.js line5 resolve里面返回的promise 所以这里也要对value的值做解析</span></span><br><span class="line">	<span class="keyword">if</span>(value <span class="keyword">instanceof</span> <span class="built_in">Promise</span>)&#123;</span><br><span class="line">	<span class="comment">// 如果一个promise resolve了一个新的promise 会等到这个内部的promise执行完成</span></span><br><span class="line">		<span class="keyword">return</span> value.then(resolve, reject );   <span class="comment">// 和resolvePromise的功能一样</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(<span class="keyword">this</span>.status === PENDING)&#123; </span><br><span class="line">	<span class="keyword">this</span>.value = value;</span><br><span class="line">	<span class="keyword">this</span>.status = FULFILLED;</span><br><span class="line">	<span class="comment">// 发布</span></span><br><span class="line">	<span class="keyword">this</span>.onResolvedCallbacks.forEach(<span class="function"><span class="params">fn</span> =&gt;</span> fn());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>情况5：<br>如下情况 catch line10-12 和 line13-15（这2种情况）可用原生方法试一下 效果是一样的<br>还可以在line12之间用.then() 空的then方法</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1.promise.js</span></span><br><span class="line"><span class="comment">/***********情况5********************************/</span></span><br><span class="line"><span class="keyword">const</span> <span class="built_in">Promise</span>  = <span class="built_in">require</span>(<span class="string">'./promise'</span>);</span><br><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>) =&gt;</span> &#123;</span><br><span class="line">    resolve(<span class="string">'hello'</span>);</span><br><span class="line">&#125;).then(<span class="function"><span class="params">data</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'抛出一个错误'</span>); <span class="comment">// 不会走自己家的错误 </span></span><br><span class="line">&#125;,err=&gt;&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// .catch(err=&gt;&#123;</span></span><br><span class="line"><span class="comment">//     console.log('err line10:' ,err);</span></span><br><span class="line"><span class="comment">// &#125;)</span></span><br><span class="line">.then(<span class="literal">null</span>,err=&gt;&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'err line15:'</span>, err);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>当cathch后面跟了一个then 还是会走then里面的成功方法</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1.promise.js</span></span><br><span class="line"><span class="keyword">const</span> <span class="built_in">Promise</span>  = <span class="built_in">require</span>(<span class="string">'./promise'</span>);</span><br><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>) =&gt;</span> &#123;</span><br><span class="line">    resolve(<span class="string">'hello'</span>);</span><br><span class="line">&#125;).then(<span class="function"><span class="params">data</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'抛出一个错误'</span>); <span class="comment">// 不会走自己家的错误 </span></span><br><span class="line">&#125;,err=&gt;&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err)</span><br><span class="line">&#125;)</span><br><span class="line">.catch(<span class="function"><span class="params">err</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'err line10:'</span> ,err);</span><br><span class="line">&#125;)</span><br><span class="line">.then()</span><br><span class="line">.then(<span class="function"><span class="params">data</span>=&gt;</span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">"line14---"</span>,data);</span><br><span class="line">&#125;,err=&gt;&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'err line16:'</span>, err);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 执行结果： </span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">err line10: 抛出一个错误</span></span><br><span class="line"><span class="comment">	at Promise.then.data (e:\.......js:4:11)</span></span><br><span class="line"><span class="comment">    at process._tickCallback (internal/process/next_tick.js:68:7)</span></span><br><span class="line"><span class="comment">    at Function.Module.runMain (internal/modules/cjs/loader.js:757:11)</span></span><br><span class="line"><span class="comment">    at startup (internal/bootstrap/node.js:283:19)</span></span><br><span class="line"><span class="comment">    at bootstrapNodeJSCore (internal/bootstrap/node.js:622:3)</span></span><br><span class="line"><span class="comment">line14--- undefined</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>小结：line11-13和line14-16是一样的，相当于catch就是then里面少写了一个成功的方法 是then的语法糖 对应的<code>promise.js</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// promsie.js</span></span><br><span class="line"><span class="keyword">catch</span>(errCallback)&#123; <span class="comment">// 加了一个catch方法</span></span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">this</span>.then(<span class="literal">null</span>, errCallback); <span class="comment">// 没有成功的then</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>【12】</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>( <span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    resolve(<span class="number">123</span>);</span><br><span class="line">&#125;).then(<span class="function"><span class="params">data</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(data);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">Promise</span>.resolve(<span class="number">123</span>).then(<span class="function"><span class="params">data</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(data);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>上面 line1-5 和 line6-8是一样的  resolve是当前类上的静态方法  说白了也是一个语法糖</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// promise.js</span></span><br><span class="line"><span class="keyword">static</span> resolve(value)&#123; <span class="comment">// 创建了一个成功的promise</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>)=&gt;</span>&#123;</span><br><span class="line">        resolve(value);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> reject(reason)&#123; <span class="comment">// 创建了一个失败的promise</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>)=&gt;</span>&#123;</span><br><span class="line">        reject(reason);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="完整版Promise-js"><a href="#完整版Promise-js" class="headerlink" title="完整版Promise.js"></a>完整版Promise.js</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> resolvePromise = <span class="function">(<span class="params">promise2, x, resolve, reject</span>) =&gt;</span> &#123; </span><br><span class="line">    <span class="keyword">if</span>(promise2 === x)&#123;</span><br><span class="line">        <span class="keyword">return</span> reject(<span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">`Chaining cycle detected for promise #&lt;Promise&gt;`</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> called;</span><br><span class="line">    <span class="keyword">if</span>( (<span class="keyword">typeof</span> x === <span class="string">'object'</span> &amp;&amp; x !== <span class="literal">null</span>) || (<span class="keyword">typeof</span> x === <span class="string">'function'</span>))&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="keyword">let</span> then = x.then;</span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">typeof</span> then === <span class="string">'function'</span>)&#123;</span><br><span class="line">                </span><br><span class="line">                then.call(x, y=&gt;&#123; </span><br><span class="line">                    <span class="comment">//resolve(y);</span></span><br><span class="line">                    <span class="keyword">if</span>(called) <span class="keyword">return</span>;</span><br><span class="line">                    called = <span class="literal">true</span>;</span><br><span class="line">                    resolvePromise(promise2, y, resolve, reject);</span><br><span class="line">                &#125;, r=&gt;&#123;</span><br><span class="line">                    <span class="keyword">if</span>(called) <span class="keyword">return</span>;</span><br><span class="line">                    called = <span class="literal">true</span>;</span><br><span class="line">                    reject(r);</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123; </span><br><span class="line">                resolve(x); </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span>(e)&#123;</span><br><span class="line">            <span class="keyword">if</span>(called) <span class="keyword">return</span>;</span><br><span class="line">            called = <span class="literal">true</span>; </span><br><span class="line">            reject(e); </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123; </span><br><span class="line">        resolve(x);  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Promise</span></span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(executor)&#123;</span><br><span class="line">        <span class="keyword">this</span>.value = <span class="literal">undefined</span>;</span><br><span class="line">        <span class="keyword">this</span>.reason = <span class="literal">undefined</span>;</span><br><span class="line">        <span class="keyword">this</span>.status = PENDING;</span><br><span class="line">        <span class="comment">// 2个数组存储</span></span><br><span class="line">        <span class="keyword">this</span>.onResolvedCallbacks = [];</span><br><span class="line">        <span class="keyword">this</span>.onRejectedCallbacks = [];</span><br><span class="line">        <span class="keyword">let</span> resolve = <span class="function">(<span class="params">value</span>) =&gt;</span> &#123; </span><br><span class="line">            <span class="comment">// 对value的值做解析</span></span><br><span class="line">            <span class="keyword">if</span>(value <span class="keyword">instanceof</span> <span class="built_in">Promise</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> value.then(resolve, reject );   <span class="comment">// 和resolvePromise的功能一样</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">this</span>.status === PENDING)&#123; </span><br><span class="line">                <span class="keyword">this</span>.value = value;</span><br><span class="line">                <span class="keyword">this</span>.status = FULFILLED;</span><br><span class="line">                <span class="comment">// 发布</span></span><br><span class="line">                <span class="keyword">this</span>.onResolvedCallbacks.forEach(<span class="function"><span class="params">fn</span> =&gt;</span> fn());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">let</span> reject = <span class="function">(<span class="params">reason</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">this</span>.status === PENDING)&#123;</span><br><span class="line">                <span class="keyword">this</span>.reason = reason;</span><br><span class="line">                <span class="keyword">this</span>.status = REJECTED;</span><br><span class="line">                <span class="comment">// 发布</span></span><br><span class="line">                <span class="keyword">this</span>.onRejectedCallbacks.forEach(<span class="function"><span class="params">fn</span> =&gt;</span> fn());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            executor(resolve, reject);</span><br><span class="line">        &#125;<span class="keyword">catch</span>(e)&#123;</span><br><span class="line">            reject(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    then(onFulfilled, onRejected)&#123;</span><br><span class="line">        <span class="comment">//可选参数 没传就给一个默认参数即可</span></span><br><span class="line">        onFulfilled = <span class="keyword">typeof</span> onFulfilled === <span class="string">'function'</span> ? onFulfilled : <span class="function"><span class="params">val</span>=&gt;</span>val;</span><br><span class="line">        onRejected = <span class="keyword">typeof</span> onRejected === <span class="string">'function'</span> ? onRejected : <span class="function"><span class="params">err</span>=&gt;</span>&#123;<span class="keyword">throw</span> err&#125;;</span><br><span class="line">        <span class="keyword">let</span> promise2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">this</span>.status === FULFILLED)&#123;</span><br><span class="line">                setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123; </span><br><span class="line">                        <span class="keyword">let</span> x = onFulfilled(<span class="keyword">this</span>.value);</span><br><span class="line">                        <span class="comment">//resolve(x);</span></span><br><span class="line">                        resolvePromise(promise2, x, resolve, reject);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">                        reject(error)</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;)</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">this</span>.status === REJECTED)&#123;</span><br><span class="line">                setTimeout( <span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;   </span><br><span class="line">                        <span class="keyword">let</span> x = onRejected(<span class="keyword">this</span>.reason);</span><br><span class="line">                        <span class="comment">//reject(x);</span></span><br><span class="line">                        resolvePromise(promise2, x, resolve, reject);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">                        reject(error)</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;)</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">this</span>.status === PENDING)&#123;</span><br><span class="line">                <span class="keyword">this</span>.onResolvedCallbacks.push(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">                    <span class="comment">//todo</span></span><br><span class="line">                    setTimeout( <span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            <span class="keyword">let</span> x = onFulfilled(<span class="keyword">this</span>.value);</span><br><span class="line">                            <span class="comment">//resolve(x);</span></span><br><span class="line">                            resolvePromise(promise2, x, resolve, reject);</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">                            reject(error)</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;)</span><br><span class="line">                    </span><br><span class="line">                &#125;)</span><br><span class="line">                <span class="keyword">this</span>.onRejectedCallbacks.push(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">                    <span class="comment">//todo</span></span><br><span class="line">                    setTimeout( <span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            <span class="keyword">let</span> x = onRejected(<span class="keyword">this</span>.reason);</span><br><span class="line">                            <span class="comment">//reject(x);</span></span><br><span class="line">                            resolvePromise(promise2, x, resolve, reject);</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">                            reject(error)</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;)</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="keyword">return</span> promise2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span>(errCallback)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.then(<span class="literal">null</span>, errCallback); <span class="comment">// 没有成功的then</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> resolve(value)&#123; <span class="comment">// 创建了一个成功的promise</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>)=&gt;</span>&#123;</span><br><span class="line">            resolve(value);</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> reject(reason)&#123; <span class="comment">// 创建了一个失败的promise</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>)=&gt;</span>&#123;</span><br><span class="line">            reject(reason);</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h4><h5 id="1）"><a href="#1）" class="headerlink" title="1）"></a>1）</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    resolve();</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">let</span> p1 = p.then(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">&#125;).then(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p11 = p.then(<span class="function"><span class="params">()</span>=&gt;</span>&#123; </span><br><span class="line">&#125;)</span><br><span class="line">p11.then(<span class="function"><span class="params">()</span>=&gt;</span>&#123;  </span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(p1, p11, p1 === p11);</span><br><span class="line"><span class="comment">// Promise &#123; &lt;pending&gt; &#125; Promise &#123; &lt;pending&gt; &#125; false</span></span><br><span class="line"><span class="comment">// 上面p1和p11不一样</span></span><br><span class="line"><span class="comment">// p1是line4-8这2个then之后的返回结果</span></span><br><span class="line"><span class="comment">// p11是line8-9这个then的返回结果</span></span><br></pre></td></tr></table></figure>

<h5 id="2-promise-中的链式调用如何中断"><a href="#2-promise-中的链式调用如何中断" class="headerlink" title="2) promise 中的链式调用如何中断 ?"></a>2) promise 中的链式调用如何中断 ?</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    resolve();</span><br><span class="line">&#125;)</span><br><span class="line">p.then(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'ok'</span>);</span><br><span class="line">&#125;).then(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'1'</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// ok  1</span></span><br></pre></td></tr></table></figure>

<p>现在希望在line5这个then就停止 如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    resolve();</span><br><span class="line">&#125;)</span><br><span class="line">p.then(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'ok'</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">()</span>=&gt;</span>&#123;&#125;) <span class="comment">// 这样就终止了</span></span><br><span class="line">&#125;).then(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'1'</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// ok</span></span><br></pre></td></tr></table></figure>

<p>总结： 中断promise链 就是返回一个等待的promise</p>
<h5 id="3）finally实现原理"><a href="#3）finally实现原理" class="headerlink" title="3）finally实现原理"></a>3）finally实现原理</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.resolve().finally(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="built_in">Promise</span>.reject().finally(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 1 报错：UnhandledPromiseRejectionWarning: undefined</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*************************分割线*******************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.reject().finally(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">&#125;).catch(<span class="function"><span class="params">err</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err);</span><br><span class="line">&#125;)<span class="comment">// 1   undefined</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*************************分割线*******************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.reject().finally(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>)=&gt;</span>&#123;</span><br><span class="line">        setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            resolve();</span><br><span class="line">        &#125;,<span class="number">1000</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;).catch(<span class="function"><span class="params">err</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err);</span><br><span class="line">&#125;)<span class="comment">// 1   过了1秒打印 undefined</span></span><br></pre></td></tr></table></figure>

<p> Promise.reject().finally 因为是这样调用的finally  所以这个finally是实例上的方法不是类上的方法 类上的方法直接Promise.调用</p>
<p>下面自己手下写finally</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.prototype.finally = <span class="function"><span class="keyword">function</span>(<span class="params">callback</span>)</span>&#123; <span class="comment">// 疑问 为什么实例是Promise.prototype</span></span><br><span class="line">    <span class="comment">// 因为finally·后面直接跟着.catch 之前有讲过.catch就是.then没有调成功方法.then(null,()=&gt;),</span></span><br><span class="line">    <span class="comment">// 所以可以看出finally相当于是一个then方法 不管成功失败都执行</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.then( <span class="function"><span class="params">val</span>=&gt;</span>&#123; <span class="comment">// 这个this就是实例 </span></span><br><span class="line">        callback();</span><br><span class="line">        <span class="keyword">return</span> val; <span class="comment">// 如果上一个是成功 就将成功往下传递</span></span><br><span class="line">    &#125;, err=&gt;&#123;</span><br><span class="line">        callback();</span><br><span class="line">        <span class="keyword">throw</span> err; <span class="comment">// 如果上一个是失败 就将失败往下抛</span></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.reject().finally(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>)=&gt;</span>&#123;</span><br><span class="line">        setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            resolve();</span><br><span class="line">        &#125;,<span class="number">1000</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;).catch(<span class="function"><span class="params">err</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 但是 如上line15-19这个callback返回的是一个promise</span></span><br><span class="line"><span class="comment">// 1 undefined 结果这个undefined 并没有等待1秒再打印</span></span><br></pre></td></tr></table></figure>

<p>改进：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.prototype.finally = <span class="function"><span class="keyword">function</span>(<span class="params">callback</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.then( <span class="function"><span class="params">val</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="comment">// 等待finall中的函数执行完毕 再继续执行 </span></span><br><span class="line">		<span class="comment">// finally函数可能返回一个promise 用Promise.resolve等待返回的promise执行完</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve(callback()).then(<span class="function"><span class="params">()</span>=&gt;</span>val);</span><br><span class="line">        <span class="comment">//return val;</span></span><br><span class="line">    &#125;, err=&gt;&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve(callback()).then(<span class="function"><span class="params">()</span>=&gt;</span>&#123;<span class="keyword">throw</span> err&#125;);</span><br><span class="line">        <span class="comment">//throw err;</span></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Promise</span>.reject().finally(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>)=&gt;</span>&#123;</span><br><span class="line">        setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            resolve();</span><br><span class="line">        &#125;,<span class="number">1000</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;).catch(<span class="function"><span class="params">err</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err);</span><br><span class="line">&#125;)<span class="comment">// 1   过了1秒打印 undefined</span></span><br></pre></td></tr></table></figure>

<p>测试</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 4个小示例</span></span><br><span class="line"><span class="comment">// 1）</span></span><br><span class="line"><span class="built_in">Promise</span>.resolve(<span class="number">123</span>).finally(<span class="function"><span class="params">()</span>=&gt;</span>&#123; <span class="comment">// #1</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'finally'</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>( <span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        setTimeout( <span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">            resolve(<span class="string">'456'</span>);<span class="comment">// #2</span></span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;).then(<span class="function"><span class="params">data</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'success:'</span>,data);</span><br><span class="line">&#125;,err=&gt;&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'err::'</span>,err)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 替换     #1                #2</span></span><br><span class="line"><span class="comment">// Promise.resolve(123)    这是定时器里的: resolve('456');   结果：success: 123</span></span><br><span class="line"><span class="comment">// Promise.resolve(123)    这是定时器里的: reject('rej');    结果：err:: rej</span></span><br><span class="line"><span class="comment">// Promise.reject(123)    这是定时器里的: reject('rej');   结果：err:: rej</span></span><br><span class="line"><span class="comment">// Promise.reject(123)    这是定时器里的: resolve('456');   结果：err:: 123</span></span><br></pre></td></tr></table></figure>

<p>用自己写的finally试验</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.prototype.finally = <span class="function"><span class="keyword">function</span>(<span class="params">callback</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.then( <span class="function"><span class="params">val</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'resolve~~'</span>, val);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve(callback()).then(<span class="function"><span class="params">()</span>=&gt;</span>val);  <span class="comment">// ***核心</span></span><br><span class="line">    &#125;, err=&gt;&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'reject~~'</span>, err)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve(callback()).then(<span class="function"><span class="params">()</span>=&gt;</span>&#123;<span class="keyword">throw</span> err&#125;); <span class="comment">// ***核心</span></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Promise</span>.resolve(<span class="number">123</span>).finally(<span class="function"><span class="params">()</span>=&gt;</span>&#123; <span class="comment">// #1</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>)=&gt;</span>&#123;</span><br><span class="line">        setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123; <span class="comment">// #2</span></span><br><span class="line">            <span class="comment">//resolve(456);</span></span><br><span class="line">            reject(<span class="string">'rej'</span>);</span><br><span class="line">        &#125;,<span class="number">1000</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;).then(<span class="function"><span class="params">data</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'success:'</span>,data);</span><br><span class="line">&#125;, err=&gt;&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'err:'</span>, err);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 替换     #1                #2</span></span><br><span class="line"><span class="comment">// Promise.resolve(123)    这是定时器里的: resolve('456');   结果：resolve~~ 123   1   success: 123</span></span><br><span class="line"><span class="comment">// Promise.resolve(123)    这是定时器里的: reject('rej');    结果：resolve~~ 123   1   err: rej</span></span><br><span class="line"><span class="comment">// Promise.reject(123)    这是定时器里的: reject('rej');   结果：reject~~ 123      1   err: rej</span></span><br><span class="line"><span class="comment">// Promise.reject(123)    这是定时器里的: resolve('456');   结果：reject~~ 123     1   err: 123</span></span><br></pre></td></tr></table></figure>

<h5 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h5><p>finall里面成功就不管 按照上一个then直接的结果返回 如果是失败则走这个失败</p>
<h5 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h5><p>① <code>Promise.resolve()</code> 时(成功)，如果这里line4 <code>resolve(callback())</code> 成功， 就直接走后面接的 <code>.then(()=&gt;val);</code> 这里的val是上一个then传过来的值，所以成功时候不改变最终结果 ；如果line4 <code>resolve(callback())</code> 失败，就走 <code>.then(()=&gt;val)</code> 的失败，因为这里的.then里面没有失败的回调，所以会接着找下面的回调 即line18-22也就是之前的 <code>.catch</code> ，会把 <code>resolve(callback())</code> 的失败结果输出， 可以在line4 <code>.then(()=&gt;val, (err)=&gt;{console.log(err)})</code> 打印 <code>resolve(callback())</code> 失败的结果，那么line18-22,就会走line19 打印 success: undefined 。</p>
<p>② <code>Promise.reject()</code> 时(失败)，如果这里line7 <code>resolve(callback())</code> 成功，就直接走后面接的 <code>then(()=&gt;{throw err})</code>，将上一个then的错误传递下去，走line21； 如果line7 <code>resolve(callback())</code> 失败，就走 <code>.then(()=&gt;{throw err})</code> 这里没有失败的接受，就走最外面line21 。</p>
<h5 id="4）（待看视频理解-找不到了…）"><a href="#4）（待看视频理解-找不到了…）" class="headerlink" title="4）（待看视频理解 找不到了…）"></a>4）（待看视频理解 找不到了…）</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.resolve().then(<span class="built_in">console</span>.log(<span class="string">'now'</span>));</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'next'</span>);</span><br><span class="line"><span class="comment">//执行结果： now   next</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">	<span class="comment">// 这里才是 executor</span></span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">'now'</span>)</span><br><span class="line">	resolve(<span class="string">'hello'</span>)</span><br><span class="line">&#125;).then(<span class="function"><span class="params">d</span> =&gt;</span> <span class="built_in">console</span>.log(d))</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'next'</span>)</span><br><span class="line"><span class="comment">// 执行结果： now  next  hello</span></span><br><span class="line"><span class="comment">//下面这个能理解， 上面这个理解不了</span></span><br></pre></td></tr></table></figure>

<p>相当于是then的成功回调，then里new 的promise2的executor立即执行，当前状态已经  FULFILLED，然后setTimeout执行的promise2的resolve</p>
<h5 id="5）Promise-race-赛跑-哪个快用哪个"><a href="#5）Promise-race-赛跑-哪个快用哪个" class="headerlink" title="5）Promise.race 赛跑 哪个快用哪个"></a>5）Promise.race 赛跑 哪个快用哪个</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>( <span class="function">(<span class="params">resolve, reject</span>)=&gt;</span>&#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">        resolve(<span class="string">'p1 ok'</span>);</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">let</span> p2 = <span class="keyword">new</span> <span class="built_in">Promise</span>( <span class="function">(<span class="params">resolve, reject</span>)=&gt;</span>&#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">        resolve(<span class="string">'p2 ok'</span>);</span><br><span class="line">    &#125;, <span class="number">2000</span>);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">Promise</span>.race([p1, p2]).then(<span class="function"><span class="params">data</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'success:'</span>, data); <span class="comment">//success: p1 ok</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>示例</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Promsie.race</span></span><br><span class="line"><span class="keyword">let</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>).promises; </span><br><span class="line"><span class="built_in">Promise</span>.race([fs.readFile(__dirname+<span class="string">'/name.txt'</span>, <span class="string">'utf8'</span>), <span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,fs.readFile(__dirname+<span class="string">'/age.txt'</span>, <span class="string">'utf8'</span>),<span class="number">123</span>]).then(<span class="function"><span class="params">data</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(data);</span><br><span class="line">&#125;,err=&gt;&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err);</span><br><span class="line">&#125;)  </span><br><span class="line"><span class="comment">// 4    注意：如果这里面读取name.txt的时候是失败的 也能成功读取到4</span></span><br><span class="line"><span class="comment">// 个人理解：如果其中有执行完成的，其他正在执行的还是会继续执行 因为promise是立即执行的，并不会中断</span></span><br></pre></td></tr></table></figure>

<p>手写一个race</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.race = <span class="function"><span class="keyword">function</span>(<span class="params">promises</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>( <span class="function">(<span class="params">resolve, reject</span>) =&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; promises.length; i++)&#123;</span><br><span class="line">            promises[i].then(resolve,reject); <span class="comment">// 这里只要一个成功就成功，一个失败就失败</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>( <span class="function">(<span class="params">resolve, reject</span>)=&gt;</span>&#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">        resolve(<span class="string">'p1 ok'</span>);</span><br><span class="line">        <span class="comment">// reject('p1 ok');</span></span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">let</span> p2 = <span class="keyword">new</span> <span class="built_in">Promise</span>( <span class="function">(<span class="params">resolve, reject</span>)=&gt;</span>&#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">        resolve(<span class="string">'p2 ok'</span>);</span><br><span class="line">    &#125;, <span class="number">2000</span>);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">Promise</span>.race([p1, p2]).then(<span class="function"><span class="params">data</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'success:'</span>, data); <span class="comment">//success: p1 ok</span></span><br><span class="line">&#125;, err=&gt;&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'err:'</span>, err) <span class="comment">// err: p1 ok</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>应用场景 ：一个网站有个接口 在两个服务器上 谁快用谁</p>
<h5 id="6）题目：-如何放弃某个promise的执行结果？"><a href="#6）题目：-如何放弃某个promise的执行结果？" class="headerlink" title="6）题目： 如何放弃某个promise的执行结果？"></a>6）题目： 如何放弃某个promise的执行结果？</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>( <span class="function">(<span class="params">resolve, reject</span>)=&gt;</span>&#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">        resolve(<span class="string">'ok'</span>);</span><br><span class="line">    &#125;, <span class="number">3000</span>);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">p.then( <span class="function"><span class="params">data</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'过三秒之后执行结果：'</span>, data);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 这里肯定是过3秒之后返回结果 我希望的是如果过了2秒还没有返回结果就调p.then里面的失败方法</span></span><br></pre></td></tr></table></figure>

<p>如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">wrap</span>(<span class="params">p1</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> fail = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">let</span> p2= <span class="keyword">new</span> <span class="built_in">Promise</span>( <span class="function">(<span class="params">resolve, reject</span>)=&gt;</span>&#123;</span><br><span class="line">        fail = reject; <span class="comment">// 将p2里失败的方法暴露出来</span></span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">let</span> p = <span class="built_in">Promise</span>.race([p1, p2]); <span class="comment">// race方法返回的也是promise</span></span><br><span class="line">    p.abort = fail;</span><br><span class="line">    <span class="keyword">return</span> p; <span class="comment">// 返回一个promise</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p = wrap(<span class="keyword">new</span> <span class="built_in">Promise</span>( <span class="function">(<span class="params">resolve, reject</span>)=&gt;</span>&#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">        resolve(<span class="string">'ok'</span>);</span><br><span class="line">    &#125;, <span class="number">3000</span>);</span><br><span class="line">&#125;))</span><br><span class="line">p.abort(<span class="string">'error~~'</span>); <span class="comment">// 终止</span></span><br><span class="line">p.then( <span class="function"><span class="params">data</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'过三秒之后执行结果：'</span>, data);</span><br><span class="line">&#125;, err=&gt;&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'返回错误'</span>, err); <span class="comment">// 返回错误 error~~</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h5 id="7-Promise-try-这个方法现在不支持"><a href="#7-Promise-try-这个方法现在不支持" class="headerlink" title="7) Promise.try 这个方法现在不支持"></a>7) Promise.try 这个方法现在不支持</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 既能捕获同步 也能捕获异步</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>)</span>&#123; <span class="comment">// 如果函数中抛出了同步错误 要通过try-catch来捕获异常</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这个是异步错误</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>( <span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            reject();</span><br><span class="line">        &#125;, <span class="number">3000</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.try = <span class="function"><span class="keyword">function</span>(<span class="params">callback</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 因为后面可以调.catch 所以其实Promise.try返回的是一个promise</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>( <span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">//callback(); // 这个callback有可能是promsie也有可能不是 所以这里要把它变成promise</span></span><br><span class="line">        <span class="comment">// Promise.resolve只能返回一个成功的promise  ？有疑问它后面跟的then不是既能捕获成功也能捕获失败，为什么说Promise.resolve只能返回一个成功的promise</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve(callback()).then(resolve, reject);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Promise</span>.try(fn).catch(<span class="function"><span class="params">err</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'err'</span>, err);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h5 id="8-Promise-all-全部"><a href="#8-Promise-all-全部" class="headerlink" title="8) Promise.all 全部"></a>8) Promise.all 全部</h5><p>处理多个异步并发的问题</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>).promises; </span><br><span class="line"><span class="comment">// 提供promises这个方法 用了这方法以后 fs上面所有的方法都变成promise的了，所以可以如下这样</span></span><br><span class="line">fs.readFile(__dirname+<span class="string">'/name.txt'</span>, <span class="string">'utf8'</span>).then(<span class="function"><span class="params">data</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(data);</span><br><span class="line">&#125;)</span><br><span class="line">fs.readFile(__dirname+<span class="string">'/age.txt'</span>, <span class="string">'utf8'</span>).then(<span class="function"><span class="params">data</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(data);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>全部完成才算完成 如果有一个失败就失败  Promsie.all是按照顺序执行的</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>).promises; </span><br><span class="line"><span class="built_in">Promise</span>.all([<span class="number">1</span>, <span class="number">2</span>, fs.readFile(__dirname+<span class="string">'/name.txt'</span>, <span class="string">'utf8'</span>), <span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,fs.readFile(__dirname+<span class="string">'/age.txt'</span>, <span class="string">'utf8'</span>),<span class="number">123</span>]).then(<span class="function"><span class="params">data</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(data);</span><br><span class="line">&#125;,err=&gt;&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// [ 1, 2, 'age.txt', 4, 5, 6, '18', 123 ]</span></span><br></pre></td></tr></table></figure>

<p>手写Promise.all</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> isPromise = <span class="function"><span class="params">value</span> =&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>( (<span class="keyword">typeof</span> value === <span class="string">'object'</span> &amp;&amp; value !== <span class="literal">null</span>) || <span class="keyword">typeof</span> value === <span class="string">'function'</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">typeof</span> value.then === <span class="string">'function'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Promise</span>.all = <span class="function"><span class="keyword">function</span>(<span class="params">promises</span>)</span>&#123; <span class="comment">// 因为Promise.all返回的是结果调用的是then所以这里要返回promise</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>( <span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> arr = []; <span class="comment">// 存放最终结果的</span></span><br><span class="line">        <span class="keyword">let</span> i = <span class="number">0</span>; <span class="comment">// 索引</span></span><br><span class="line">        <span class="keyword">let</span> processData = <span class="function">(<span class="params">index, data</span>) =&gt;</span>&#123;</span><br><span class="line">            arr[index] = data;</span><br><span class="line">            <span class="keyword">if</span>(++i === promises)&#123; <span class="comment">// 将数据存放到数组中，成功的数量和传入的数量相等时抛出即可</span></span><br><span class="line">                resolve(arr);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; promises.length; i ++ )&#123;</span><br><span class="line">            <span class="keyword">let</span> current = promises[i]; <span class="comment">// 这里要判断current是否为promise</span></span><br><span class="line">            <span class="keyword">if</span>(isPromise(current))&#123;</span><br><span class="line">                current.then(<span class="function"><span class="params">data</span>=&gt;</span>&#123;</span><br><span class="line">                    processData(i, data);</span><br><span class="line">                &#125;,reject);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                processData(i, current);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="ES6中的Promise"><a href="#ES6中的Promise" class="headerlink" title="ES6中的Promise"></a>ES6中的Promise</h3><h4 id="catch"><a href="#catch" class="headerlink" title="catch"></a>catch</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  resolve(<span class="number">1</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line">&#125;).then(<span class="function"><span class="params">r</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(r);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，调用resolve(1)以后，后面的console.log(2)还是会执行，并且会首先打印出来。这是因为立即 resolved 的 Promise 是在本轮事件循环的末尾执行，总是晚于本轮循环的同步任务。</p>
<p>一般来说，调用resolve或reject以后，Promise 的使命就完成了，后继操作应该放到then方法里面，而不应该直接写在resolve或reject的后面。所以，最好在它们前面加上return语句，这样就不会有意外。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> resolve(<span class="number">1</span>);</span><br><span class="line">  <span class="comment">// 后面的语句不会执行</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>跟传统的try/catch代码块不同的是，如果没有使用catch()方法指定错误处理的回调函数，Promise 对象抛出的错误不会传递到外层代码，即不会有任何反应。<br>内部有语法错误,浏览器运行到这一行，会打印出错误提示，但是不会退出进程、终止脚本执行。</p>
<h4 id="Promise-all"><a href="#Promise-all" class="headerlink" title="Promise.all"></a>Promise.all</h4><p>注意，如果作为参数的 Promise 实例，自己定义了catch方法，那么它一旦被rejected，并不会触发Promise.all()的catch方法。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  resolve(<span class="string">'hello'</span>);</span><br><span class="line">&#125;)</span><br><span class="line">.then(<span class="function"><span class="params">result</span> =&gt;</span> result)</span><br><span class="line">.catch(<span class="function"><span class="params">e</span> =&gt;</span> e);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'报错了'</span>);</span><br><span class="line">&#125;)</span><br><span class="line">.then(<span class="function"><span class="params">result</span> =&gt;</span> result)</span><br><span class="line">.catch(<span class="function"><span class="params">e</span> =&gt;</span> e);</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.all([p1, p2])</span><br><span class="line">.then(<span class="function"><span class="params">result</span> =&gt;</span> <span class="built_in">console</span>.log(result))</span><br><span class="line">.catch(<span class="function"><span class="params">e</span> =&gt;</span> <span class="built_in">console</span>.log(e));</span><br><span class="line"><span class="comment">// ["hello", Error: 报错了]</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，p1会resolved，p2首先会rejected，但是p2有自己的catch方法，该方法返回的是一个新的 Promise 实例，p2指向的实际上是这个实例。该实例执行完catch方法后，也会变成resolved，导致Promise.all()方法参数里面的两个实例都会resolved，因此会调用then方法指定的回调函数，而不会调用catch方法指定的回调函数。</p>
<p>如果p2没有自己的catch方法，就会调用Promise.all()的catch方法。</p>
]]></content>
      <categories>
        <category>ES6</category>
      </categories>
  </entry>
  <entry>
    <title>柯里化</title>
    <url>/2019/08/26/Currying/</url>
    <content><![CDATA[<h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>将一个函数拆分成多个函数</p>
<hr>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 判断类型 Object.prototype.toString.call</span></span><br><span class="line"><span class="keyword">const</span> checkType = <span class="function">(<span class="params">content, type</span>) =&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Object</span>.prototype.toString.call(content) === <span class="string">`[object <span class="subst">$&#123;type&#125;</span>]`</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> b = checkType(<span class="number">123</span>, <span class="string">'Number'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(b); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<h3 id="示例拓展："><a href="#示例拓展：" class="headerlink" title="示例拓展："></a>示例拓展：</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> b = checkType(<span class="number">123</span>, <span class="string">'Number'</span>);</span><br><span class="line"><span class="comment">// 当用户传入向 'Number'这样的会有传入拼写错误的情况 </span></span><br><span class="line"><span class="comment">// 如果用户传入的 'Number'错误，那这个方法就会返回false</span></span><br></pre></td></tr></table></figure>

<a id="more"></a>
<p>所以现在想要 类似于 isString(‘12345’)这样实现，因为如果方法名写错会报错，而‘Number’这个字符串写错 结果就是false了</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> checkType = <span class="function">(<span class="params">type</span>) =&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function">(<span class="params">content</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Object</span>.prototype.toString.call(content) === <span class="string">`[object <span class="subst">$&#123;type&#125;</span>]`</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> isString = checkType(<span class="string">'String'</span>);</span><br><span class="line"><span class="keyword">let</span> res = isString(<span class="string">'1234'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(res); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>如上line1-5将一个函数（checkType ）拆分成了2个更细小的部分<br>当执行line6时 传过去的‘String’ 保存到了line2-4这个函数的作用域中</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">(content) =&gt; &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">Object</span>.prototype.toString.call(content) === <span class="string">`[object <span class="subst">$&#123;type&#125;</span>]`</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>它返回的函数 可以在其他作用域（即line7） 中执行   即为<code>闭包</code>，函数checkType返回的值可以在其他作用域中执行</p>
<h3 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h3><h4 id="函数柯里化怎么实现"><a href="#函数柯里化怎么实现" class="headerlink" title="函数柯里化怎么实现"></a>函数柯里化怎么实现</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">add(<span class="number">1</span>,<span class="number">2</span>)(<span class="number">3</span>)(<span class="number">4</span>)(<span class="number">5</span>); <span class="comment">// 15</span></span><br></pre></td></tr></table></figure>

<p>这里可以构建add函数如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> add = <span class="function">(<span class="params">a, b, c, d, e</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a + b + c + d + e;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>分析：当调用的参数个数为5 == 该函数本身参数个数的时候才执行了return 所以app(1,2)时返回一个函数，app(3)时返回一个函数…<br>每次调用的时候存值[1,2,3,4,5]当这个数组中的个数和这个方法中的参数个数相等时执行。<br>完整代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> add = <span class="function">(<span class="params">a, b, c, d, e</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a + b + c + d + e;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> curring = <span class="function">(<span class="params">fn, arr = []</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> len = fn.length;  <span class="comment">// 函数的长度是参数的个数 所以这里的len代表函数add的参数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function">(<span class="params">...args</span>) =&gt;</span> &#123;</span><br><span class="line">        arr = arr.concat(args);</span><br><span class="line">        <span class="keyword">if</span>(arr.length &lt; len)&#123;</span><br><span class="line">            <span class="keyword">return</span> curring(fn, arr);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> fn(...arr);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> curry = currying(add)(<span class="number">1</span>,<span class="number">2</span>)(<span class="number">3</span>)(<span class="number">4</span>)(<span class="number">5</span>);</span><br><span class="line"><span class="built_in">console</span>.log(curry); <span class="comment">// 15</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 自己实现</span></span><br><span class="line"><span class="keyword">const</span> add = <span class="function">(<span class="params">a,b,c,d,e</span>) =&gt;</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a + b+ c+ d +e;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> curring = <span class="function">(<span class="params">fn, arr = []</span>) =&gt;</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">    arr.push(...arguments);</span><br><span class="line">    <span class="keyword">if</span>(arr.length === fn.length)&#123;</span><br><span class="line">      <span class="keyword">return</span> fn(...arr);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> curring(fn, arr);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> _add = curring(add);</span><br><span class="line"><span class="built_in">console</span>.log(_add(<span class="number">1</span>,<span class="number">2</span>)(<span class="number">3</span>)(<span class="number">4</span>)(<span class="number">5</span>)); <span class="comment">// 15</span></span><br></pre></td></tr></table></figure>

<p>以上为通用柯里化，好处是可以把函数更细化。<br>利用闭包将函数的参数储存起来，等参数达到一定数量时执行函数。</p>
<h3 id="示例拓展优化"><a href="#示例拓展优化" class="headerlink" title="示例拓展优化"></a>示例拓展优化</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 用checkType实现</span></span><br><span class="line"><span class="keyword">const</span> curring = <span class="function">(<span class="params">fn, arr = []</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> len = fn.length; </span><br><span class="line">    <span class="keyword">return</span> <span class="function">(<span class="params">...args</span>) =&gt;</span> &#123;</span><br><span class="line">        arr = arr.concat(args);</span><br><span class="line">        <span class="keyword">if</span>(arr.length &lt; len)&#123;</span><br><span class="line">            <span class="keyword">return</span> curring(fn, arr);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> fn(...arr);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> checkType = <span class="function">(<span class="params">type, content</span>) =&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Object</span>.prototype.toString.call(content) === <span class="string">`[object <span class="subst">$&#123;type&#125;</span>]`</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> types = [<span class="string">'String'</span>, <span class="string">'Number'</span>];</span><br><span class="line"><span class="keyword">let</span> utils = &#123;&#125;;</span><br><span class="line">types.forEach( <span class="function"><span class="params">type</span> =&gt;</span> &#123;</span><br><span class="line">    utils[<span class="string">"is"</span> + type] = curring(checkType)(type);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(utils.isString(<span class="string">'123'</span>)); <span class="comment">// true</span></span><br><span class="line"><span class="comment">// 这个调用 执行的是line4-10区域</span></span><br><span class="line"><span class="built_in">console</span>.log(curring(checkType)(<span class="string">'String'</span>)(<span class="string">'123'</span>)); <span class="comment">// true</span></span><br><span class="line"><span class="comment">// 当前行的执行 其实就是line17-20，只是18行先将类型传了过去与上面的内容一样 不让用户传类似‘String’，而是传isString()函数，这样直接调用。</span></span><br></pre></td></tr></table></figure>

<h3 id="柯里化的作用"><a href="#柯里化的作用" class="headerlink" title="柯里化的作用"></a>柯里化的作用</h3><h4 id="参数复用"><a href="#参数复用" class="headerlink" title="参数复用"></a>参数复用</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">volume</span>(<span class="params">length, width, height</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> length * width * height;</span><br><span class="line">&#125;</span><br><span class="line">volume(<span class="number">200</span>, <span class="number">100</span>, <span class="number">200</span>);</span><br><span class="line">volume(<span class="number">200</span>, <span class="number">150</span>, <span class="number">100</span>);</span><br><span class="line">volume(<span class="number">200</span>, <span class="number">50</span>, <span class="number">80</span>);</span><br><span class="line">volume(<span class="number">100</span>, <span class="number">50</span>, <span class="number">60</span>);</span><br></pre></td></tr></table></figure>

<p>如上计算长方体的体积函数会发现存在很多相同长度的长方体，我们再用柯里化函数实现一下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">volume</span>(<span class="params">length, width, height</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">width</span>) </span>&#123;</span><br><span class="line">    	<span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">height</span>) </span>&#123;</span><br><span class="line">         <span class="keyword">return</span> length * width * height;</span><br><span class="line">			&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> len200 = volume(<span class="number">200</span>);</span><br><span class="line">len200(<span class="number">100</span>)(<span class="number">200</span>);</span><br><span class="line">len200(<span class="number">150</span>)(<span class="number">100</span>);</span><br><span class="line">len200(<span class="number">50</span>)(<span class="number">80</span>);</span><br><span class="line">volume(<span class="number">100</span>)(<span class="number">50</span>)(<span class="number">60</span>);</span><br></pre></td></tr></table></figure>

<p>如上，通过实现一个len200函数我们统一处理长度为200的长方体的体积，这就实现了<code>参数复用</code>。</p>
<p>[场景] <a href="https://segmentfault.com/a/1190000010878974" target="_blank" rel="noopener">https://segmentfault.com/a/1190000010878974</a></p>
<blockquote>
<p>Curry 的核心思想是把多参数传入的函数拆成单参数（或部分）函数，内部再返回调用下一个单参数（或部分）函数，依次处理剩余的参数。</p>
</blockquote>
]]></content>
      <categories>
        <category>js基础</category>
      </categories>
  </entry>
  <entry>
    <title>React 事务</title>
    <url>/2019/08/26/React-Transaction/</url>
    <content><![CDATA[<h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>开始的时候 做某件事 结束的时候再做某件事</p>
<hr>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> perform = <span class="function">(<span class="params"> (</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"说话"</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<a id="more"></a>
<p>需要在说话之前做… 需要在说话之后做…</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> perform = <span class="function">(<span class="params">anyMethod, wrapper</span>) =&gt;</span>&#123;</span><br><span class="line">    wrapper.forEach( <span class="function">(<span class="params">item</span>)=&gt;</span>&#123;</span><br><span class="line">        item.close();</span><br><span class="line">    &#125;)</span><br><span class="line">    anyMethod();</span><br><span class="line">    wrapper.forEach( <span class="function">(<span class="params">item</span>)=&gt;</span>&#123;</span><br><span class="line">        item.initilizae();</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">perform = <span class="function">(<span class="params">(</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"说话"</span>);</span><br><span class="line">&#125;,[</span><br><span class="line">    &#123;</span><br><span class="line">        initilizae()&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">"你好1"</span>);</span><br><span class="line">        &#125;,</span><br><span class="line">        close()&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">"再见1"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        initilizae()&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">"你好2"</span>);</span><br><span class="line">        &#125;,</span><br><span class="line">        close()&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">"再见2"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">])</span><br><span class="line"><span class="comment">// 打印结果：</span></span><br><span class="line"><span class="comment">// 再见1</span></span><br><span class="line"><span class="comment">// 再见2</span></span><br><span class="line"><span class="comment">// 说话</span></span><br><span class="line"><span class="comment">// 你好1</span></span><br><span class="line"><span class="comment">// 你好2</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>其他</category>
      </categories>
  </entry>
  <entry>
    <title>高阶函数</title>
    <url>/2019/08/26/Higher-Order-Components/</url>
    <content><![CDATA[<h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><hr>
<p>1、一个函数的参数 是一个函数</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">&#125;</span><br><span class="line">a( <span class="function"><span class="params">()</span>=&gt;</span>&#123;&#125;)  </span><br><span class="line"><span class="comment">// 函数a就是一个高阶函数</span></span><br></pre></td></tr></table></figure>

<p>2、一个函数 返回一个函数</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;  </span><br><span class="line"><span class="comment">// 函数a就是一个高阶函数</span></span><br></pre></td></tr></table></figure>

<a id="more"></a>
<h3 id="简单应用"><a href="#简单应用" class="headerlink" title="简单应用"></a>简单应用</h3><hr>
<h4 id="函数的before"><a href="#函数的before" class="headerlink" title="函数的before"></a>函数的before</h4><p>需求：在“说话”之前要有其他的操作，可以直接在say函数中todo</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> say = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// console.log("张三");</span></span><br><span class="line">    <span class="comment">// console.log("李四");</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'说话'</span>);</span><br><span class="line">&#125;</span><br><span class="line">say();</span><br></pre></td></tr></table></figure>

<p>现在希望将函数的核心部分提取出来 在外面增加功能</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> say = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'说话'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> newSay = say.before( <span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"张三"</span>); <span class="comment">// todo</span></span><br><span class="line">&#125;)</span><br><span class="line">newSay();</span><br><span class="line"><span class="comment">// 在say方法之前加一个before方法，使其在调用say方法的时候 之前先调用before方法</span></span><br></pre></td></tr></table></figure>

<p>在原型上添加before方法</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.before = <span class="function"><span class="keyword">function</span>(<span class="params">beforeFn</span>)</span>&#123; <span class="comment">// 函数的参数是函数  高阶函数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> &#123; <span class="comment">// 在函数中返回一个函数  高阶函数</span></span><br><span class="line">        beforeFn(); </span><br><span class="line">        <span class="keyword">this</span>(); <span class="comment">// 箭头函数中没有this指向，所以会像上级作用域查找</span></span><br><span class="line">        <span class="comment">// 这里面的this会向上级查找  调用这个before方法的是say 即这里执行say方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>合在一起如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.before = <span class="function"><span class="keyword">function</span>(<span class="params">beforeFn</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        beforeFn(); </span><br><span class="line">        <span class="keyword">this</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> say = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'说话'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> newSay = say.before( <span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"张三"</span>);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">const</span> newSay2 = say.before( <span class="function"><span class="params">()</span>=&gt;</span>&#123; <span class="comment">// 示例 2</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"李四"</span>);</span><br><span class="line">&#125;)</span><br><span class="line">newSay(); <span class="comment">// 结果： 张三 说话</span></span><br><span class="line">newSay2(); <span class="comment">// 结果：李四 说话</span></span><br></pre></td></tr></table></figure>

<p>这就是AOP 面向切片编程 或者叫装饰 我们给say方法装饰了一些自己独特的逻辑   这个就是一个典型的高阶函数的使用。<br>AOP的思想：把核心抽离出来 在核心基础上增加功能。</p>
<hr>
<h4 id="拓展：添加参数"><a href="#拓展：添加参数" class="headerlink" title="拓展：添加参数"></a>拓展：添加参数</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.before = <span class="function"><span class="keyword">function</span>(<span class="params">beforeFn</span>)</span>&#123;  </span><br><span class="line">    <span class="keyword">return</span> <span class="function">(<span class="params">...args</span>) =&gt;</span> &#123; <span class="comment">// #1-&gt; </span></span><br><span class="line">	<span class="comment">// 箭头函数中没有this指向 也没有arguments </span></span><br><span class="line">	<span class="comment">// 所以在接受参数的时候可以先把所有的函数参数都接收到一起 ...arg</span></span><br><span class="line">        beforeFn(); </span><br><span class="line">        <span class="keyword">this</span>(...args);  <span class="comment">// 展开运算符 表示把所有的函数参数都展开     </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> say = <span class="function">(<span class="params">...args</span>) =&gt;</span> &#123; <span class="comment">// 剩余运算符 把所有的参数组成一个数组</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'说话'</span>, args);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> newSay = say.before( <span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"张三"</span>);</span><br><span class="line">&#125;)</span><br><span class="line">newSay(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>);</span><br><span class="line"><span class="comment">// 打印结果： </span></span><br><span class="line"><span class="comment">// 张三</span></span><br><span class="line"><span class="comment">// 说话 [ 1, 2, 3 ]</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 疑问： newSay中的123怎么到箭头函数里去了#1-&gt; </span></span><br><span class="line"><span class="comment">// 这里newSay指的是 line2-line7这个return的返回值(函数)，所以把参数传过去了</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>js基础</category>
      </categories>
  </entry>
</search>
